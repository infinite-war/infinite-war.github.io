[{"title":"What's_米家？","url":"/posts/51802/","content":"\n\n# 💩  What's 米家❓ 💩\n\n# 米家发展简史\n\n- 2019年x月y日，<u>dyc</u>于xxx市塘下中学开始传播米家思想，自封零少，并~~擅自~~指名<u>林米</u>为大少、<u>lwy</u>为二少、<u>smd</u>为三少，为未来米家的建立提供了思想基础建设与基础人才储备。\n- 2019年12月z日，陈九日加入米家，按照加入时间成为四少。由于此时的大少掌握大部分资源却无心建设米家，于是四少开始暗中拉帮结派，决心击败林米并成为大少，亲自完成创建米家的重要历史任务。\n- 2020年1月b日，陈九日暗中用大米贿赂lwy，并顺手拉拢新成员<u>谢荣扣</u>（五少）后，以迅雷不及掩耳之势快速击败了林米，自封大少，林米则降级为四少。随后，陈九日全心全意投入到创建米家的任务中。\n- 2020年7月8日，陈九日于<u>xxx市塘下中学351A寝室</u>聚集所有米家成员，宣布了米家的成立，米家势力从此登上历史舞台。\n\n![](/gallery/What's_米家_images/米家交接仪式.jpg)\n\n<p align=\"center\">7月8日米家成立，米家成员留下珍贵合照\n</p>\n\n\n\n![](/gallery/What's_米家_images/米家合照.jpg)\n\n<p align=\"center\">米家大少交接仪式</p>\n\n\n\n- 2020年9月初  在陈九日的计划下，米家成员开始分布至大陆各地，西部有新疆根据地（三少），中部有山西根据地（零少），东部有杭州主根据地（其他成员）。大少力求在大陆多个地区同步实现米家势力的快速发展，米家成员现已渗透医学（三少）、小学教育（零少）、经济（大少、二少、五少）、外语教育（四少）多个行业。随着米家成员的增加，米家的发展将会更加多元化。\n- <strong>至今，米家的发展仍在继续❗❗❗❗❗❗❗❗❗❗❗</strong>\n","categories":[],"tags":["娱乐  高中回忆"]},{"title":"Hello World","url":"/posts/16107/","content":"\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","categories":[],"tags":[]},{"title":"Java 注解与反射","url":"/posts/12475/","content":"\n\n# Java注解与反射\n\n参考视频：BV1p4411P7V3\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/122568162\n# 注解\n\n`Java.Annotation`。与注释不同，注解不仅可以给人看，还可以用于程序运行。\n\nAnnotation可以附加在package、class、method、field等之上，用于添加额外的辅助信息，可以通过<u>反射</u>机制编程实现对这些元数据的访问。\n\n```java\n@注解名\n//代码......\n```\n\n## 常见内置注解\n\n- `@Override`:定义载`java.lang.Override`中，此注解只适用于修辞方法，表示一个方法声明打算重载超类中的另一个方法声明。\n- `@Deprecated`:定义在`java.lang.Deprecated`中，表示不鼓励程序员使用这样的元素。\n- `@SuppressWarnings`:定义在`java.lang.SuppressWarnings`中，用来抑制编译时的警告信息。需要添加参数，如`@SuppressWarnings(\"all\")`，`@SuppressWarnings(\"unchecked\")` ，`@SuppressWarnings(value={\"unchecked\",\"deprecation})`等\n\n## 元注解\n\n目的：用于注解其他注解\n\n`java.lang.annotation`\n\n- `@Target`:用于描述注解的适用范围(即：被描述的注解可以用在什么地方)\n- `@Retention`:表示需要载什么级别保存该注释信息，用于描述注解的生命周期(SOURCE<CLASS<RUNTIME)\n- `@Document`:说明该注解将被包含在javadoc中\n- `@inherited`:说明子类可以继承父类中的该注解\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8a47cfc938d943f2bf7bc81d16861596.png?x-oss-process=image)\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/58684b7a7e6e44269d13fac0e570b6b5.png?x-oss-process=image)\n\n\n\n\n```java\npackage Test;\n\n\nimport java.lang.annotation.*;\n\n@MyAnnotation\npublic class Test{\n    \n    @MyAnnotation\n    public void test(){\n        \n    }\n}\n\n//定义一个注解\n@Target(value={ElementType.METHOD,ElementType.TYPE})  //表示可以用在方法或类上\n@Retention(value= RetentionPolicy.RUNTIME)\n@Documented\n@Inherited //子类可以继承父类的注解\n@interface MyAnnotation{\n    \n}\n```\n\n\n\n## 自定义注解\n\n使用`@interface`自定义注解时，自动继承了`java.lang.annotation.Annotation`接口\n\n```java\npackage Test;\n\nimport java.lang.annotation.*;\n\n@MyAnnotation(name=\"class\")\npublic class Test{\n\n    @MyAnnotation2(\"aaaa\")  //不写复制对象时，默认对value赋值\n    public void test(){\n\n    }\n}\n\n//定义一个注解\n@Target(value={ElementType.METHOD,ElementType.TYPE})  //表示可以用在方法或类上\n@Retention(value= RetentionPolicy.RUNTIME)\n@Documented\n@Inherited //子类可以继承父类的注解\n@interface MyAnnotation{\n    //注解的参数：参数类型+参数名()\n    //default用来设置默认值，若不设置，则必须在写注解时显式赋值\n    String name() default \"\";\n    int age() default 0;\n    int id() default -1;\n\n    String[] schools() default {\"xx大学\",\"yy大学\"};\n}\n\n@Target(value={ElementType.METHOD,ElementType.TYPE})  //表示可以用在方法或类上\n@Retention(value= RetentionPolicy.RUNTIME)\n@interface MyAnnotation2{\n    String value();\n}\n```\n\n\n\n\n\n\n\n# 反射\n\n## 概述\n\n`java.Reflection`\n\n动态语言：C#，python，javascript等。运行时可以根据条件改变结构\n\n静态语言：C，C++，java等。运行时结构不变\n\n反射使java拥有了动态的特性，如运行时创建类\n\n\n\n反射机制允许程序在执行时借助Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。\n\n```java\nClass c=Class.forName(\"java.lang.String\")\n```\n\n加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有哟个Class对象)，这个对象就包含了完成的类的结构信息。我们可以通过这个对象看到类的结构。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4de51408c853445ba43e4486238d440b.png?x-oss-process=image)\n\n\n优点：灵活性更高\n\n缺点：对性能有影响\n\n\n\n## Class类\n\n- Class对象只能由系统建立\n- 一个加载的类在JVM中只会由一个Class实例\n- 一个Class对象对应的时一个加载到JVM中的一个.class文件\n- 每个类的实例都会记得自己是由哪个Class实例所生成的\n- 通过Class可以完整地得到一个类中的所有被加载的结构\n- Class类是Reflection的根源，针对任何想要动态加载、允许的类，必须先获得相应的Class对象\n\n\n\n常用方法\n\n| 方法名                                  | 功能                                                      |\n| --------------------------------------- | --------------------------------------------------------- |\n| static ClassforName(String name)        | 范围指定类名name的Class对象                               |\n| Object newInstance()                    | 调用缺省构造函数，返回Class对象的一个实例                 |\n| getName()                               | 返回此Class对象所表示的实体(类、接口、数组类或void)的名称 |\n| Class getSuperClass()                   | 返回当前Class对象的父类的Class对象                        |\n| Class[] getinterfaces()                 | 获取当前Class对象的接口                                   |\n| ClassLoader getClassLoader()            | 返回该类的类加载器                                        |\n| Constructor[] getConstructors()         | 返回一个包含某些Constructor对象的数组                     |\n| Method getMethod(String name,Class.. T) | 返回一个Method对象，此最想的形参类型为param Type          |\n| Field[] getDeclaredFields()             | 返回Fields对象的一个数组                                  |\n\n\n\n### 获取Class对象\n\n以下类型拥有Class对象(即可以使用  `类名称.class` 获取Class对象)：\n\n- 类：外部类，成员类，局部内部类，匿名内部类\n- interface：接口\n- []：数组\n- enum：枚举\n- annotation：注解@interface\n- primitive type：基本数据类型\n- void\n\n\n\n```java\npackage Test;\n\npublic class Test extends Object{\n    public static void main(String[] args) throws ClassNotFoundException {\n        Person person=new Student();\n        System.out.println(\"这个人是：\"+person.type);\n\n        //方法一：通过对象获得\n        Class c1=person.getClass();\n        System.out.println(c1.hashCode());\n\n        //方法二：forname获得\n        Class c2=Class.forName(\"Test.Student\");\n        System.out.println(c2.hashCode());\n\n        //方法三：通过类名.class获得\n        Class c3=Student.class;\n        System.out.println(c3.hashCode());\n\n        //方法四：基本内置类型的包装类都有一个Type属性\n        Class c4=Integer.TYPE;\n        System.out.println(c4);\n        \n        //获得父类类型\n        Class c5 = c1.getSuperclass();\n        System.out.println(c5);\n    }\n}\n\n\nclass Person{\n    public String type;\n\n    public Person() {\n    }\n\n    public Person(String type) {\n        this.type = type;\n    }\n}\n\nclass Student extends Person{\n    public Student() {\n        this.type=\"学生\";\n    }\n}\n\nclass Teacher extends Person{\n    public Teacher() {\n        this.type=\"老师\";\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dd5c6ae6ab8c4f09a37d01299e7ab1ed.png#pic_center)\n\n\n\n\n\n\n\n\n```java\npackage Test;\n\npublic class Test extends Object{\n    public static void main(String[] args) throws ClassNotFoundException {\n        \n        //通过反射获取类的Class对象\n        Class c1=Class.forName(\"Test.User\");\n        System.out.println(c1);\n        \n        Class c2=Class.forName(\"Test.User\");\n        Class c3=Class.forName(\"Test.User\");\n        Class c4=Class.forName(\"Test.User\");\n        //一个类在内存中只有一个Class对象\n        //一个类加载后，类的整个结构都会被封装在Class对象中\n        System.out.println(c2.hashCode());\n        System.out.println(c3.hashCode());\n        System.out.println(c4.hashCode());\n    }\n}\n\n\n//实体类\nclass User{\n    private String name;\n    private int id;\n    private int age;\n\n    //constructor\n\t//getter()+setter()\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9b6dd1852e514318b58687c2d6d314b5.png?x-oss-process=image)\n\n\n\n## Java内存分析\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ba1646a261b844a09ce13c497a378e74.png?x-oss-process=image)\n\n\n\n### 类加载过程\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/371061ec95a24d3f96b8c303ad9b6155.png?x-oss-process=image)\n\n\n加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象。\n\n链接：将Java类的二进制代码合并到JVM的运行状态之中的过程\n\n- 验证：确保加载的类信息符合JVM规范，没有安全方面的问题。\n- 准备：正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。\n- 解析：JVM常量池内的符号引用(常量名)替换为直接引用(地址)的过程。\n\n初始化(JVM自动完成)：\n\n- 执行类构造器`<clinit>()`方法的过程。该方法是由编译时自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。(构造的是类而不是对象)\n- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。\n- JVM会保证一个类的`<clinit>()`方法在多线程环境中被正确加锁和同步。\n\n\n\n\n\n```java\npackage Test;\n\npublic class Test extends Object{\n    public static void main(String[] args){\n        A a=new A();\n        System.out.println(A.m);\n        /*\n        1.加载到内存，会产生一个类对应的Class对象\n        2.链接，链接结束后m=0\n        3.初始化\n            <clinit>(){\n                System.out.println(“A类静态代码块初始化”);\n                m=300;\n                m=100;\n            }\n            m最终赋值为100\n        */\n    }\n}\n\nclass A{\n    static {\n        System.out.println(\"A类静态代码块初始化\");\n        m=300;\n    }\n    static int m=100;\n    public A(){\n        System.out.println(\"A类的无参构造初始化\");\n    }\n}\n```\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b41ae46dd6e4489eb19921e5caf8867a.png?x-oss-process=image)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f8403ef4691148578f9104673f3f2ec7.png?x-oss-process=image)\n\n\n\n### 类的初始化\n\n类的主动引用(一定会发生类的初始化)：\n\n- JVM启动时，先初始化main方法所在的类\n- new一个类的对象\n- 调用类的静态成员(除了final常量)个静态方法\n- 使用java.lang.reflect包的方法对类进行反射调用\n- 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类\n\n\n\n```java\npackage Test;\n\npublic class Test extends Object{\n\n    static {\n        System.out.println(\"Main类被加载\");\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException {\n        //1.主动引用\n        //Son son=new Son();\n\n        //2.通过反射产生主动调用\n        Class.forName(\"Test.Son\");\n    }\n}\n\nclass Father{\n    static int b=2;\n    static {\n        System.out.println(\"父类被加载\");\n    }\n}\n\nclass Son extends Father{\n    static {\n        System.out.println(\"子类被加载\");\n        m=300;\n    }\n\n    static int m=100;\n    static final int M=1;\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b4d5924fe45f4596bc0bd076d46f9750.png#pic_center)\n\n\n\n\n\n\n类的被动引用(不会发生类的初始化)：\n\n- 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化\n- 通过数组定义类引用，不会触发此类的初始化\n- 引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)\n\n```java\npackage Test;\n\npublic class Test extends Object{\n\n    static {\n        System.out.println(\"Main类被加载\");\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException {\n        //不会产生类的引用的方法\n        //1.调用类内静态变量\n        //System.out.println(Son.b);\n\n        //2.声明类的数组\n        //Son[] son=new Son[5];\n\n        //3.调用类内静态常量\n        System.out.println(Son.M);\n\n    }\n}\n\n//Father、Son类定义\n```\n\n调用类内静态变量\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/221b11e6f86d4110a874382c985647bd.png?x-oss-process=image)\n\n\n声明类的数组\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c9a4f9d71d6a48a0832d533f4f8e2407.png#pic_center)\n\n\n调用类内静态常量\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20ab79d3730248e0846f9811fae409ae.png#pic_center)\n\n\n\n### 类加载器\n\n类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法去的运行时数据结构，然后再队中生成一个代表这个类的`java.lang.Class`对象，作为方法区中数据的访问入口。\n\n类缓存：标准的JavaEE类加载器中可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间，不过JVM垃圾回收机制可以回收这些Class对象。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/38788cf4571a4e49a44f42b595065cbb.png?x-oss-process=image)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e87cb12060954b2fb475946f01d1ac67.png?x-oss-process=image)\n\n\n\n\n\n\n```java\npackage Test;\n\npublic class Test extends Object{\n    public static void main(String[] args) throws ClassNotFoundException {\n        //获取系统类的加载器\n        ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader();\n        System.out.println(systemClassLoader);\n\n        //获取系统类加载器的父类加载器：扩展类加载器\n        ClassLoader parent=systemClassLoader.getParent();\n        System.out.println(parent);\n\n        //获取扩展类加载器的父类加载器：根加载器\n        ClassLoader parent1=parent.getParent();\n        System.out.println(parent1);\n\n        //测试当前类是哪个加载器加载的\n        ClassLoader classLoader=Class.forName(\"Test.Test\").getClassLoader();\n        System.out.println(classLoader);\n        //测试JDK内置的类是谁加载的\n        classLoader=Class.forName(\"java.lang.Object\").getClassLoader();\n        System.out.println(classLoader);\n        \n        //如何获得系统类加载器可以加载的所有路径\n        System.out.println(System.getProperty(\"java.class.path\"));\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5b370747c78c483390fdbe975d1b4f9d.png?x-oss-process=image)\n\n\n双亲委派机制：加入写了一个跟已有包重名的包(如自己写了java.lang.String)，系统会自动选择原有的java.lang.String包，保证安全性。\n\n\n\n## 获取类的运行时结构\n\n通过反射获取运行时类的完整结构：Field、Method、Constructor、Superclass、Interface、Annotation\n\n```java\npackage Test;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class Test extends Object{\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {\n        Class c1=Class.forName(\"Test.User\");\n\n        //获得类的名字\n        System.out.println(c1.getName());  //获得包名+类名\n        System.out.println(c1.getSimpleName()); //获得类名\n\n        //获得类的属性\n        System.out.println(\"=================================================\");\n        //c1.getFields()只能获取public属性\n        Field[] fields=c1.getDeclaredFields(); //获取所有类型的属性\n        for(Field field:fields){\n            System.out.println(field);\n        }\n\n        //获得指定属性的值\n        Field name=c1.getDeclaredField(\"name\");\n        System.out.println(name);\n\n        //获得类的方法\n        System.out.println(\"==============================================\");\n        Method[] methods=c1.getMethods(); //获取当前类及其超类的所有方法\n        for(Method method:methods){\n            System.out.println(method);\n        }\n\n        methods=c1.getDeclaredMethods(); //获取当前类的所有方法\n        for(Method method:methods){\n            System.out.println(method);\n        }\n\n        //获得特定方法\n        //重载\n        Method getName=c1.getMethod(\"getName\",null);\n        Method setName=c1.getMethod(\"setName\",String.class);\n        System.out.println(getName);\n        System.out.println(setName);\n\n\n        //获得构造器\n        System.out.println(\"==========================================\");\n        Constructor[] constructors=c1.getConstructors(); //只能获得public方法\n        for(Constructor constructor:constructors){\n            System.out.println(constructor);\n        }\n        constructors=c1.getDeclaredConstructors();\n        for(Constructor constructor:constructors){\n            System.out.println(constructor);\n        }\n\n        //获得指定构造器\n        Constructor declaredConstructor=c1.getDeclaredConstructor(String.class,int.class,int.class);\n        System.out.println(declaredConstructor);\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dbce163c07a24f64844dd39f65a4db39.png?x-oss-process=image)\n\n\n\n## 动态创建对象\n\n```java\npackage Test;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Test extends Object{\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        //获取Class对象\n        Class c1=Class.forName(\"Test.User\");\n\n        //通过反射构造一个对象\n        User user=(User) c1.newInstance();  //本质是调用无参构造。若类里没有实现无参构造，就会报错\n        System.out.println(user.toString());\n\n        System.out.println(\"\\n================================\\n\");\n        //通过构造器创建对象\n        Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);//指定构造器\n        User user2=(User)constructor.newInstance(\"张三\",001,10);\n        System.out.println(user2.toString());\n\n        System.out.println(\"\\n================================\\n\");\n        //通过反射调用普通方法\n        User user3=(User)c1.newInstance();\n        Method setName=c1.getDeclaredMethod(\"setName\",String.class);\n        //invoke为激活方法\n        setName.invoke(user3,\"李四\");\n        System.out.println(user3.toString());\n\n        System.out.println(\"\\n================================\\n\");\n        //通过反射操作属性\n        User user4=(User)c1.newInstance();\n        Field name=c1.getDeclaredField(\"name\");\n\n        //User中的name是private类型，通过下面方法设置为可以直接访问\n        name.setAccessible(true);\n        name.set(user4,\"王五\");\n        System.out.println(user4.toString());\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/089b72ee00364e028fbc3f479774be5e.png?x-oss-process=image)\n\n\n\n\n`Object invoke(Object obj,Object ... args)`\n\n- Object对应原方法的返回值，若原方法无返回值，此时返回null\n- 若原方法为静态方法，此时形参Object obj可以为null\n- 若原方法形参列表为空，则Object[] args为null\n- 若原方法声明为private，则需要再使用invoke前，显示调用方法对象的`setAccessible(true)`方法，将可以访问private方法(属性同理)\n\n`setAccessible`(boolean x)\n\n- Method、Field、Constructor对象都有setAccessible()方法\n- setAccessible作用是启动和禁用访问安全检查的开关。默认为false，说明反射的对象应该实施Java语言访问检查。true代表反射的对象在使用时应该取消Java语言访问检查\n\n\n\n\n\n### 性能分析\n\n```java\npackage Test;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Test extends Object{\n    //普通方式\n    public static void test1(){\n        User user=new User();\n        long startTime=System.currentTimeMillis();\n\n        for(int i=0;i<1000000000;i++){\n            user.getName();\n        }\n        long endTime=System.currentTimeMillis();\n        System.out.println(\"普通方式执行10亿次：\"+(endTime-startTime)+\"ms\");\n    }\n\n    //反射方式\n    public static void test2() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        User user=new User();\n        Class c1=user.getClass();\n\n        Method getName=c1.getDeclaredMethod(\"getName\",null);\n\n        long startTime=System.currentTimeMillis();\n\n        for(int i=0;i<1000000000;i++){\n            getName.invoke(user,null);\n        }\n        long endTime=System.currentTimeMillis();\n        System.out.println(\"反射方式执行10亿次：\"+(endTime-startTime)+\"ms\");\n    }\n\n    //反射方式  关闭访问权限检测\n    public static void test3() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        User user=new User();\n        Class c1=user.getClass();\n\n        Method getName=c1.getDeclaredMethod(\"getName\",null);\n        getName.setAccessible(true);\n\n        long startTime=System.currentTimeMillis();\n\n        for(int i=0;i<1000000000;i++){\n            getName.invoke(user,null);\n        }\n        long endTime=System.currentTimeMillis();\n        System.out.println(\"反射方式(关闭检测)执行10亿次：\"+(endTime-startTime)+\"ms\");\n    }\n\n\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        test1();\n        test2();\n        test3();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/876d7585c7b14555ac07ab0846fe1748.png?x-oss-process=image)\n\n\n\n## 获取泛型信息\n\nJava采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题。但是，一旦编译完成，所有和泛型有关的类型会全部擦除。\n\n为了通过反射操作这些类型，Java新增了集中类型来代表<u>不能被归到Class类中的类型 但是 又和原始类型其名</u>的类型：\n\n- `ParameterizedType`:表示一种参数化类型，如：`Collection<String>`\n- `GenericArrayType`:表示一种元素类型是参数化类型或者类型变量的数组类型\n- `TyprVariable`：是各种类型变量的公共父接口\n- `WildcardType`：代表一种通配符类型表达式\n\n\n\n```java\npackage Test;\n\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Test extends Object{\n\n    public void test1(Map<String,User> map, List<User> list){\n        System.out.println(\"test1\");\n    }\n\n    public Map<String,User> test2(){\n        System.out.println(\"test2\");\n        return null;\n    }\n\n    public static void main(String[] args) throws NoSuchMethodException {\n        Method method=Test.class.getMethod(\"test1\",Map.class,List.class);\n\n        Type[] genericParameterTypes=method.getGenericParameterTypes();\n        for(Type type:genericParameterTypes){\n            System.out.println(\"#\"+type);\n            if(type instanceof ParameterizedType){\n                Type[] actualTypeArguments=((ParameterizedType)type).getActualTypeArguments();\n                for(Type actualTypeArgument:actualTypeArguments){\n                    System.out.println(actualTypeArgument);\n                }\n            }\n        }\n\n        method=Test.class.getMethod(\"test2\",null);\n        Type genericReturnType=method.getGenericReturnType();\n\n        if(genericReturnType instanceof ParameterizedType){\n            Type[] actualTypeArguments=((ParameterizedType)genericReturnType).getActualTypeArguments();\n            for(Type actualTypeArgument:actualTypeArguments){\n                System.out.println(actualTypeArgument);\n            }\n        }\n\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/80a5eb892be94e51bf91aed1c57e8917.png?x-oss-process=image)\n\n## 获取注解信息\n\n```java\npackage Test;\n\nimport java.lang.annotation.*;\nimport java.lang.reflect.Field;\n\npublic class Test{\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        Class c1 = Class.forName(\"Test.Student\");\n        //通过反射获得注解\n        Annotation[] annotations=c1.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation);\n        }\n\n        //获取注解的值\n        MyTable table=(MyTable) c1.getAnnotation(MyTable.class);\n        String value=table.value();\n        System.out.println(value);\n\n        System.out.println(\"=======================================\");\n        //获得类指定的注解\n        Field f=c1.getDeclaredField(\"name\");\n        MyField annotation=f.getAnnotation(MyField.class);\n        System.out.println(annotation.coloumName());\n        System.out.println(annotation.type());\n        System.out.println(annotation.length());\n    }\n}\n\n//学生类\n@MyTable(\"db_student\")\nclass Student{\n    @MyField(coloumName = \"db_id\",type = \"int\",length = 10)\n    private int id;\n    @MyField(coloumName = \"db_age\",type = \"int\",length = 10)\n    private int age;\n    @MyField(coloumName = \"db_name\",type = \"varchar\",length = 3)\n    private String name;\n\n    //constructor...\n    //getter、setter...\n    //toString...\n}\n\n\n//类名的注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface MyTable{\n    String value();\n}\n\n//属性的注解\n@Target({ElementType.FIELD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@interface MyField{\n    String coloumName();\n    String type();\n    int length();\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/28aae089b10e4ae3bb15eae52d5ecba0.png?x-oss-process=image)\n\n\n\n\n\n","categories":[],"tags":["JavaSE"]},{"title":"Java 多线程基础","url":"/posts/24112/","content":"\n\n# Java多线程\n\n参考视频:BV1V4411p7EF\n\n并发相关概念已经学过，可以直接参考操作系统相关书籍，这里不再记录。\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/122547019\n# 线程创建\n\n父类：Thread   (java.lang.Thread)\n接口：Runnable、Callable\n\n## 创建Thread\n\n\n\n```java\npackage Multics;\n\npublic class TestThread extends Thread{\n    @Override\n    public void run() {\n        //run方法线程体\n        for(int i=0;i<20;i++){\n            System.out.println(\"吃饭\");\n        }\n    }\n\n    public static void main(String[] args) {\n        //主线程\n\n        //创建一个线程对象\n        TestThread testThread=new TestThread();\n\n        //调用start()方法开启线程。调用run()方法不会实现并发\n        testThread.start();\n\n        for(int i=0;i<40;i++){\n            System.out.println(\"看电视\");\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/184e9b96564944b0aa5a5f8395bc50f5.png#pic_center)\n\n\n注：每次执行结果可能不一样\n\n\n\n## 多线程网图下载\n\n可用工具包：https://commons.apache.org/proper/commons-io/download_io.cgi\n\n```java\npackage Multics;\n\nimport org.apache.commons.io.FileUtils;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class TestThread extends Thread{\n    private String url;\n    private String name;\n\n    public TestThread(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n    //下载图片执行体\n    @Override\n    public void run() {\n        WebDownloader webDownloader=new WebDownloader();\n        webDownloader.downloader(url,name);\n        System.out.println(\"下载的文件名为：\"+name);\n    }\n\n    public static void main(String[] args) {\n        TestThread t1=new TestThread(\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F1d%2Fd7%2F74%2F1dd7742b0e08837f0afb77d3c9006a75.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644976584&t=c01c909514022ae483b88d1f5570fe2d\",\"1.jpg\");\n        TestThread t2=new TestThread(\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2020-11-06%2F5fa4dec85d63f.jpg&refer=http%3A%2F%2Fpic1.win4000.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644976692&t=f0ec64a96d2eba5ebd5942bd42381e53\",\"2.jpg\");\n        TestThread t3=new TestThread(\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.3dmgame.com%2Fuploads%2Fimages%2Fnews%2F20200701%2F1593590839_180447.jpg&refer=http%3A%2F%2Fimg.3dmgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644976721&t=6d631b3087b6a7ef424b4d7c74e1aa15\",\"3.jpg\");\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n\n}\n\n\n//下载器\nclass WebDownloader{\n    public void downloader(String url,String name){\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"downloader方法出现IO异常\");\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d5a74a2627374d578e867a5aea0ff0dc.png?x-oss-process=image)\n\n\n\n## 实现Runnable接口\n\n\n\n```java\n// 1.1创建Thread改写\npackage Multics;\n\npublic class TestThread implements Runnable{\n    @Override\n    public void run() {\n        //run方法线程体\n        for(int i=0;i<20;i++){\n            System.out.println(\"吃饭\");\n        }\n    }\n\n    public static void main(String[] args) {\n        //创建Runnable接口的实现类对象\n        TestThread testThread1=new TestThread();\n\n        //创建线程对象，通过线程对象来开启线程，又称代理\n        Thread thread=new Thread(testThread1);\n        thread.start();\n        //上面两行也可以简写成  new Thread(testThread1).start();\n\n        for(int i=0;i<40;i++){\n            System.out.println(\"看电视\");\n        }\n    }\n}\n```\n\n\n\n```java\npackage Multics;\n\nimport org.apache.commons.io.FileUtils;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class TestThread implements Runnable{\n    \n    //......\n    \n    public static void main(String[] args) {\n        //创建t1,t2,t3\n\t\t//......\n        \n        new Thread(t1).start();\n        new Thread(t2).start();\n        new Thread(t3).start();\n        \n    }\n\n}\n\n\n//下载器\n//......\n```\n\n\n\n| 继承Thread类                    | 实现Runnable接口                                             |\n| ------------------------------- | ------------------------------------------------------------ |\n| 子类继承Thread类具备多线程能力  | 实现接口Runnable具有多线程能力                               |\n| 启动线程：子类对象.start()      | 启动线程：传入目标对象+Thread对象.start()                    |\n| 不建议使用：避免OOP单继承局限性 | 推荐使用：避免单继承的局限性，灵活方便，便于同一个对象被多个线程使用 |\n\n\n\n## 实现Callable接口（次要）\n\n```java\npackage Multics;\n\nimport org.apache.commons.io.FileUtils;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.concurrent.*;\n\n/**\n*  1.2网图下载改写\n*/\npublic class TestThread implements Callable<Boolean>{\n    private String url;\n    private String name;\n\n    public TestThread(String url, String name) {\n        this.url = url;\n        this.name = name;\n    }\n\n    //下载图片执行体\n    @Override\n    public Boolean call() {\n        WebDownloader webDownloader=new WebDownloader();\n        webDownloader.downloader(url,name);\n        System.out.println(\"下载的文件名为：\"+name);\n        return true;\n    }\n\n    public static void main(String[] args) throws Exception{\n        //创建t1,t2,t3\n        //......\n        \n        \n        //创建执行服务\n        ExecutorService ser= Executors.newFixedThreadPool(3); //线程池\n\n        //提交执行\n        Future<Boolean> r1=ser.submit(t1);\n        Future<Boolean> r2=ser.submit(t2);\n        Future<Boolean> r3=ser.submit(t3);\n\n        //获取结果\n        boolean rs1=r1.get();\n        boolean rs2=r2.get();\n        boolean rs3=r3.get();\n\n        //关闭服务\n        ser.shutdown();\n    }\n}\n\n\n//下载器\n//......\n```\n\n实现Callable接口的好处：\n\n1. 可以定义返回值\n2. 可以抛出异常\n\n\n\n## 例子：购买火车票\n\n多个线程操作同一个对象\n\n```java\npackage Multics;\n\nimport org.apache.commons.io.FileUtils;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class TestThread implements Runnable{\n\n    //剩余票数\n    private int ticketNums=10;\n\n    @Override\n    public void run() {\n        while(true){\n            if(ticketNums<=0){\n                break;\n            }\n\n            //模拟延时\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\"-->拿到了第：\"+ticketNums--+\"张票\");\n        }\n    }\n\n    public static void main(String[] args) {\n        TestThread ticket=new TestThread();\n\n        new Thread(ticket,\"张三\").start();\n        new Thread(ticket,\"李四\").start();\n        new Thread(ticket,\"黄牛\").start();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c270924911b9474eb9d83821502029bd.png?x-oss-process=image)\n\n\n由结果可以看出，多线程代码可能会出现数据不安全的问题。需要用并发方法解决。\n\n## 例子：龟兔赛跑\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9c50185ba72e448986bb5725bbf0ab1b.png?x-oss-process=image)\n\n\n```java\npackage Multics;\n\npublic class Race implements Runnable{\n    private static String winner;\n\n    @Override\n    public void run() {\n        for(int i=0;i<=100;i++){\n\n            //模拟兔子偷懒\n            if(Thread.currentThread().getName().equals(\"兔子\") && i%30==0){\n                try {\n                    Thread.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            //判断比赛是否结束\n            boolean flag=gameOver(i);\n            if(flag) {break;}\n\n            System.out.println(Thread.currentThread().getName()+\"-->已经跑了\"+i+\"步\");\n        }\n    }\n\n    //判断是否完成比赛\n    private boolean gameOver(int steps){\n        //判断胜利者\n        if(winner!=null){\n            return true;\n        }\n        if(steps==100){\n            winner=Thread.currentThread().getName();\n            System.out.println(\"winner is \"+winner);\n            return true;\n        }\n        return false;\n    }\n\n\n    public static void main(String[] args) {\n        Race race=new Race();\n\n        new Thread(race,\"兔子\").start();\n        new Thread(race,\"乌龟\").start();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c14d033cbf5042e89cefb312b8328e7e.png#pic_center)\n\n## 静态代理模式\n\n真实目标角色和代理角色实现同一个接口。换句话说，真实目标角色可以只实现很小一部分的接口内容，接口的大部分内容可以放到代理角色中实现。\n\n\n\n```java\npackage Multics;\n\npublic class StaticProxy{\n    public static void main(String[] args) throws Exception{\n        WeddingCompany weddingCompany=new WeddingCompany(new You());\n        weddingCompany.HappyMarry();\n    }\n}\n\ninterface Marry{\n    //一些待实现接口\n    //结婚内容1\n    //结婚内容2\n    //结婚内容3\n    //结婚内容4\n\n    void HappyMarry();\n}\n\nclass You implements Marry{\n    @Override\n    public void HappyMarry() {\n        System.out.println(\"秦老师要结婚了，超开心\");\n    }\n}\n\n//婚庆公司类\nclass WeddingCompany implements Marry{\n    private Marry target;\n    public WeddingCompany(Marry target){\n        this.target=target;\n    }\n\n    @Override\n    public void HappyMarry() {\n        before();\n        this.target.HappyMarry();\n        after();\n    }\n\n    private void after(){\n        System.out.println(\"结婚之后，收尾款\");\n    }\n    private void before(){\n        System.out.println(\"结婚之前，布置现场\");\n    }\n    //还可以实现Marry中的其他接口\n}\n```\n\n\n\n## Lambda表达式\n\n目的：避免匿名内部类定义过多。可以将几乎不常用(比如只在一个地方用过一次)的函数直接写成lambda函数。大体思想和C++的lambda表达式相同。\n\n```java\n//三种定义方式\n(params)->expression[表达式]\n(params)->statement[语句]\n(params)->{statements}\n\n//例\na->System.out.println(\"i like lambda -->\"+a);\n```\n\n\n\n```java\npackage Multics;\n\npublic class TestLambda {\n    //3.静态内部类\n    static class Like2 implements ILike{\n        @Override\n        public void lambda() {\n            System.out.println(\"i like lambda2\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ILike like=new Like();\n        like.lambda();\n\n        like=new Like2();\n        like.lambda();\n\n\n        //4.局部内部类\n        class Like3 implements ILike{\n            @Override\n            public void lambda() {\n                System.out.println(\"i like lambda3\");\n            }\n        }\n        like=new Like3();\n        like.lambda();\n\n        //5.匿名内部类,通过接口声明\n        like=new ILike() {\n            @Override\n            public void lambda() {\n                System.out.println(\"i like lambda4\");\n            }\n        };\n\n        //6.用lambda简化\n        like=()->{\n            System.out.println(\"i like lambda5\");\n        };\n        like.lambda();\n    }\n}\n\n//1.定义一个函数式接口\ninterface ILike{\n    void lambda();\n}\n\n//2.实现类\nclass Like implements ILike{\n    @Override\n    public void lambda() {\n        System.out.println(\"i like lambda\");\n    }\n}\n```\n\n注：\n\n- 函数式接口说明接口内只有一个待实现的方法，加入ILike中写了两个待实现方法，那么用lambda表达式就会报错。\n- lambda表达式中的参数可以不声明类型。\n\n\n\n# 线程操作\n\n## Java线程基本内容\n\n常见线程方法\n\n```java\nsetPriority(int newPriority)  //更改线程的优先级\nstatic void sleep(long millis)  //指定毫秒内停止当前线程\nvoid join()  //等待该线程终止\nstatic void yield()  //暂停当前正在执行的线程对象，并执行其他线程\nvoid interrupt()  //中断线程\nboolean isAlive()  //测试线程是否处于活动状态\n```\n\n线程状态常量  -->Thread.State.常量：\n\n- `NEW`：尚未启动的线程\n- `RUNNABLE`:  在Java虚拟机中处于就绪态的线程\n- `BLOCKED`:  线程处于阻塞态\n- `WAITING`:  线程正在等待另一个线程执行特定动作\n- `TIMED_WAITING`：正在等待另一个线程执行动作达到指定等待时间的线程\n- `TERMINATED`：结束态\n\n\n\n\n\n## 线程停止\n\n- 建议线程正常停止。不建议死循环。\n- 建议使用自定义的标志位，用于判断线程是否停止\n- 不要使用stop()或destory()等JDK已不建议使用的方法\n\n```java\npackage Multics;\n\npublic class TestStop implements Runnable{\n\n    //1.设置一个标志位\n    private boolean flag=true;\n\n    @Override\n    public void run() {\n        int i=0;\n        while(flag){\n            System.out.println(\"run......Thread\"+i++);\n        }\n    }\n\n    //2.设置一个公开的方法停止线程，转换标志位\n    public void stop(){\n        this.flag=false;\n    }\n\n    public static void main(String[] args) {\n        TestStop testStop=new TestStop();\n        new Thread(testStop).start();\n        for(int i=0;i<1000;i++){\n            System.out.println(\"测试\"+i);\n            if(i==900){\n                testStop.stop();\n                System.out.println(\"线程强制停止\");\n            }\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0ef97546f36b4129b02457ecb059114c.png#pic_center)\n\n\n\n\n## 线程休眠\n\n- sleep存在异常InterruptedException\n- sleep事件结束后线程进入就绪态\n- 每个对象都有一个锁，sleep不会释放锁\n\n```java\npackage Multics;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n//模拟网络延时\npublic class TestSleep{\n\n    public static void turnDown() throws InterruptedException{\n        int num=10;\n        while(true){\n            Thread.sleep(1000);\n            System.out.println(num--);\n            if(num<=0){\n                break;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Date startTime=new Date(System.currentTimeMillis());//获取系统当前时间\n\n        while(true){\n            try {\n                Thread.sleep(1000);\n                System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime));\n                startTime=new Date(System.currentTimeMillis());//更新当前时间\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0af4b466fdbb416595bab74e62212832.png#pic_center)\n\n\n\n## 线程礼让\n\n目的：让当前正在执行的线程暂停，但不进入阻塞态。这个过程不一定成功。\n\n\n\n```java\npackage Multics;\n\npublic class TestYield {\n    public static void main(String[] args) {\n        MyYield myYield=new MyYield();\n\n        new Thread(myYield,\"a\").start();\n        new Thread(myYield,\"b\").start();\n    }\n}\n\n\nclass MyYield implements  Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"线程开始执行\");\n        Thread.yield();//礼让\n        System.out.println(Thread.currentThread().getName()+\"线程停止执行\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef6845c28e94490680668054f2fa6650.png#pic_center)\n\n## 线程强制执行\n\njoin()\n\n```java\npackage Multics;\n\npublic class TestJoin implements Runnable{\n    @Override\n    public void run() {\n        for(int i=0;i<1000;i++){\n            System.out.println(\"线程vip来了\"+i);\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException{\n        //启动线程\n        TestJoin testJoin=new TestJoin();\n        Thread thread=new Thread(testJoin);\n        thread.start();\n\n        //主线程\n        for(int i=0;i<500;i++){\n            if(i==200){  //i==200是有一个vip线程插队\n                thread.join();\n            }\n            System.out.println(\"main\"+i);\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3c05f399ca04b38a26ed4e8ef93d870.png?x-oss-process=image)\n\n\n\n## 线程优先级\n\n优先级用数字表示：1~10\n\n- Thread.MIN_PRIOTITY=1;\n- Thread.MAX_PRIOTITY=10;   //最高优先级\n- Thread.NORM_PRIOTITY=5;\n\n```java\ngetPriority()   //获取优先级 \nsetPriority(int x)  //在线程启动前 设置优先级\n```\n\n\n\n## 守护(daemon)线程\n\n- 线程分为用户线程和守护线程\n- JVM必须确保用户线程执行完毕  如main()函数\n- JVM不用等待守护线程执行完毕\n- 例：后台记录操作日志，监控内存，垃圾回收......\n\n\n\n```java\npackage Multics;\n\npublic class TestDaemon {\n    public static void main(String[] args) {\n        God god = new God();\n        You you = new You();\n\n        Thread thread = new Thread(god);\n        thread.setDaemon(true);  //默认为false\n        thread.start();\n        new Thread(you).start();\n    }\n}\n\n//上帝类\nclass God implements Runnable{\n    @Override\n    public void run() {\n        while(true){\n            System.out.println(\"上帝保佑着你\");\n        }\n    }\n}\n\n//人类\nclass You implements Runnable{\n    @Override\n    public void run() {\n        for(int i=0;i<36500;i++){\n            System.out.println(\"你的一生都开心地活着\");\n        }\n        System.out.println(\"==========goodbye  world!=============\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8ca4f159d8bf4c8ab97d5b9916939eb2.png?x-oss-process=image)\n\n\n\n# 线程同步\n\n目的：多个线程操作同一个资源。如抢票系统\n\n主要思想：队列+锁(确保安全)。\n\t\t处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问次对象的线程进入这个对象的等待吃形成队列，等待前面线程是哟弄个完毕，下一个线程在使用。\n\n\n\n锁机制：为了保证数据在方法中被访问时的正确性，在访问时加入`锁机制：synchronized`。当一个线程获得对象的排他锁，就可以独占资源，其他线程必须等待，使用完后可以释放锁。\n\n\n\n- 一个线程持有锁会导致其他所有需要此锁的线程挂起\n- 在多线程竞争下，加锁、释放锁会导致比较多的<u>上下文切换和调度延时</u>，导致性能问题\n- 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题\n\n\n\n## 三大不安全案例\n\n### 抢票系统\n\n\n\n```java\npackage Multics;\n\npublic class UnsafeBuyTicket{\n    public static void main(String[] args) {\n        BuyTicket buyTicket = new BuyTicket();\n        new Thread(buyTicket,\"张三\").start();\n        new Thread(buyTicket,\"李四\").start();\n        new Thread(buyTicket,\"黄牛\").start();\n    }\n}\n\nclass BuyTicket implements Runnable{\n    //票\n    private int ticketNums=10;\n    private boolean flag=true;\n\n    @Override\n    public void run() {\n        while(flag){\n            buy();\n        }\n    }\n\n    private void buy(){\n        //判断是否有票\n        if(ticketNums<=0) {\n            flag=false;\n            return;\n        }\n\n        //模拟延时\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        //买票\n        System.out.println(Thread.currentThread().getName()+\"拿到了\"+ticketNums--);\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6d3237dc79ff4a32a36f77e81806c702.png?x-oss-process=image)\n\n\n线程操作资源时没有上锁，导致线程不安全。\n\n\n\n### 银行取钱\n\n```java\npackage Multics;\n\npublic class UnsafeBank {\n    public static void main(String[] args) {\n        Account account=new Account(100,\"基金\");\n\n        Drawing you=new Drawing(account,50,\"你\");\n        Drawing friend=new Drawing(account,100,\"friend\");\n        you.start();\n        friend.start();\n    }\n}\n\n\n//账户\nclass Account{\n    int money;  //余额\n    String name; //卡号\n\n    public Account(int money, String name) {\n        this.money = money;\n        this.name = name;\n    }\n}\n\n//银行  模拟取款\nclass Drawing extends Thread{\n    Account account;\n    //取了多少钱\n    int drawingMoney;\n    //现在手里由多少钱\n    int nowMoney;\n\n    public Drawing(Account account, int drawingMoney,String name) {\n        super(name);\n        this.account = account;\n        this.drawingMoney = drawingMoney;\n    }\n\n    //取钱\n    @Override\n    public void run() {\n        //判断有没有钱\n        if(account.money-drawingMoney<0){\n            System.out.println(Thread.currentThread().getName()+\"余额不足\");\n            return;\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        //更新余额与现金\n        account.money-=drawingMoney;\n        nowMoney+=drawingMoney;\n\n        System.out.println(account.name+\"余额为：\"+account.money);\n        System.out.println(this.getName()+\"现金：\"+nowMoney);\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2864545c80345d1af4ddd1f759b4a82.png?x-oss-process=image)\n\n\n\n\n\n### 线程安全\n\n```java\npackage Multics;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UnsafeList {\n    public static void main(String[] args) {\n        List<String> list =new ArrayList<String>();\n        for(int i=0;i<10000;i++){\n            new Thread(()->{\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/33be83adbf264fdcbaa6dfe6cd344049.png#pic_center)\n\n\n\n## 同步方法\n\n`synchronized`关键字\n\n```java\npublic synchronized void method(...){...}\n```\n\nsynchronized修饰的方法必须先获得调用该方法对象的锁后才能执行，否则线程会阻塞。\n\n### 抢票系统\n\n```java\npackage Multics;\n\npublic class UnsafeBuyTicket{\n    public static void main(String[] args) {\n        BuyTicket buyTicket = new BuyTicket();\n        new Thread(buyTicket,\"张三\").start();\n        new Thread(buyTicket,\"李四\").start();\n        new Thread(buyTicket,\"黄牛\").start();\n    }\n}\n\nclass BuyTicket implements Runnable{\n    //......\n\n    //对this加锁\n    private synchronized void buy(){\n        //......\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0e7fb8d1ce1f426caaad232850b77251.png#pic_center)\n\n\n\n### 银行取钱\n\n\n\n```java\npackage Multics;\n\npublic class UnsafeBank {\n    public static void main(String[] args) {\n        Account account=new Account(100,\"基金\");\n\n        Drawing you=new Drawing(account,50,\"你\");\n        Drawing friend=new Drawing(account,100,\"friend\");\n        you.start();\n        friend.start();\n    }\n}\n\n\n//账户\nclass Account{...}\n\n//银行  模拟取款\nclass Drawing extends Thread{\n    //......\n    \n    //取钱\n    @Override\n    public void run() {\n        //通过synchronized块对account上锁。默认上锁this\n        synchronized(account){\n           //源码套上synchronized块\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d9719351adaa4fccbcf35efbf05ee113.png#pic_center)\n\n\n\n\n\n### 线程安全\n\n```java\npackage Multics;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UnsafeList {\n    public static void main(String[] args) {\n        List<String> list =new ArrayList<String>();\n        for(int i=0;i<10000;i++){\n            new Thread(()->{\n                synchronized (list){\n                    list.add(Thread.currentThread().getName());\n                }\n            }).start();\n        }\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e1ae6e14a6df47b390f6532769914459.png#pic_center)\n\n\n\n\n也可以使用现成的JUC安全类型集合\n\n```java\npackage Multics;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class TestJUC {\n    public static void main(String[] args){\n        CopyOnWriteArrayList<String> list=new CopyOnWriteArrayList<String>();\n        for(int i=0;i<10000;i++){\n            new Thread(()->{\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(list.size());\n    }\n}\n```\n\n\n\n# 锁\n\n## 死锁\n\n\n\n产生死锁的四个必要条件：\n\n1. 互斥条件：一个资源每次只能被一个进程使用。\n2. 请求余保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。\n4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n\n\n\n化妆案例\n\n```java\npackage Multics;\n\npublic class DeadDock {\n    public static void main(String[] args) {\n        Makeup g1=new Makeup(0,\"A\");\n        Makeup g2=new Makeup(1,\"B\");\n\n        g1.start();\n        g2.start();\n    }\n}\n\n//口红\nclass Lipstick{ }\n//镜子\nclass Mirror{ }\n\nclass Makeup extends Thread{\n    //需要的资源都只有一份\n    static Lipstick lipstick=new Lipstick();\n    static Mirror mirror=new Mirror();\n\n    int choice;\n    String girlName;\n\n    public Makeup(int choice, String girlName) {\n        this.choice = choice;\n        this.girlName = girlName;\n    }\n\n\n    @Override\n    public void run() {\n        try {\n            makeup();//化妆\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    //化妆，一个人有口红，另一个人有镜子。双方都需要对方的资源\n    private void makeup() {\n        if (choice == 0) {\n            synchronized (lipstick) {  //获得口红的锁\n                System.out.println(this.girlName + \"获得了口红的锁\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                //1s后，想获得镜子的锁\n                synchronized (mirror) {  //获得镜子的锁\n                    System.out.println(this.girlName + \"获得了镜子的锁\");\n                }\n            }\n        }\n        else {\n            synchronized (mirror) {  //获得镜子的锁\n                System.out.println(this.girlName + \"获得了镜子的锁\");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                //1s后，想获得口红的锁\n                synchronized (lipstick) {  //获得口红的锁\n                    System.out.println(this.girlName + \"获得了口红的锁\");\n                }\n            }\n\n        }\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/116808f2d4a84fba9b6c7cd6e970d2d8.png?x-oss-process=image)\n\n\n\n\n修改代码\n\n```java\npackage Multics;\n\npublic class DeadDock {\n    public static void main(String[] args) {\n        Makeup g1=new Makeup(0,\"A\");\n        Makeup g2=new Makeup(1,\"B\");\n\n        g1.start();\n        g2.start();\n    }\n}\n\n//口红\nclass Lipstick{ }\n//镜子\nclass Mirror{ }\n\nclass Makeup extends Thread{\n    //......\n    //化妆，一个人有口红，另一个人有镜子。双方都需要对方的资源\n    private void makeup() {\n        if (choice == 0) {\n            synchronized (lipstick) {  //获得口红的锁\n                System.out.println(this.girlName + \"获得了口红的锁\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            \n            //1s后，想获得镜子的锁\n            synchronized (mirror) {  //获得镜子的锁\n                System.out.println(this.girlName + \"获得了镜子的锁\");\n            }\n        }\n        else {\n            synchronized (mirror) {  //获得镜子的锁\n                System.out.println(this.girlName + \"获得了镜子的锁\");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            \n            //1s后，想获得口红的锁\n            synchronized (lipstick) {  //获得口红的锁\n                System.out.println(this.girlName + \"获得了口红的锁\");\n            }\n\n        }\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fc0e9ae6b3d0487d83aa3a375e43aee4.png?x-oss-process=image)\n\n\n\n## Lock锁(JDK)\n\njava.util.concurrent.locks.Lock接口时控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象枷锁，线程开始访问共享资源之前应先获得的Lock对象。\n\nReentrantLock类(可重入锁)实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁。\n\n\n\n```java\npackage Multics;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\n//抢票模拟\npublic class TestLock {\n    public static void main(String[] args) {\n        TestLock2 testLock2 = new TestLock2();\n\n        new Thread(testLock2).start();\n        new Thread(testLock2).start();\n        new Thread(testLock2).start();\n    }\n}\n\nclass TestLock2 implements Runnable{\n\n    int ticketNums=10;\n\n    //定义lock锁。默认对this上锁\n    private  final ReentrantLock lock=new ReentrantLock();\n\n    @Override\n    public void run() {\n        while(true){\n            try {\n                lock.lock();  //显式加锁\n\n                if(ticketNums>=0){\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(ticketNums--);\n                }\n            } finally {\n                lock.unlock(); //显式解锁\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/32ea06e8b11f4800b1398fbb06043e33.png?x-oss-process=image)\n\n\n\n\n`sychronized` 和`Lock`对比：\n\n- Lock式显式锁。sychronized是隐式锁。后者加锁、释放锁自动完成。\n- Lock只有代码块锁。sychronized有代码块所和方法锁。\n- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)\n- 优先使用顺序：Lock>同步代码块>同步方法\n\n# 线程通信\n\n## 生产者、消费者问题\n\n前提：\n\n- 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中的产品取走消费。\n- 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，知道仓库中的产品被消费者取走为止。\n- 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，知道仓库中再次放入产品为止。\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fbfa55df92d34c8a94cac65e3ea7c450.png?x-oss-process=image)\n\n\n\n\n\n\n该问题中，生产者和消费者之间相互依赖，互为条件：\n\n1. \n\n- 对于生产者，没有生产产品之前，要通知消费者等待。生产了产品之后，有需要马上通知消费者消费。\n- 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。\n- 该问题中，只用`synchronized`是不够的。1.`synchronized`可以组织并发更新同一个共享资源，实现了同步。 2.`synchronized`不能用来实现不同线程之间的消息传递(通信)\n  \n\n```java\n//线程通信相关的java方法\nwait()  //表示线程已知等待，知道其他线程通知，与sleep不同，会释放锁\nwait(long timeout)  //指定等待的毫秒数\nnotify()  //唤醒一个处于等待状态的线程\nnotifyAll()  //唤醒同一个对象上所有调用wait()方法的线程，优先级高的线程优先\n```\n\n注：以上均为Object类的方法，都只能在同步方法或同步代码块中使用，否则会抛出异常`IllegalMonitorStateException`\n\n\n\n## 解决方式\n\n### 管程法\n\n- 生产者：负责生产数据的模块(可能是方法，对象，线程，进程)；\n- 消费者：负责处理数据的模块(可能是方法，对象，线程，进程)；\n- 缓冲区：消费者不能直接使用生产者的数据。他们之间有一个缓冲区；\n\n\n\n```java\npackage Multics;\n\n//需要的类：生产者、消费者、产品、缓冲区\npublic class TestPC {\n    public static void main(String[] args) {\n        SynContainer container=new SynContainer();\n\n        new Productor(container).start();\n        new Consumer(container).start();\n    }\n}\n\n\n//生产者\nclass Productor extends Thread{\n    SynContainer container;\n    public Productor(SynContainer container){\n        this.container=container;\n    }\n\n    //生产\n    @Override\n    public void run() {\n        for(int i=0;i<100;i++){\n            container.push(new Chicken(i));\n            System.out.println(\"生产了\"+i+\"只鸡\");\n        }\n    }\n}\n\n//消费者\nclass Consumer extends Thread{\n    SynContainer container;\n    public Consumer(SynContainer container){\n        this.container=container;\n    }\n\n    //消费\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"消费了-->\"+container.pop().id+\"只鸡\");\n        }\n    }\n}\n\n//产品\nclass Chicken{\n    int id; //产品编号\n\n    public Chicken(int id) {\n        this.id = id;\n    }\n}\n\n//缓冲区\nclass SynContainer{\n\n    //仓库大小\n    Chicken[] chickens=new Chicken[10];\n    //当前容器已用大小\n    int count=0;\n\n    //生产者放入产品\n    public synchronized void push(Chicken chicken){\n        //如果容器满了，就需要等待消费者消费\n        if(count==chickens.length){\n            //通知消费者消费，生产者等待\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        //如果容器没有满，则放入产品\n        chickens[count]=chicken;\n        count++;\n\n        //通知消费者消费\n        this.notifyAll();\n    }\n\n\n    //消费者取出产品\n    public synchronized Chicken pop(){\n        //判断能否消费\n        if(count==0){\n            //等待生产者生产，消费者等待\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        //可以消费\n        count--;\n        Chicken chicken=chickens[count];\n        //通知生产者生产\n        this.notifyAll();\n        return chicken;\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/58b35963a65943b79d273a51a71ddc24.png?x-oss-process=image)\n\n\n\n\n\n\n\n### 信号灯法\n\n\n\n```java\npackage Multics;\n\n//需要的类：生产者、消费者、产品、缓冲区\npublic class TestPC {\n    public static void main(String[] args) {\n        TV tv = new TV();\n        new Player(tv).start();\n        new Watcher(tv).start();\n    }\n}\n\n\n//生产者-->演员\nclass Player extends Thread{\n    TV tv;\n\n    public Player(TV tv) {\n        this.tv = tv;\n    }\n\n    @Override\n    public void run() {\n        for(int i=0;i<20;i++){\n            if(i%2==0){\n                this.tv.play(\"节目A播放中\");\n            }\n            else{\n                this.tv.play(\"节目B播放中\");\n            }\n        }\n    }\n}\n\n//消费者-->观众\nclass Watcher extends Thread{\n    TV tv;\n\n    public Watcher(TV tv) {\n        this.tv = tv;\n    }\n\n    @Override\n    public void run() {\n        for(int i=0;i<20;i++){\n            tv.watch();\n        }\n    }\n}\n\n//产品-->节目\nclass TV{\n    //演员表演，观众等待 T\n    //观众观看，演员等待 F\n    String voice; //节目\n    boolean flag=true;  //标志位\n\n    //表演\n    public synchronized void play(String voice){\n        if(!flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        System.out.println(\"演员表演了：\"+voice);\n        //通知观众观看\n        this.notifyAll();\n        this.voice=voice;\n        this.flag=!this.flag;\n    }\n\n    //观看\n    public synchronized void watch(){\n        if(flag){\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"观看了：\"+voice);\n        //通知演员表演\n        this.notifyAll();\n        this.flag=!this.flag;\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f6a2772fde1e42ec8756b7058f3b7330.png?x-oss-process=image)\n\n# 线程池\n\n背景：经常创建和销毁、使用特别大的资源，比如并发情况下的线程，对性能影响很大。\n\n思路：提前创建多个线程，放入线程池中，使用时直接获取，食用含放回池中。这样可以避免频繁创建销毁、实现重复利用。如显示生活中的公交车。\n\n优点：\n\n- 提高相应速度(减少了创建新线程的时间)\n- 降低资源消耗(重复利用线程池中的线程，不需要每次都创建)\n- 便于线程管理（核心池大小、最大线程数、线程没有任务时最多保持多长时间后会终止......）\n\n\n\nJDK5.0起提供了线程池相关API：`ExecutorService`和`Executors`\n\nExecutorService:真正的线程池接口。常见子类ThreadPoolExecutor\n\n- `void execute(Runnable command)`:执行任务/命令，没有返回值，一般用来执行Runnable\n- `<T>Future<T>submmit(Callable<T>task)`:执行任务，有返回值，一般用来执行Callable\n- `void shutdown()`：关闭线程池\n\nExecutors：工具类、线程池的工具类，用于创建并返回不同类型的线程池。\n\n\n\n```java\npackage Multics;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool {\n    public static void main(String[] args) {\n        //1.创建服务，创建线程池\n        //参数为线程池大小\n        ExecutorService service= Executors.newFixedThreadPool(10);\n\n        //执行\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n\n        //2.关闭连接\n        service.shutdown();\n    }\n}\n\n\nclass MyThread implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5fded5f57c9443b59b4c58dae67076d2.png?x-oss-process=image)\n\n\n\n\n\n","categories":[],"tags":["JavaSE"]},{"title":"Java 网络编程基础","url":"/posts/9017/","content":"\n\n# Java网络编程\n\n参考视频:BV1LJ411z7vY\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/122516970\n\n网络内容大体已经学过。这里重点记录编程实现。\n\n\n\n# IP\n\n\n\n```java\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\n/**\n * 测试IP\n */\npublic class TestInteAddress {\n    public static void main(String[] args) {\n        try {\n            InetAddress inetAddress1=InetAddress.getByName(\"127.0.0.1\");\n            InetAddress inetAddress2=InetAddress.getLocalHost();\n            InetAddress inetAddress3=InetAddress.getByName(\"www.bilibili.com\");\n            System.out.println(inetAddress1);\n            System.out.println(inetAddress2);\n            System.out.println(inetAddress3);\n\n            System.out.println(\"=================\");\n            System.out.println(inetAddress3.getAddress());\n            System.out.println(inetAddress3.getCanonicalHostName());  //获取规范命名\n            System.out.println(inetAddress3.getHostAddress());\n            System.out.println(inetAddress3.getHostName());\n\n\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c8ebcb0fe73e476ebbc27e551cba69ef.png?x-oss-process=image)\n\n\n\n# 端口\n\n端口表示计算机上的一个程序的进程：\n\n- 不同的进程有不同的端口号\n- 端口号范围：0~65535\n- TCP和UDP各有65535个端口号。TCP的x端口与UDP的x端口不冲突。\n\n端口分类:\n\n- 公有端口 0~1023。如HTTP:30，HTTPS:443，FTP:21，Telnet:23\n- 程序注册端口:1024~49151,用于分配用户或程序。如Tomcat:8080，MySQL:3306 ，Oracle:1521\n- 动态、私有：49125~65535\n\n\n\n```bash\nnetstat -ano  #查看所有的端口\nnetstat -ano|findstr \"5900\"  #筛选查询信息，只显示5900端口号信息\ntasklist|findstr \"8696\" #查看指定端口的进程\n```\n\n\n\n\n\n```java\nimport java.net.InetSocketAddress;\n\npublic class TestInetSocketAddress {\n    public static void main(String[] args) {\n        InetSocketAddress inetSocketAddress1=new InetSocketAddress(\"127.0.0.1\",8080);  //8080为端口号\n        InetSocketAddress inetSocketAddress2=new InetSocketAddress(\"localhost\",8080);\n        System.out.println(inetSocketAddress1);\n        System.out.println(inetSocketAddress2);\n\n        System.out.println(inetSocketAddress1.getAddress());\n        System.out.println(inetSocketAddress1.getHostName());\n        System.out.println(inetSocketAddress1.getPort());//获取端口号\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7a621873074f47aabadf1c06459f42d7.png?x-oss-process=image)\n\n\n\n\n\n# TCP\n\n## 简易文本传输\n\n客户端\n\n1. 连接服务器Socket\n2. 发送消息\n\n\n\n```java\npackage NetTest;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.nio.charset.StandardCharsets;\n\n/**\n*  客户端\n*/\npublic class TcpCilentDemo {\n    public static void main(String[] args) {\n        Socket socket=null;\n        OutputStream os=null;\n        try {\n            //1.要获取服务器的地址、端口号\n            InetAddress serverIP=InetAddress.getByName(\"127.0.0.1\");\n            int port=9999;\n            //2.创建一个socket连接\n            socket=new Socket(serverIP,port);\n            //发送消息  IO流\n            os=socket.getOutputStream();\n            os.write(\"测试测试测试测试测试测试\".getBytes());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        if (os!=null) {\n            try {os.close();}\n            catch (IOException e) {e.printStackTrace();}\n        }\n        if (socket!=null) {\n            try {socket.close();}\n            catch (IOException e) {e.printStackTrace();}\n        }\n    }\n}\n```\n\n\n\n\n\n服务器\n\n1. 建立服务的端口ServerSocket\n2. 通过accept()方法等待用户连接\n3. 接收用户的消息\n\n\n\n\n\n```java\npackage NetTest;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n\n/**\n*  服务器端\n*/\npublic class TcpServerDemo {\n    public static void main(String[] args) {\n        ServerSocket serverSocket=null;\n        Socket socket=null;\n        InputStream is=null;\n        ByteArrayOutputStream baos=null;\n        try {\n            //1.设置地址\n            serverSocket=new ServerSocket(9999);\n            while (true) {\n                //2.等待客户端连接\n                socket=serverSocket.accept();\n                //3.读取客户端传输的信息。使用管道流\n                is=socket.getInputStream();\n\n                baos=new ByteArrayOutputStream();\n\n                byte[] buffer=new byte[1024];\n                int len;\n                while((len=is.read(buffer))!=-1){\n                    baos.write(buffer,0,len);\n                }\n                System.out.println(baos.toString());\n            }\n\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n            //按栈的顺序关闭所有资源\n            if (baos!=null) {\n                try {baos.close();}\n                catch (IOException e) {e.printStackTrace();}\n            }\n            if (is!=null) {\n                try {is.close();}\n                catch (IOException e) {e.printStackTrace();}\n            }\n            if (socket!=null) {\n                try {socket.close();}\n                catch (IOException e) {e.printStackTrace();}\n            }\n            if (serverSocket!=null) {\n                try {serverSocket.close();}\n                catch (IOException e) {e.printStackTrace();}\n            }\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e881e522d9294517917e1ade9b9feae6.png?x-oss-process=image)\n\n\n\n\n\n\n\n## 文件传输\n\n客户端\n\n```java\npackage NetTest;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class TcpCilentDemo {\n    public static void main(String[] args) throws Exception{\n        //1.创建一个scoket连接\n        Socket socket=new Socket(InetAddress.getByName(\"127.0.0.1\"),9000);\n        //2.创建一个输出流\n        OutputStream os=socket.getOutputStream();\n        //3.读文件\n        FileInputStream fis=new FileInputStream(new File(\"C:\\\\Users\\\\96955\\\\Desktop\\\\work.png\"));\n        //4.写文件\n        byte[] buffer=new byte[1024];\n        int len;\n        while((len=fis.read(buffer))!=-1){\n            os.write(buffer,0,len);\n        }\n\n        //通知服务器上传完毕\n        socket.shutdownOutput();\n        //确定服务器接收完毕。再断开连接\n        InputStream is=socket.getInputStream();\n        ByteArrayOutputStream baos=new ByteArrayOutputStream();\n        while((len=is.read(buffer))!=-1){\n            baos.write(buffer,0,len);\n        }\n        System.out.println(baos.toString());\n\n        //5.关闭资源\n        baos.close();\n        is.close();\n        fis.close();\n        os.close();\n        socket.close();\n    }\n}\n```\n\n\n\n\n\n服务器端\n\n```java\npackage NetTest;\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.StandardCharsets;\n\npublic class TcpServerDemo {\n    public static void main(String[] args) throws Exception{\n        //1.创建服务\n        ServerSocket serverSocket=new ServerSocket(9000);\n        //2.监听客户端的连接\n        Socket socket=serverSocket.accept();  //阻塞式监听，会已知等待客户端的连接\n        //3.获取输入流\n        InputStream is=socket.getInputStream();\n        //4.文件输出\n        FileOutputStream fos=new FileOutputStream(new File(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\receive.png\"));\n        byte[] buffer=new byte[1024];\n        int len;\n        while((len=is.read(buffer))!=-1){\n            fos.write(buffer,0,len);\n        }\n\n        //通知用户端接收完毕\n        OutputStream os=socket.getOutputStream();\n        os.write(\"接收完毕\".getBytes());\n\n        //5.关闭页面\n        fos.close();\n        is.close();\n        socket.close();\n        serverSocket.close();\n    }\n}\n```\n\n\n\n# 初识Tomcat\n\n源码获取:https://github.com/apache/tomcat\n\n可参考博客https://blog.csdn.net/o_o_gl/article/details/79662995\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/812979b2bd1a480381b18b140da5d6dd.png?x-oss-process=image)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e58917e4210b4ab192f683b6262c9343.png?x-oss-process=image)\n\n\n\n# UDP\n\n发短信:不用建立连接，但需要知道对方的地址\n\n## 简易消息发送\n\n\n\n客户端\n\n```java\npackage NetTest;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.nio.charset.StandardCharsets;\n\npublic class UDPClientDemo {\n    public static void main(String[] args) throws Exception{\n        //1.建立一个Socket\n        DatagramSocket socket=new DatagramSocket();\n\n        //2.建个包\n        String msg=\"hello\";\n        InetAddress localHost=InetAddress.getByName(\"localhost\");\n        int port=9000;\n\n        //传入参数:数据本身，数据的长度、起始位置，发送给谁\n        DatagramPacket packet=new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localHost,port);\n        //3.发送包\n        socket.send(packet);\n\n        //4.关闭连接\n        socket.close();\n    }\n}\n```\n\n\n\n服务器端(也可以是客户端)\n\n```java\npackage NetTest;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPServerDemo {\n    public static void main(String[] args)throws Exception {\n        //开放端口\n        DatagramSocket socket=new DatagramSocket(9000);\n        //接收数据包\n        byte[] buffer=new byte[1024];\n        DatagramPacket packet=new DatagramPacket(buffer,0,buffer.length);\n        socket.receive(packet); //阻塞接收\n        System.out.println(packet.getAddress());\n        System.out.println(new String(packet.getData(),0,packet.getLength()));\n        //关闭连接\n        socket.close();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0dd3d0d11ed240999af9a1adac513b5a.png?x-oss-process=image)\n\n\n\n\n\n## 实现聊天\n\n发送端\n\n```java\npackage NetTest;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\nimport java.nio.charset.StandardCharsets;\n\npublic class UDPSenderDemo {\n    public static void main(String[] args) throws Exception{\n        DatagramSocket socket=new DatagramSocket(8888);\n        //数据输入\n        BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n\n        while (true) {\n            String data=reader.readLine();\n            byte[] datas=data.getBytes();\n            DatagramPacket packet=new DatagramPacket(datas,0,datas.length,new InetSocketAddress(\"localhost\",6666));\n\n            socket.send(packet);\n            if(data.equals(\"bye\")){\n                break;\n            }\n        }\n\n        socket.close();\n    }\n}\n```\n\n\n\n接收端\n\n```java\npackage NetTest;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPReceiverDemo {\n    public static void main(String[] args)throws Exception {\n        DatagramSocket socket=new DatagramSocket(6666);\n\n        while (true) {\n            //准备接收数据包\n            byte[] container=new byte[1024];\n            DatagramPacket packet=new DatagramPacket(container,0,container.length);\n            socket.receive(packet);\n\n            //断开连接\n            byte[] data=packet.getData();\n            String receiveData=new String(data,0, packet.getLength());\n            System.out.println(receiveData);\n\n            if(receiveData.equals(\"bye\")){\n                break;\n            }\n        }\n        socket.close();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dee3b4cf6fe14734ab8599e2373a19b2.png#pic_center)\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4af68efd200543a6811d606d2be9a8cd.png#pic_center)\n\n\n\n## 多线程在线咨询\n\n先实现发送和接收功能，分别封装成两个类\n\n```java\npackage NetTest;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\n\n//消息发送功能\n\npublic class TalkSend implements Runnable{\n    DatagramSocket socket=null;\n    BufferedReader reader=null;\n\n    private  int fromPort;\n    private String toIP;\n    private int toPort;\n\n    public TalkSend(int fromPort, String toIP, int toPort) {\n        this.fromPort = fromPort;\n        this.toIP = toIP;\n        this.toPort = toPort;\n\n        try{\n            socket=new DatagramSocket(fromPort);\n            reader=new BufferedReader(new InputStreamReader(System.in));\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n\n    @Override\n    public void run(){\n\n        while (true) {\n            try {\n                String data=reader.readLine();\n                byte[] datas=data.getBytes();\n                DatagramPacket packet=new DatagramPacket(datas,0,datas.length,new InetSocketAddress(this.toIP,this.toPort));\n\n                socket.send(packet);\n                if(data.equals(\"bye\")){\n                    break;\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        socket.close();\n    }\n}\n```\n\n\n\n```java\npackage NetTest;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\n\n//消息接收功能\npublic class TalkReceive implements Runnable{\n    DatagramSocket socket=null;\n    private int port;\n    private String msgFrom;\n\n    public TalkReceive(int port,String msgFrom) {\n        this.port = port;\n        this.msgFrom=msgFrom;\n        try {\n            socket=new DatagramSocket(port);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run(){\n        while (true) {\n            try {\n                //准备接收数据包\n                byte[] container=new byte[1024];\n                DatagramPacket packet=new DatagramPacket(container,0,container.length);\n                socket.receive(packet);\n\n                //断开连接\n                byte[] data=packet.getData();\n                String receiveData=new String(data,0, packet.getLength());\n                System.out.println(msgFrom+\":\"+receiveData);\n\n                if(receiveData.equals(\"bye\")){\n                    break;\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        socket.close();\n    }\n}\n\n```\n\n\n\n两个功能作为两个线程写入用户类\n\n```java\npackage NetTest;\n\npublic class TalkStudent {\n    public static void main(String[] args) {\n        //开启两个线程\n        new Thread(new TalkSend(7777,\"localhost\",9999)).start();\n        new Thread(new TalkReceive(8888,\"老师\")).start();\n    }\n}\n```\n\n\n\n```java\npackage NetTest;\n\npublic class TalkTeacher {\n    public static void main(String[] args) {\n        new Thread(new TalkSend(5555,\"localhost\",8888)).start();\n        new Thread(new TalkReceive(9999,\"学生\")).start();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/403a8237a5e443e2b10a5941b0f17728.png#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4712938b94cb4261ad945d4b62378ffd.png#pic_center)\n\n\n\n\n\n\n\n# URL\n\n\n\n```java\npackage NetTest;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class URLDown {\n    public static void main(String[] args) throws IOException {\n        //1.下载地址\n        URL url=new URL(\"https://i0.hdslb.com/bfs/videoshot/67730043.jpg\");\n\n        //2.连接到该网页\n        HttpURLConnection urlConnection=(HttpsURLConnection) url.openConnection();\n        InputStream inputStream=urlConnection.getInputStream();\n\n        FileOutputStream fos=new FileOutputStream(\"11.jpg\");\n        byte[] buffer=new byte[1024];\n        int len;\n        while((len=inputStream.read(buffer))!=-1){\n            fos.write(buffer,0,len);\n        }\n\n        fos.close();\n        inputStream.close();\n        urlConnection.disconnect();\n    }\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d6d12ebb00074e7dad8492f9e2c2123d.png?x-oss-process=image)\n\n","categories":[],"tags":["JavaSE"]},{"title":"JavaGUI 基础","url":"/posts/47384/","content":"\n\n# JavaGUI\n\n参考视频：BV1DJ411B75F\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/122503407\n\n关键类：Swing、AWT\n\n技术已不常用，不过可以为了解MVC架构打基础\n\n\n# AWT\n\n## AWT介绍\n\njava.awt.* ，内部包含很多GUI相关的类和接口。\n\n元素：窗口、按钮、文本框\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef29b129551346c4ab21e54a35454b34.png?x-oss-process=image)\n\n\n\n\n## 组件和容器\n\n==注：大体学习思路是：知道有相关的类-->创建这个类的对象-->各种类方法的使用和细节可以看源码(IDEA中通过ctrl+鼠标点击相关类可以跳到类的源码)==\n\n### Frame\n\n```java\n/**\n* 创建一个Frame窗口\n*/\n\nimport java.awt.*;\npublic class TestFrame {\n    public static void main(String[] args) {\n        //Frame创建窗口对象，具体细节看源码\n        Frame frame=new Frame(\"My first java frame\");\n        \n        //设置窗口是否可见\n        frame.setVisible(true);\n    \n        //设置窗口大小\n        frame.setSize(400,300);\n        \n        //设置背景颜色  Color类\n        frame.setBackground(new Color(111,56,220));\n        \n        //窗口弹出的初始位置\n        frame.setLocation(200,200);\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/608bd9d955274eda8f540ef7c8391017.png?x-oss-process=image)\n\n\n\n\n下面实现一次弹出多个窗口，可以将窗口的特点进行封装，写成自己的窗口类\n\n```java\nimport java.awt.*;\npublic class TestFrame2 {\n    public static void main(String[] args) {\n        //弹出多个窗口\n        MyFrame myFrame1=new MyFrame(100,100,200,200, Color.cyan);\n        MyFrame myFrame2=new MyFrame(100,300,200,200, Color.pink);\n        MyFrame myFrame3=new MyFrame(100,500,200,200, Color.red);\n        MyFrame myFrame4=new MyFrame(100,700,200,200, Color.yellow);\n    }\n}\n\n\nclass MyFrame extends Frame{\n    static int id=0;   //统计创建的窗口数\n\n    public MyFrame(int x,int y,int w,int h,Color color){\n        super(\"MyFrame\"+(++id));\n        setBackground(color);\n        setBounds(x,y,w,h);\n        setVisible(true);\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/aa912ab2696b437398d05a7ca112a7f3.png?x-oss-process=image)\n\n\n### Panel(面板)\n\nPanel不能单独存在，可以堪称是一个空间或容器\n\n```java\n//Panel源码定义部分\npublic class Panel extends Container implements Accessible {\n    private static final String base = \"panel\";\n    private static int nameCounter = 0;\n//......\n}\n```\n\nPanel继承了Container\n\n```java\npublic class Container extends Component {\n\n    private static final PlatformLogger log = PlatformLogger.getLogger(\"java.awt.Container\");\n    private static final PlatformLogger eventLog = PlatformLogger.getLogger(\"java.awt.event.Container\");\n\n    private static final Component[] EMPTY_ARRAY = new Component[0];\n\t//......\n}\n```\n\nContainer继承了Component。因此Panel对象作为元素放入Frame对象\n\n\n\n测试样例\n\n```java\nimport java.lang.*;\nimport java.util.*;\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowListener;\npublic class TestPanel {\n    public static void main(String[] args) {\n        Frame frame=new Frame(\"包含Panel的窗口\");\n        Panel panel=new Panel();\n        //设置布局\n        frame.setLayout(null);\n\n        //坐标\n        frame.setBounds(300,300,500,500);\n        frame.setBackground(Color.cyan);\n\n        //设置panel坐标，相对于frame。frame的左上角为panel的(0,0)坐标\n        panel.setBounds(50,50,260,260);\n        panel.setBackground(Color.magenta);\n\n        //将panel加入frame中\n        frame.add(panel);\n        frame.setVisible(true);\n\n        //监听事件，监听窗口关闭事件\n        //下面采用适配器模式，这种模式下可以在众多待重载的方法中，只重载部分需要的方法\n        frame.addWindowListener(new WindowAdapter() {\n            //窗口右上角关闭事件\n            public void windowClosing(WindowEvent e){\n                System.exit(0);\n            }\n        });\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2e2d6cd8baac4a74bbf3cba3a6a34bbe.png?x-oss-process=image)\n\n\n\n\n## 布局管理器\n\n#### 基本布局\n\n- 流式布局(从左往右)\n\n```java\nimport java.io.BufferedReader;\nimport java.lang.*;\nimport java.util.*;\nimport java.awt.*;\npublic class TestFlowLayout {\n    public static void main(String[] args) {\n        Frame frame=new Frame();\n\n        //组件+按钮\n        Button button1=new Button(\"button1\");\n        Button button2=new Button(\"button2\");\n        Button button3=new Button(\"button3\");\n\n        //设置为流式布局\n        //frame.setLayout(new FlowLayout());\n        //frame.setLayout(new FlowLayout(FlowLayout.LEFT));\n        frame.setLayout(new FlowLayout(FlowLayout.RIGHT));\n\n        frame.setSize(300,300);\n\n        //添加按钮\n        frame.add(button1);\n        frame.add(button2);\n        frame.add(button3);\n        frame.setVisible(true);\n    }\n\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bded7421e1ce4e5e96bfbc26c71b6b77.png?x-oss-process=image)\n\n\n\n\n\n\n- 东西南北中\n\n```java\nimport java.io.BufferedReader;\nimport java.lang.*;\nimport java.util.*;\nimport java.awt.*;\npublic class TestFlowLayout {\n    public static void main(String[] args) {\n        Frame frame=new Frame();\n\n        //组件+按钮\n        Button east=new Button(\"East\");\n        Button west=new Button(\"West\");\n        Button south=new Button(\"South\");\n        Button north=new Button(\"North\");\n        Button center=new Button(\"Center\");\n\n        frame.add(east,BorderLayout.EAST);\n        frame.add(west,BorderLayout.WEST);\n        frame.add(south,BorderLayout.SOUTH);\n        frame.add(north,BorderLayout.NORTH);\n        frame.add(center,BorderLayout.CENTER);\n\n        frame.setSize(500,500);\n        frame.setVisible(true);\n    }\n\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6311cbda781e484b9b69f68fed15885d.png?x-oss-process=image)\n\n\n\n\n- 表格布局\n\n```java\nimport java.io.BufferedReader;\nimport java.lang.*;\nimport java.util.*;\nimport java.awt.*;\npublic class TestFlowLayout {\n    public static void main(String[] args) {\n        Frame frame=new Frame();\n        \n        Button bin1=new Button(\"bin1\");\n        Button bin2=new Button(\"bin2\");\n        Button bin3=new Button(\"bin3\");\n        Button bin4=new Button(\"bin4\");\n        Button bin5=new Button(\"bin5\");\n        Button bin6=new Button(\"bin6\");\n\n\n        //设置表格布局规格\n        frame.setLayout(new GridLayout(3,2));\n        frame.add(bin1);\n        frame.add(bin2);\n        frame.add(bin3);\n        frame.add(bin4);\n        frame.add(bin5);\n        frame.add(bin6);\n        frame.setSize(500,500);\n        frame.setVisible(true);\n    }\n\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f933a7bc60524affb742d5fceab4897b.png?x-oss-process=image)\n\n\n\n\n#### 嵌套布局\n\n实现下面布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2ada57368fd04fdfabc71b2b2e19997b.png#pic_center)\n\n\n\n\n```java\nimport java.lang.*;\nimport java.util.*;\nimport java.awt.*;\nimport java.util.concurrent.Flow;\n\npublic class TestFlowLayout {\n    public static void main(String[] args) {\n        Frame frame=new Frame();\n\n\n        //上半部分\n        Panel panelup=new Panel(new BorderLayout());\n        panelup.add(new Button(\"West-1\"),BorderLayout.WEST);\n        panelup.add(new Button(\"East-1\"),BorderLayout.EAST);\n\n        Panel panelup1=new Panel(new GridLayout(2,1));\n        panelup1.add(new Button(\"center1-bin-1\"));\n        panelup1.add(new Button(\"center1-bin-2\"));\n        panelup.add(panelup1,BorderLayout.CENTER);\n\n        //下半部分\n        Panel paneldown=new Panel(new BorderLayout());\n        paneldown.add(new Button(\"West-2\"),BorderLayout.WEST);\n        paneldown.add(new Button(\"East-3\"),BorderLayout.EAST);\n        Panel paneldown1=new Panel(new GridLayout(2,2));\n\n        for(int i=1;i<=4;i++){\n            paneldown1.add(new Button(\"center2-bin-\"+i));\n        }\n        paneldown.add(paneldown1,BorderLayout.CENTER);\n\n\n        //设置表格布局规格\n\n        frame.setSize(500,500);\n        panelup.setSize(250,250);\n        panelup.setLocation(0,0);\n        paneldown.setSize(250,250);\n        paneldown.setLocation(250,0);\n        frame.setLayout(new GridLayout(2,1));\n        frame.add(panelup);\n        frame.add(paneldown);\n        frame.setVisible(true);\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48363523910c4e0893efc36317202a52.png?x-oss-process=image)\n\n\n\n## 事件监听\n\n目的：某个事件发生时可以触发什么操作\n\n\n\n```java\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestActionEvent {\n\n    public static void main(String[] args) {\n\n        //点击按钮触发事件\n        Frame frame=new Frame();\n        Button button=new Button(\"button\");\n        frame.setVisible(true);\n\n        //自定义监听事件类\n        MyActionListener myActionListener=new MyActionListener();\n        button.addActionListener(myActionListener);   //添加监听器\n        frame.add(button,BorderLayout.CENTER);\n        frame.pack();   //自动调整组件布局\n        windowClose(frame);\n    }\n\n    //关闭窗体事件\n    private static void windowClose(Frame frame){\n        frame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e){\n                System.exit(0);\n            }\n        });\n    }\n}\n\n\nclass MyActionListener implements ActionListener{\n\n    @Override\n    public void actionPerformed(ActionEvent e){\n        System.out.println(\"xxxxx\");\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0b3c87e5dadd44d1a7d7e507b50f015a.png?x-oss-process=image)\n\n\n\n\n\n\n\n\n```java\n/**\n*  两个按钮共用一个监听器\n*/\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\npublic class TestActionTwo {\n    public static void main(String[] args) {\n        \n        Frame frame=new Frame();\n        Button bin1=new Button(\"Start\");\n        Button bin2=new Button(\"End\");\n\n        //修改bin2的内部信息。默认值为按钮名\n        bin2.setActionCommand(\"button2-stop\");\n\n        MyMonitor myMonitor=new MyMonitor();\n        bin1.addActionListener(myMonitor);\n        bin2.addActionListener(myMonitor);\n\n        frame.add(bin1,BorderLayout.NORTH);\n        frame.add(bin2,BorderLayout.SOUTH);\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n\n\nclass MyMonitor implements ActionListener{\n    @Override\n    public void actionPerformed(ActionEvent e){\n        //e.getActionCommand()  可以获取按钮的信息\n        System.out.println(e.getActionCommand());\n        if(e.getActionCommand().equals(\"Start\")){\n            System.out.println(\"1111111111111111\");\n        }\n        else if(e.getActionCommand().equals(\"End\")){\n            System.out.println(\"2222222222222222\");\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4868162c2b4d4bf7a6344868ecbf41a4.png?x-oss-process=image)\n\n\n\n## TextField(输入框)\n\n不可换行的文本框\n\n```java\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class TextTest {\n    public static void main(String[] args) {\n        new MyFrame();\n    }\n}\n\nclass MyFrame extends Frame{\n    public MyFrame(){\n        TextField textField=new TextField();\n        add(textField);\n        setVisible(true);\n        pack();\n\n        //监听文本框输入的内容\n        MyActionListener myActionListener=new MyActionListener();\n        //写入内容后按回车触发事件\n        textField.addActionListener(myActionListener);\n\n        //设置替换编码\n        textField.setEchoChar('*');\n\n    }\n}\n\n\nclass MyActionListener implements ActionListener{\n    @Override\n    public void actionPerformed(ActionEvent e){\n        TextField field=(TextField) e.getSource();    //e.getSource()返回Object类型\n        System.out.println(field.getText());\n        //field.setText(\"\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2c89fa51abf641a18c5b683fc830ec9c.png?x-oss-process=image)\n\n\n\n\n## 案例：简易计算器\n\n涉及组合、内部类的内容\n\n\n\n```java\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestCal {\n    public static void main(String[] args) {\n        new Calculator();\n    }\n}\n\n//计算器类\nclass Calculator extends Frame {\n\n    public Calculator(){\n        //3个文本框\n        TextField num1 = new TextField(10);  //10为限制字符数\n        TextField num2 = new TextField(10);\n        TextField num3 = new TextField(20);\n\n        //1个按钮\n        Button button=new Button(\"=\");\n        button.addActionListener(new MyCalculatorListener(num1,num2,num3));\n        //1个标签\n        Label label=new Label(\"+\");\n\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);add(label);add(num2);add(button);add(num3);\n\n        pack();\n        setVisible(true);\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                super.windowClosing(e);\n                System.exit(0);\n            }\n        });\n    }\n}\n\n\n//监听器类\nclass MyCalculatorListener implements ActionListener{\n    private TextField num1,num2,num3;\n\n    public MyCalculatorListener(TextField num1, TextField num2, TextField num3) {\n        this.num1 = num1;\n        this.num2 = num2;\n        this.num3 = num3;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e){\n        //获取两个加数\n        int n1=Integer.parseInt(num1.getText());\n        int n2=Integer.parseInt(num2.getText());\n        \n        //计算结果放到第三个文本框\n        num3.setText(\"\"+(n1+n2));\n        \n        //清除前两个框\n        num1.setText(\"\");\n        num2.setText(\"\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2cd3f6502e4a49f2b52dfa53c4599bbf.png#pic_center)\n\n\n\n\n上述代码以面向过程为主，下面通过组合形式优化成面向对象的代码\n\n```java\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestCal {\n    public static void main(String[] args) {\n        new Calculator();\n    }\n}\n\n//计算器类\nclass Calculator extends Frame {\n    TextField num1,num2,num3;\n\n\n    public Calculator(){\n        //3个文本框\n        num1 = new TextField(10);  //10为限制字符数\n        num2 = new TextField(10);\n        num3 = new TextField(20);\n        //1个按钮\n        Button button=new Button(\"=\");\n        button.addActionListener(new MyCalculatorListener(this));\n        //1个标签\n        Label label=new Label(\"+\");\n\n\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);add(label);add(num2);add(button);add(num3);\n\n        pack();\n        setVisible(true);\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                super.windowClosing(e);\n                System.exit(0);\n            }\n        });\n    }\n}\n\n\n//监听器类\nclass MyCalculatorListener implements ActionListener{\n\n    //获取对象，在一个类中组合另一个类\n    Calculator calculator=null;\n\n    public MyCalculatorListener(Calculator calculator) {\n        this.calculator = calculator;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e){\n        //获取两个加数\n        int n1=Integer.parseInt(calculator.num1.getText());\n        int n2=Integer.parseInt(calculator.num2.getText());\n        \n        //计算结果放到第三个文本框\n        calculator.num3.setText(\"\"+(n1+n2));\n        \n        //清除前两个框\n        calculator.num1.setText(\"\");\n        calculator.num2.setText(\"\");\n    }\n}\n```\n\n进一步，还可以使用内部类方法将监听器类放到计算器类中，从而更好地封装类\n\n```java\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestCal {\n    public static void main(String[] args) {\n        new Calculator().loadFrame();\n    }\n}\n\n//计算器类\nclass Calculator extends Frame {\n    TextField num1,num2,num3;\n    \n    public void loadFrame(){\n        //3个文本框\n        num1 = new TextField(10);  //10为限制字符数\n        num2 = new TextField(10);\n        num3 = new TextField(20);\n        //1个按钮\n        Button button=new Button(\"=\");\n        button.addActionListener(new MyCalculatorListener());\n        //1个标签\n        Label label=new Label(\"+\");\n\n\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);add(label);add(num2);add(button);add(num3);\n\n        pack();\n        setVisible(true);\n        addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                super.windowClosing(e);\n                System.exit(0);\n            }\n        });\n    }\n    \n    //监听器内部类\n    public class MyCalculatorListener implements ActionListener{\n\n        @Override\n        public void actionPerformed(ActionEvent e){\n            //获取两个加数\n            int n1=Integer.parseInt(num1.getText());\n            int n2=Integer.parseInt(num2.getText());\n\n            //计算结果放到第三个文本框\n            num3.setText(\"\"+(n1+n2));\n\n            //清除前两个框\n            num1.setText(\"\");\n            num2.setText(\"\");\n        }\n    }\n}\n```\n\n\n\n## Paint(画笔)\n\n```java\nimport java.awt.*;\npublic class TestPaint {\n    public static void main(String[] args) {\n        new MyPaint().loadFrame();\n    }\n}\nclass MyPaint extends Frame{\n    public void loadFrame(){\n        setBounds(200,200,600,500);\n        setVisible(true);\n    }\n\n    //画笔\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        g.setColor(Color.cyan);\n        g.fillOval(100,100,100,100); //实心圆\n        g.setColor(Color.magenta);\n        g.fillRect(150,200,200,200);\n    }\n}\n```\n\n\n\n## 常用监听\n\n### 鼠标监听\n\n```java\n/**\n* 简易画板\n*/\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class TestMouseListener {\n    public static void main(String[] args) {\n        new MyFrame(\"画图\");\n    }\n}\n\n\n\nclass MyFrame extends Frame{\n    //画笔。需要监听鼠标当前的位置，还需要一个存储所画点的集合\n    ArrayList points;\n\n    public MyFrame(String title) {\n        super(title);\n        setBounds(200,200,400,300);\n        setVisible(true);\n\n        //存储鼠标点击的位置\n        points=new ArrayList();\n\n        //鼠标监听器\n        addMouseListener(new MyMouseListener());\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        //监听鼠标的事件\n        Iterator iterator=points.iterator();\n        while(iterator.hasNext()){\n            Point point=(Point)iterator.next();\n            g.setColor(Color.cyan);\n            g.fillOval(point.x,point.y,10,10);\n        }\n    }\n\n    public void addPoint(Point point){\n        points.add(point);\n    }\n\n    //适配器模式\n    private class MyMouseListener extends MouseAdapter{\n        //鼠标事件：按下、弹起、按住不放\n\n        @Override\n        public void mousePressed(MouseEvent e) {\n            MyFrame myFrame=(MyFrame)e.getSource();\n\n            //鼠标的位置\n            addPoint(new Point(e.getX(),e.getY()));\n\n            //每次点击鼠标都需要重新调用paint函数\n            myFrame.repaint();\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/979e93ffaeb74357bf04eba4dc7bc776.png?x-oss-process=image)\n\n\n\n### 窗口监听\n\n\n\n```java\nimport java.awt.*;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class TestWindow {\n    public static void main(String[] args) {\n        new WindowFrame();\n    }\n}\n\nclass WindowFrame extends Frame{\n    public WindowFrame(){\n        setBackground(Color.cyan);\n        setBounds(200,200,200,200);\n        setVisible(true);\n\n        this.addWindowListener(new WindowAdapter() {\n            //匿名内部类\n            @Override\n            public void windowOpened(WindowEvent e) {\n                System.out.println(\"窗口打开\");\n            }\n\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.out.println(\"窗口正在关闭\");\n                System.exit(0);\n            }\n        });\n    }\n}\n```\n\n\n\n### 键盘监听\n\n\n\n```java\nimport java.awt.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\npublic class TestKeyListener {\n    public static void main(String[] args) {\n        new KeyFrame();\n    }\n}\n\nclass KeyFrame extends Frame {\n    public KeyFrame(){\n        setBounds(200,200,200,200);\n        setVisible(true);\n\n        this.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                int keyCode=e.getKeyCode();\n                if(keyCode==KeyEvent.VK_UP){\n                    System.out.println(\"👆\");\n                }\n                else if(keyCode==KeyEvent.VK_LEFT){\n                    System.out.println(\"👈\");\n                }\n                else if(keyCode==KeyEvent.VK_RIGHT){\n                    System.out.println(\"👉\");\n                }\n                else if(keyCode==KeyEvent.VK_DOWN){\n                    System.out.println(\"👇\");\n                }\n            }\n        });\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/62dc0fdbd7f24800abdd57b6fa05bd52.png?x-oss-process=image)\n\n\n\n\n\n# Swing\n\n功能比AWT更强。\n\n大体用法相近\n\n## 窗口、面板\n\n\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JFrameDemo {\n    public static void main(String[] args) {\n        new MyJframe().init();\n    }\n}\n\nclass MyJframe extends JFrame{\n    public void init(){\n        setBounds(200,200,200,200);\n        setVisible(true);\n\n        JLabel label=new JLabel(\"A JLabel\");\n        add(label);\n        //将label设为居中\n        label.setHorizontalAlignment(SwingConstants.CENTER);\n\n        //获取一个容器\n        Container container=this.getContentPane();\n        container.setBackground(Color.cyan);\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/44d892f951524d7ba682a3b39d53ccf9.png?x-oss-process=image)\n\n\n\n\n\n## 弹窗\n\n\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class DialogDemo extends JFrame {\n    public DialogDemo(){\n        setVisible(true);\n        setSize(700,500);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        //JFrame 容器\n        Container container=this.getContentPane();\n        //绝对布局\n        container.setLayout(null);\n\n        //按钮\n        JButton button=new JButton(\"点击弹出一个对话框\");\n        button.setBounds(30,30,200,50);\n        button.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                //按下按钮显示弹窗\n                new MyDialogDemo();\n            }\n        });\n        container.add(button);\n    }\n\n    public static void main(String[] args) {\n        new DialogDemo();\n    }\n}\n\n//弹窗类\nclass MyDialogDemo extends JDialog{\n    public MyDialogDemo() {\n        setVisible(true);\n        setBounds(100,100,500,500);\n\n        //这句话的功能在JDialog中已实现，不用再添加\n        //setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        Container container=this.getContentPane();\n        container.setLayout(null);\n\n        container.add(new Label(\"弹窗文本\"));\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/67ec743c5f3a4281b71245e5ed1124b8.png?x-oss-process=image)\n\n\n\n## 标签(Icon)\n\nJLabel\n\n图标Icon\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class IconDemo extends JFrame implements Icon {\n\n    private int width;\n    private int height;\n\n    public IconDemo(){}//无参构造\n    public IconDemo(int width,int height){\n        this.width=width;\n        this.height=height;\n    }\n\n    public void init(){\n        IconDemo iconDemo=new IconDemo(13,15);\n        JLabel label=new JLabel(\"icontest\",iconDemo,SwingConstants.CENTER);\n\n        Container container=this.getContentPane();\n        container.add(label);\n\n        setVisible(true);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n\n    public static void main(String[] args) {\n        new IconDemo().init();\n    }\n\n\n    @Override\n    public void paintIcon(Component c, Graphics g, int x, int y) {\n        g.drawImage(new ImageIcon(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\chigua.png\").getImage(),10,10,new JPanel());\n    }\n\n    @Override\n    public int getIconWidth() {\n        return this.width;\n    }\n\n    @Override\n    public int getIconHeight() {\n        return this.height;\n    }\n}\n\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/079141d00d5c414b8f5dc3434560c2f6.png?x-oss-process=image)\n\n\n\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class ImageIconDemo extends JFrame{\n    public ImageIconDemo(){\n        //获取图片地址\n        JLabel label=new JLabel(\"ImageIcon\");\n        URL url=ImageIconDemo.class.getResource(\"chigua.png\");\n\n        ImageIcon imageIcon=new ImageIcon(url);\n        label.setIcon(imageIcon);\n        label.setHorizontalAlignment(SwingConstants.CENTER);\n\n        Container container=new Container();\n        container.add(label);\n\n        setBounds(100,100,100,100);\n        setVisible(true);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n    public static void main(String[] args) {\n        new ImageIconDemo();\n    }\n}\n```\n\n\n\n## 面板\n\n### JPanel\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JPanelDemo extends JFrame {\n    public JPanelDemo(){\n        Container container=this.getContentPane();\n        container.setLayout(new GridLayout(2,1,10,10));\n\n        JPanel panel1=new JPanel(new GridLayout(1,3));\n        JPanel panel2=new JPanel(new GridLayout(1,2));\n        JPanel panel3=new JPanel(new GridLayout(2,1));\n        JPanel panel4=new JPanel(new GridLayout(3,2));\n        panel1.add(new JButton(\"1\"));\n        panel1.add(new JButton(\"1\"));\n        panel1.add(new JButton(\"1\"));\n        panel2.add(new JButton(\"2\"));\n        panel2.add(new JButton(\"2\"));\n        panel3.add(new JButton(\"3\"));\n        panel3.add(new JButton(\"3\"));\n        panel4.add(new JButton(\"4\"));\n        panel4.add(new JButton(\"4\"));\n        panel4.add(new JButton(\"4\"));\n        panel4.add(new JButton(\"4\"));\n        panel4.add(new JButton(\"4\"));\n        panel4.add(new JButton(\"4\"));\n        container.add(panel1);container.add(panel2);\n        container.add(panel3);container.add(panel4);\n\n        setVisible(true);\n        setSize(500,500);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n    public static void main(String[] args) {\n        new JPanelDemo();\n    }\n}\n```\n\n注：JButton可以通过setIcon方法设置按钮图标\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ff086ec25fdc4a17a5a253b4e65bf6ba.png?x-oss-process=image)\n\n\n\n\n### JScrollPanel\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class JScrollDemo extends JFrame {\n    public JScrollDemo(){\n        Container container=this.getContentPane();\n\n        //文本域\n        JTextArea jTextArea=new JTextArea(20,50);\n        jTextArea.setText(\"测试测试测试测试测试测试测试测试\");\n\n        //Scroll面板\n        JScrollPane jScrollPane=new JScrollPane(jTextArea);\n        container.add(jScrollPane);\n        setVisible(true);\n        setBounds(100,100,300,350);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n    public static void main(String[] args) {\n        new JScrollDemo();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6dfaf10c646849e998faa42495af5e16.png?x-oss-process=image)\n\n\n\n\n\n\n## 按钮\n\n- 单选按钮\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class JButtonDemo extends JFrame {\n    public JButtonDemo(){\n        Container container=this.getContentPane();\n        //将一个图片变为图标\n        URL url=JButtonDemo.class.getResource(\"chigua.png\");\n\n        //单选框\n        JRadioButton radioButton1=new JRadioButton(\"单选1\");\n        JRadioButton radioButton2=new JRadioButton(\"单选2\");\n        JRadioButton radioButton3=new JRadioButton(\"单选3\");\n        //单选只能选一个，因此可以对其进行分组\n        ButtonGroup buttonGroup=new ButtonGroup();\n        buttonGroup.add(radioButton1);\n        buttonGroup.add(radioButton2);\n        buttonGroup.add(radioButton3);\n\n        container.add(radioButton1,BorderLayout.CENTER);\n        container.add(radioButton2,BorderLayout.NORTH);\n        container.add(radioButton3,BorderLayout.SOUTH);\n\n        setVisible(true);\n        setSize(500,300);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n    public static void main(String[] args) {\n        new JButtonDemo();\n    }\n}\n\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/425c48a89f4a49bba95742e5f1b46dc6.png?x-oss-process=image)\n\n\n\n\n\n\n- 多选按钮\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class JButtonDemo extends JFrame {\n    public JButtonDemo(){\n        Container container=this.getContentPane();\n        //将一个图片变为图标\n        URL url=JButtonDemo.class.getResource(\"chigua.png\");\n\n        //多选框\n        JCheckBox checkBox1=new JCheckBox(\"多选1\");\n        JCheckBox checkBox2=new JCheckBox(\"多选2\");\n        JCheckBox checkBox3=new JCheckBox(\"多选3\");\n\n        container.add(checkBox1,BorderLayout.CENTER);\n        container.add(checkBox2,BorderLayout.NORTH);\n        container.add(checkBox3,BorderLayout.SOUTH);\n\n        setVisible(true);\n        setSize(500,300);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n    public static void main(String[] args) {\n        new JButtonDemo();\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a26761b123a0480189bf458c911cb2c0.png?x-oss-process=image)\n\n\n\n## 列表\n\n- 下拉框\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\npublic class TestComboboxDemo extends  JFrame{\n\n    public TestComboboxDemo(){\n        Container container=this.getContentPane();\n\n        JComboBox subject=new JComboBox();\n\n        \n        subject.addItem(\"高等数学\");\n        subject.addItem(\"线性代数\");\n        subject.addItem(\"数据库\");\n        subject.addItem(\"数据结构\");\n        subject.addItem(\"计算机网络\");\n\n\n        container.add(subject);\n        setVisible(true);\n        setSize(500,300);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n\n    public static void main(String[] args) {\n        new TestComboboxDemo();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/aa0a58a7d8b74b4a83b70350f535a54e.png?x-oss-process=image)\n\n\n\n\n- 列表框\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Vector;\n\npublic class TestComboboxDemo extends  JFrame{\n\n    public TestComboboxDemo(){\n        Container container=this.getContentPane();\n\n        //生成列表内容\n        Vector contents=new Vector();\n        contents.add(\"操作系统\");\n        contents.add(\"数字电子技术\");\n        //列表中添加内容\n        JList jList=new JList(contents);\n        //可以实现动态添加内容\n        contents.add(\"高等数学\");\n        contents.add(\"线性代数\");\n        contents.add(\"计算机网络\");\n\n        container.add(jList);\n        setVisible(true);\n        setSize(500,300);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n\n    public static void main(String[] args) {\n        new TestComboboxDemo();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8e344bfe5ac84a57bc0cad33e62ceaa1.png?x-oss-process=image)\n\n\n\n\n\n## 文本框\n\n- 文本框（单行）\n\n\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class TestTextDemo extends JFrame {\n    public TestTextDemo(){\n        Container container=this.getContentPane();\n\n        JTextField textField1=new JTextField(\"hello\");\n        JTextField textField2=new JTextField(\"world\",20);\n\n        container.add(textField1,BorderLayout.NORTH);\n        container.add(textField2,BorderLayout.SOUTH);\n\n        setVisible(true);\n        setSize(500,300);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n    public static void main(String[] args) {\n        new TestTextDemo();\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ec00774fa2cc4cffa83630cdddbe8b6d.png?x-oss-process=image)\n\n\n\n\n\n- 密码框\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class TestTextDemo extends JFrame {\n    public TestTextDemo(){\n        Container container=this.getContentPane();\n\n        JPasswordField jPasswordField=new JPasswordField();\n        jPasswordField.setEchoChar('*');\n        container.add(jPasswordField);\n        setVisible(true);\n        setSize(500,300);\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n\n    public static void main(String[] args) {\n        new TestTextDemo();\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d7336267459547609040db7413afe4eb.png?x-oss-process=image)\n\n\n\n\n\n\n- 文本域\n\nJTextArea\n\n2.4的JScrollPanel测试中已用过，可以回看。\n\n\n\n# 实践：贪吃蛇\n\n定时器：Timer，用于划分游戏的帧数\n\n\n\n1. 定义数据结构\n2. 添加素材\n3. 添加监听事件\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c231c376406c4ab99330db622099bc57.png#pic_center)\n\n\n```java\npackage Snake;\n\nimport javax.swing.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\n//游戏的主启动类\npublic class StartGame {\n    public static void main(String[] args) {\n        JFrame frame=new JFrame();\n        frame.setVisible(true);\n        frame.setResizable(false); //锁定窗口大小\n        frame.setBounds(10,10,900,720);\n        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\n        //游戏的主要内容写在面板类中\n        frame.add(new GamePanel());\n    }\n}\n```\n\n\n\n\n\n```java\npackage Snake;\n\nimport javax.swing.*;\nimport java.net.URL;\n\n//数据中心类(图片素材相关数据)\npublic class Data {\n    public static URL headerURL=Data.class.getResource(\"static/chigua.png\");\n    public static URL bodyURL=Data.class.getResource(\"static/body.png\");\n    public static URL downURL=Data.class.getResource(\"static/down.png\");\n    public static URL foodURL=Data.class.getResource(\"static/food.png\");\n    public static URL leftURL=Data.class.getResource(\"static/left.png\");\n    public static URL rightURL=Data.class.getResource(\"static/right.png\");\n    public static URL upURL=Data.class.getResource(\"static/up.png\");\n\n    public static ImageIcon header=new ImageIcon(headerURL);\n    public static ImageIcon body=new ImageIcon(bodyURL);\n    public static ImageIcon down=new ImageIcon(downURL);\n    public static ImageIcon food=new ImageIcon(foodURL);\n    public static ImageIcon left=new ImageIcon(leftURL);\n    public static ImageIcon right=new ImageIcon(rightURL);\n    public static ImageIcon up=new ImageIcon(upURL);\n\n}\n```\n\n\n\n```java\npackage Snake;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.util.Random;\n\n//游戏面板\npublic class GamePanel extends JPanel implements KeyListener, ActionListener {\n    //设计🐍的数据结构\n    int length;  //🐍的长度\n    int[] snakeX=new int[600];  //🐍的x坐标 25*25\n    int[] snakeY=new int[500];  //🐍的y坐标 25*25\n    String fx;  //初始方向向右\n\n    //食物的坐标\n    int foodX,foodY;\n    Random random=new Random();\n\n\n\n    //游戏的状态：开始、停止\n    boolean isStart=false;\n    boolean isFail=false; //游戏失败状态\n    int score; //游戏得分\n    //定时器\n    Timer timer=new Timer(100,this); //100ms刷新一次\n\n\n    //构造器\n    public GamePanel() {\n        init();\n        //获取焦点和键盘事件\n        this.setFocusable(true); //获取焦点事件\n        //this.addKeyListener(this); //获取键盘监听事件\n        this.addKeyListener(this);\n        timer.start();\n    }\n\n    //初始化方法\n    public void init(){\n        length=3;\n        snakeX[0]=100;snakeY[0]=100; //头的坐标\n        snakeX[1]=75;snakeY[1]=100; //第一节身体的坐标\n        snakeX[2]=50;snakeY[2]=100; //第二节身体的坐标\n        fx=\"R\";\n\n        //事务位置随机分布\n        foodX=25+25*random.nextInt(24);\n        foodY=75+25*random.nextInt(24);\n        score=0;\n    }\n\n    //绘制面板\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g); //清屏\n\n        //绘制静态面板\n        this.setBackground(Color.BLACK);\n        Data.header.paintIcon(this,g,25,11); //头部栏\n        g.fillRect(25,75,850,600); //默认游戏界面\n\n        //画积分\n        g.setColor(Color.WHITE);\n        g.setFont(new Font(\"微软雅黑\",Font.BOLD,18));\n        g.drawString(\"长度\"+length,750,35);\n        g.drawString(\"分数\"+score,750,50);\n\n        //根据方向添加蛇头\n        switch (fx) {\n            case \"R\" -> Data.right.paintIcon(this, g, snakeX[0], snakeY[0]);\n            case \"L\" -> Data.left.paintIcon(this, g, snakeX[0], snakeY[0]);\n            case \"U\" -> Data.up.paintIcon(this, g, snakeX[0], snakeY[0]);\n            case \"D\" -> Data.down.paintIcon(this, g, snakeX[0], snakeY[0]);\n        }\n\n\n        for(int i=1;i<length;i++){\n            //第i节身体\n            Data.body.paintIcon(this,g,snakeX[i],snakeY[i]);\n        }\n\n        Data.food.paintIcon(this,g,foodX,foodY);\n\n\n        //游戏状态判断\n        if(!isStart){\n            g.setColor(Color.WHITE);\n            g.setFont(new Font(\"微软雅黑\",Font.BOLD,40));\n            g.drawString(\"点击空格开始游戏\",300,300);\n        }\n\n        if(isFail){\n            g.setColor(Color.RED);\n            g.setFont(new Font(\"微软雅黑\",Font.BOLD,40));\n            g.drawString(\"游戏失败，按下空格重新开始\",300,300);\n        }\n    }\n\n\n    //键盘监听事件\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int keyCode=e.getKeyCode(); // 获取键盘内容\n        if(keyCode==KeyEvent.VK_SPACE){\n            if(isFail){\n                isFail=false;\n                init();\n            }\n            else {\n                isStart = !isStart;\n            }\n            repaint();\n        }\n\n        //🐍移动\n        if(keyCode==KeyEvent.VK_UP){\n            fx=\"U\";\n        }\n        else if(keyCode==KeyEvent.VK_DOWN){\n            fx=\"D\";\n        }\n        else if(keyCode==KeyEvent.VK_LEFT){\n            fx=\"L\";\n        }\n        else if(keyCode==KeyEvent.VK_RIGHT){\n            fx=\"R\";\n        }\n    }\n\n    //事件监听   需要超过固定事件来刷新，1秒10次\n    @Override\n    public void actionPerformed(ActionEvent e){\n        if(isStart && !isFail){ //当前游戏是开始状态。小蛇运动\n\n            //吃食物\n            if(snakeX[0]==foodX && snakeY[0]==foodY){\n                length++;\n                score+=10;\n                //再生成一个食物\n                foodX=25+25*random.nextInt(24);\n                foodY=75+25*random.nextInt(24);\n            }\n\n            //身体移动\n            for(int i=length-1;i>0;i--){\n                snakeX[i]=snakeX[i-1];\n                snakeY[i]=snakeY[i-1];\n            }\n\n            //走向\n            if(fx.equals(\"R\")){\n                snakeX[0]=snakeX[0]+25;\n                if(snakeX[0]>850) snakeX[0]=25;\n            }\n            else if(fx.equals(\"L\")){\n                snakeX[0]=snakeX[0]-25;\n                if(snakeX[0]<25) snakeX[0]=850;\n            }\n            else if(fx.equals(\"U\")){\n                snakeY[0]=snakeY[0]-25;\n                if(snakeY[0]<25) snakeY[0]=650;\n            }\n            else if(fx.equals(\"D\")){\n                snakeY[0]=snakeY[0]+25;\n                if(snakeY[0]>650) snakeY[0]=75;\n            }\n\n            //失败判断\n            for(int i=1;i<length;i++){\n                if(snakeX[0]==snakeX[i] && snakeY[0]==snakeY[1]){\n                    isFail=true;\n                }\n            }\n\n            repaint();\n        }\n        timer.start(); //定时器开启\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e) {}\n    @Override\n    public void keyReleased(KeyEvent e) {}\n}\n```\n\n","categories":[],"tags":["JavaSE"]},{"title":"Java IO 框架","url":"/posts/21012/","content":"\n\n# Java IO框架\n参考视频: BV1Tz4y1X7H7\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/122483591\n\n\n\n# 流的概念\n\n流的定义：内存与存储设备之间传输数据的通道\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7ee8c866c9184462ab92862a12962d32.png?x-oss-process=image)\n\n\n\n\n\n\n# 流的分类\n\n\n\n> 按方向\n\n**输入流**：将存储设备中的内容读入到内存中。\n\n**输出流**：将内存中的内容写入到存储设备中。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9e373aed346e4c7f859f053b587239b6.png#pic_center)\n\n\n> 按单位\n\n**字节流**：以字节为单位，可以读写所有数据。\n\n**字符流**：以字符为单位，只能读写文本数据。\n\n\n\n\n\n> 按功能\n\n**字节流**：具有实际传输数据的读写功能。\n\n**过滤流**：在节点流的基础之上增强功能。\n\n\n\n# 字节流\n\n## 继承关系\n\n\n\n输入流继承关系\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3a9fd10be1de42dc8ec1bf9a0a70c9fb.png?x-oss-process=image)\n\n\n输出流继承关系\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3cb6d0b60f844413b46ec08f0b5cf33e.png?x-oss-process=image)\n\n\n\n\n## 字节流的抽象父类\n\nInputStream\n\n字节输入流\n\n- `public int read(){}`\n- `public int read(byte[] b){}`\n- `public int read(byte[] b,int off,int len){}`\n\nOutputStream\n\n字节输出流\n\n- `public void write(int n){}`\n- `public void write(byte[] b){}`\n- `public void write(byte[] b,int off,int len){}`\n\n\n\n## 字节流的子类\n\n### 文件字节流\n\n**FileInputStream**\n\n- `public int read()`//从输入流中读取一个字节数据，返回读到的字节数据，如果达到文件末尾，返回-1。\n- `public int read(byte[] b)`//从输入流中读取字节数组长度的字节数据存入数组中，返回实际读到的字节数；如果达到文件的尾部，则返回-1。\n\n**FileOutputStream**\n\n- `public void write(int b)`//将指定字节写入输出流。\n- `public void write(bute[] b)`//一次写多个字节，将b数组中所有字节，写入输出流。\n\n\n\n#### 测试\n\n```java\n/*\n*  FileInputStream测试\n*/\npublic class MainTest {\n    public static void main(String[] args) throws IOException {\n        //文件内容：dafegesa\n        FileInputStream ifs=new FileInputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\");\n\n        //read();读入单个字节\n        System.out.println(\"读入单个字节\");\n        int data=ifs.read();\n        System.out.println((char)data);\n        while((data=ifs.read())!=-1){  //-1代表文件已读完\n            System.out.println((char)data);\n        }   //按1个字节依次输出\n//==========上下两个测试部分不能同时进行，因为上半部分读完数据后输入流为空=======\n        ifs.reset();\n        //read(byte[] b); 读入多个字节\n        byte[] b=new byte[3];   //一次读取的字节数=byte的容量\n        if((data=ifs.read(b))!=-1){\n            System.out.println(new String(b,0,data));\n        }   //按3个字节依次输出\n\n        ifs.close();\n    }\n}\n```\n\n\n\n```java\n/*\n*  FileOutputStream测试\n*/\npublic class MainTest {\n    public static void main(String[] args) throws IOException {\n        //文件内容：dafegesa     若没有文件则会自动创建\n        FileOutputStream ofs=new FileOutputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\");\n\n        //write(int b);\n        ofs.write(97);\n        ofs.write('b');\n        ofs.write('c');\n\n        //write(byte[] b);\n        ofs.write(new String(\"hellorld\").getBytes());\n        //此时文件bbb.txt内容为abchelloworld    原内容被替换\n\n        ofs.close();\n    }\n}\n```\n\n#### 读取图片\n\n```java\npublic class MainTest {\n    public static void main(String[] args) throws IOException {\n        FileInputStream ifs=new FileInputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\right\\\\ganyu\\\\chigua.png\");\n        FileOutputStream ofs=new FileOutputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\chigua.png\");\n\n\n        int count; //保存一次读取到的实际字节数\n        byte[] b=new byte[1024];\n\n        while((count=ifs.read(b))!=-1){\n            ofs.write(b,0,count);\n        }\n        System.out.println(\"复制完成\");\n        ifs.close();\n        ofs.close();\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8619b7f92f80487cbda54704fe6616cf.png?x-oss-process=image)\n\n\n\n\n### 字节缓冲流\n\nBufferedInputStream\nBufferedOutputStream\n\n目的：\n\n1. 提高IO效率，减少访问磁盘的次数；\n2. 数据存储在缓冲区中。flush可以将缓存区的内容写入文件，也可以直接close。\n\n#### 测试\n\n```java\n/**\n* 使用字节缓冲流读取\n* BufferedInputStream\n*/\npublic class MainTest {\n    public static void main(String[] args) throws IOException {\n        FileInputStream ifs=new FileInputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\");\n\n        //缓冲流需要一个底层流\n        BufferedInputStream bis=new BufferedInputStream(ifs);\n\n        //读取\n        int data;\n        while((data=bis.read())!=-1){\n            System.out.println((char)data);\n        }\n\n\n        int count; //保存一次读取到的实际字节数\n        byte[] b=new byte[1024];\n        while((count=bis.read(b,0,b.length))!=-1){\n            System.out.println(new String(b,0,count));\n        }\n        bis.close();\n    }\n}\n```\n\n\n\n```java\n/**\n* 使用字节缓冲流写入文件\n* BufferedOutputStream\n*/\npublic class MainTest {\n    public static void main(String[] args) throws IOException {\n        FileOutputStream ofs=new FileOutputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\");\n\n        //缓冲流将数据写入缓冲区\n        BufferedOutputStream bos=new BufferedOutputStream(ofs);\n\n        //写入文件\n        bos.write(\"helloworld\".getBytes());\n        bos.flush();  //确认修改。源码内部也会调用flush方法\n\n        bos.close();\n    }\n}\n```\n\n\n\n### 对象流\n\nObjectOutputStream\nObjectInputStream\n\n- 增加了缓冲区功能。\n- 增强了读写8种基本数据类型和字符串功能。\n- 增强了读写对象的功能：\n  - `readObject()`//从流中读取一个对象。又称反序列化\n  - `writeObject(Object obj)`向流中写入一个对象。又称序列化\n\n\n\n#### 序列化\n\n```java\n/**\n* Student类\n*/\n\n//要实现序列化必须先实现Serializable接口（源码为空，只是起标记作用）\npublic class Student implements Serializable {\n    private String name;\n    private int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\"name='\" + name + '\\'' +\", age=\" + age +'}';\n    }\n}\n\n```\n\n\n\n```java\n/**\n * 使用ObjectOutputStream实现对象的序列化\n */\npublic class MainTest {\n    public static void main(String[] args) throws IOException {\n        FileOutputStream ofs=new FileOutputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\obj.bin\");\n        ObjectOutputStream obs=new ObjectOutputStream(ofs);\n\n        //序列化(写文件)\n        Student tang=new Student(\"唐瑞\",21);\n        obs.writeObject(tang);\n        obs.close();\n        System.out.println(\"序列化完成\");\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a88741b9e9534f258575d8614c756059.png?x-oss-process=image)\n\n\n\n\n#### 反序列化\n\n\n\n```java\n/**\n * 使用ObjectInputStream实现反序列化（读取重构对象）\n */\npublic class MainTest {\n    public static void main(String[] args) throws IOException,ClassNotFoundException {\n        FileInputStream ifs=new FileInputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\obj.bin\");\n        ObjectInputStream obs=new ObjectInputStream(ifs);\n\n        //反序列化(读取文件)\n        Student student=(Student)obs.readObject();\n        obs.close();\n        System.out.println(\"反序列化完成\");\n        System.out.println(student.toString());\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/06c5a95703fc496cb9ed29ab755851b6.png#pic_center)\n\n\n#### 附加说明\n\n- 序列化类及其内部类必须实现Serializable接口。\n\n- 序列化类中可以添加<u>序列化版本号ID</u>，以保证序列化的类和被序列化的类是同一个类。在上面的代码中并没有添加序列号版本，虽然IDE没有报错，但是会显示一个警告，提示我添加序列化版本号（串行版本标识）。我们可以在Student类中添加：\n\n```java\nprivate static final long serialVersionUID = 100L;  //序列号\n```\n\n此时执行反序列化会报错\n\n```java\nException in thread \"main\" java.io.InvalidClassException: Student; local class incompatible: stream classdesc serialVersionUID = 5061154393647412285, local class serialVersionUID = 100\n```\n\n报错内容说明两个类的serialVersionUID不同，`5061154393647412285`是我们没有自定义序列号时，序列化过程中系统自动生成的。  可以在修改序列号后重新序列化，这之后反序列化就能通过。\n\n\n\n- tranisient(瞬时的)修饰符，可以避免修饰的属性被序列化，如：\n\n  ```java\n  private transient int age;\n  ```\n\n  此时将学生类序列化后，age不会被写入目标文件。反序列化的结果中，age是一个默认值。\n\n- 静态属性不能被序列化\n- 可以利用集合来序列化多个对象\n\n```java\nArrayList<Student> arrayList=new ArrayList<Student>();\narrayList.add(s1);\narrayList.add(s2);\narrayList.add(s3);\nobjectOutputStream.writeObject(arrayList);\n```\n\n```java\nArrayList<Student> list=(ArrayList<Student>)objectInputStream.readObject();\n\n//反序列化的结果是一个集合\n```\n\n\n\n\n\n\n\n# 编码方式\n\n- IOS-8859-1\n\n  收录除ASCII外，还包括西欧、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。采用1个字节来表示，最多只能表示256个字符。\n\n- UTF-8\n\n  针对Unicode码表的可变长度字符编码。国际上使用的编码，也称为“万国码”，收录了几乎所有国家的常用字符。采用1至3个字节来表示一个字符。\n\n- GB2312\n\n  简体中文，采用1个或2个字节来表示字符，95年之前所采用的编码。\n\n- GBK\n\n  简体中文的扩充，GB2312的升级版本。\n\n- BIG5\n\n  台湾，繁体中文。\n\n**当编码方式和解码方式不一致时，会出现乱码**。假如要读取的文件中的内容不是字母而是“**一二三四**”这样的汉字，那么读取出来的信息就是乱码。因为字节流按<u>字节</u>输入输出，而这<u>四个汉字占了12个字节</u>，把一个汉字按一个一个字节读入自然会出现问题，这时就需要使用字符流。\n\n\n\n\n\n# 字符流\n\n## 字符流继承关系\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1a5bb951a0e44dfd9b3e56dc05de23cc.png?x-oss-process=image)\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3ab1b910d309406b8ec8ec4ec7dc56b5.png?x-oss-process=image)\n\n\n\n\n## 字符流的抽象父类\n\n- **Reader：**字符输入流\n\n  - `public int read()`\n\n    从流中读取单个字符，用整型来返回读取的字符；当读到流底部时返回-1。\n\n  - `public int read(char[] c)`\n\n    从流中读取字符保存到c数组中，返回读取的字符个数，当读到流底部时返回-1。\n\n  - `public int read(char[] cbuf,int off,int len){}`\n\n    抽象方法。\n\n- **Writer：**字符输出流\n\n  - `public void write(int n)`\n\n    写入单个字符，只能写入包含16位低阶字节的整型数值，16位高阶字节将会被忽略。\n\n  - `public void write(String str)`\n\n    写入一个字符串。\n\n  - `public void write(char[] cbuf)`\n\n    写入一个字符数组。\n\n\n\n\n\n## 字符流的子类\n\n### FileReader\n\n- `public int read()`\n\n  继承自InputStreamReader类。读取单个字符，返回读取的字符，当读到流底部时返回-1。\n\n- `public int read(char[] c)`\n\n  继承自Reader类。\n\n- `public int read(char[] cbuf,int offset,int length)`\n\n  继承自InputStreamReader类。从流中读取部分字符到cbuf中指定位置，返回读取到的字符个数，当读到流底部时返回-1。\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        FileReader ifs=new FileReader(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\");\n\n        int data;\n        //read(); 每次读取一个字符而不是一个字节\n        while((data=ifs.read())!=-1){\n            System.out.println((char)data);\n        }\n        ifs.close();\n    }\n}\n\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c7349f86f9824d8bb3d33aa03928b373.png?x-oss-process=image)\n\n\n\n\n### FileWriter\n\n- `public void write(int c)`\n\n  继承自OutputStreamWriter类，写入一个字符。\n\n- `public void write(String str)`\n\n  继承自Writer类。\n\n- `public void Write(char[] cbuf)`\n\n  继承自Writer类。\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        FileWriter ofs=new FileWriter(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\");\n\n        int data;\n        ofs.write(\"测试测试测试测试\");\n        ofs.close();\n        System.out.println(\"执行完毕\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/31aba701076d4ee4ac1f5f75c9938b68.png?x-oss-process=image)\n\n\n\n\n\n\n### 字符流复制测试\n\n```java\n/**\n * 使用FileReader和FileWrite复制文本文件\n *  注：不能复制图片或二进制文件\n */\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        InputStreamReader inputStreamReader=new InputStreamReader(new FileInputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\"));\n        FileWriter ofs=new FileWriter(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp1.txt\");\n\n        //读写\n        int data=0;\n        while((data=inputStreamReader.read())!=-1){\n            ofs.write(data);\n        }\n\n        inputStreamReader.close();\n        ofs.close();\n        System.out.println(\"执行完毕\");\n    }\n}\n\n```\n\n\n\n## 字符缓冲流\n\nBufferedReader\nBufferedWriter\n\n- 高效读写\n- 支持换行输入符\n- 可一次写一行、读一行。\n\n```java\n/**\n * 使用字符缓冲流读取文件\n * BufferedReader\n */\n\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        InputStreamReader inputStreamReader=new InputStreamReader(new FileInputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp.txt\"));\n        BufferedReader bufferedReader=new BufferedReader(inputStreamReader);\n\n        //read(char[] cbuf)\n        char[] cbuf=new char[3]; //一次读3的字符\n        int count;\n        while((count=bufferedReader.read(cbuf))!=-1){\n            System.out.println(new String(cbuf,0,count));\n        }\n//==================上下部分不能同时进行，上部分读完后缓冲区已为空===================\n        //readline();  一次读取一行\n        String line;\n        while((line=bufferedReader.readLine())!=null){\n            System.out.println(line);\n        }\n\n        System.out.println(\"执行完毕\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94f8cc230bc84e5f8fd8f88df7559192.png?x-oss-process=imager)\n\n\n\n\n\n\n```java\n/**\n * 使用字符缓冲流写入文件\n * BufferedWriter\n */\n\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp1.txt\"));\n        bufferedWriter.write(\"测试一测试一测试一\\r\\n测试一测试一\");\n        //换行符: windows-->\\r\\n    linux \\n\n        bufferedWriter.newLine();\n        bufferedWriter.write(\"测试二\\r\\n测试二测试二测试二测试二\");\n\n        bufferedWriter.close();\n        System.out.println(\"执行完毕\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/02f853b7f45b471a9fb65bc55df50abc.png?x-oss-process=image)\n\n\n\n\n\n\n## 打印流\n\n**PrintWriter：**\n\n- 封装了print()/println()方法，支持写入后换行。\n- 支持数据原样打印。比如打印97会按原样写入97而不是转成‘a’。\n\n```java\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        PrintWriter printWriter=new PrintWriter(new FileWriter(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp1.txt\"));\n\n        //打印到文件\n        printWriter.println(97);//97\n        printWriter.println('b');//b\n        printWriter.println(3.14);//3.14\n        printWriter.println(true);//true\n\n        printWriter.close();\n        System.out.println(\"执行完毕\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6d6bd8d0d22a404a8b4f4fdc3252c552.png#pic_center)\n\n\n\n\n\n\n## 转换流\n\n**桥转换流**：InputStreamReader/OutputStreamWriter\n\n- 可将字节流转换为字符流。\n- 可设置字符的编码方式。\n\n```java\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        OutputStreamWriter outputStreamWriter=new OutputStreamWriter(new FileOutputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp1.txt\"));\n\n        outputStreamWriter.write(\"转换流测试\");\n        outputStreamWriter.close();\n        System.out.println(\"执行完毕\");\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ceb4f3c0cd9740e9b4516400fd707dca.png#pic_center)\n\n\n\n\n# File类\n\nFile类可以指向一个文件或一个目录\n\n**方法**：\n\n- `public boolean CreateNewFile()`\n\n  当且仅当指定的文件名不存在时创建一个指定的新的、空的文件。创建成功返回true，如果指定文件名已存在返回false。\n\n- `public boolean mkdir()`\n\n  创建一个指定路径名的文件夹。当且仅当文件夹被创建时返回true，否则返回false。\n\n- `public boolean delete()`\n\n  删除一个指定的文件或文件夹，文件夹必须为空才能被删除。当且仅当指定的文件或文件夹被删除时返回true，否则返回false。\n\n- `public boolean exists()`\n\n  检查指定的文件或文件夹是否存在。当且仅当指定的文件或者文件夹存在时返回true，否则返回false。\n\n- `public File[] listFiles()`\n\n  列出目录中的所有内容，返回一个指定路径名中的文件数组，如果指定的路径名不代表一个文件夹（目录）就返回null。\n\n- `public boolean renameTo(File dest)`\n\n  重命名一个路径名所指定的文件。当且仅当修改操作成功时返回true，否则返回false。\n\n\n\n## 文件操作\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) throws IOException,InterruptedException{\n        //输出：\n        //路径分隔符：;\n        //名称分隔符：\\\n        separator();\n        fileOp();\n    }\n\n    public static void separator() {\n        System.out.println(\"路径分隔符：\"+File.pathSeparator);\n        System.out.println(\"名称分隔符：\"+File.separator);\n    }\n\n    public static void fileOp() throws IOException,InterruptedException {\n        //1.创建文件\n        File file=new File(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\temp1.txt\");\n        if(!file.exists()){\n            boolean flag=file.createNewFile();\n            System.out.println(\"创建状态\"+flag);\n        }\n\n        //2.删除文件\n        //2.1 直接删除\n        //System.out.println(\"删除结果：\"+file.delete());\n\n        //2.2使用JVM退出时自动删除\n        file.deleteOnExit();\n        Thread.sleep(5000);  //延迟5秒后自动删除文件\n\n\n        //3.获取文件信息\n        System.out.println(\"文件绝对路径：\"+file.getAbsolutePath());\n        System.out.println(\"获取路径：\"+file.getPath());\n        System.out.println(\"获取父目录：\"+file.getParent());\n        System.out.println(\"获取文件名称：\"+file.getName());\n        System.out.println(\"获取文件长度：\"+file.length());\n        System.out.println(\"获取文件创建时间：\"+new Date(file.lastModified()));\n\n        //4.判断内容\n        System.out.println(\"是否可写：\"+file.canWrite());\n        System.out.println(\"是否可读：\"+file.canRead());\n        System.out.println(\"是否隐藏：\"+file.isHidden());\n        System.out.println(\"是否是文件：\"+file.isFile());\n        System.out.println(\"是否是文件夹：\"+file.isDirectory());\n    }\n\n}\n```\n\n\n\n\n\n## 目录操作\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args){\n        directorOp();\n    }\n\n    public static void directorOp() {\n        //1.创建目录\n        File dir=new File(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\");\n        if(!dir.exists()){\n            //mkdir();  只能创建单级目录\n            boolean flag=dir.mkdirs();  //创建多级目录\n            System.out.println(\"创建结果：\"+flag);\n        }\n\n        //2.删除目录\n        //2.1直接删除\n        //System.out.println(\"删除结果：\"+dir.delete());\n\n        //2.2使用JVM删除\n        dir.deleteOnExit();\n\n\n        //3.获取目录信息\n        System.out.println(\"获取绝对路径：\"+dir.getAbsolutePath());\n        System.out.println(\"获取路径：\"+dir.getPath());\n        System.out.println(\"获取父目录：\"+dir.getParent());\n        System.out.println(\"获取创建时间：\"+new Date(dir.lastModified()));\n        System.out.println(\"文件夹名称：\"+dir.getName());\n\n        //4.判断\n        System.out.println(\"是否隐藏：\"+dir.isHidden());\n        System.out.println(\"是否是文件：\"+dir.isFile());\n\n        //5.遍历目录\n        File dir2=new File(\"C:\\\\Users\\\\96955\\\\Desktop\");\n        String[] files=dir2.list();\n        for(String string:files){\n            System.out.println(string);\n        }\n    }\n}\n```\n\n\n\n## 文件过滤器\n\n**FileFilter接口：**\n\n`public interface FileFilter`\n\n- `boolean accepte(File pathname)`\n- 当调用File类中的listFiles()方法时，支持传入FileFilter接口实现类，对获取的文件进行过滤，只有满足条件的文件才可以出现在listFiles()的返回值中。\n\n\n\n```java\n//实现只打印当前目录中的txt文件的文件名\n\n//这段代码卸载6.2中的\"5.遍历目录\"处\npublic static void  directorOp() {\n    File[] files1=dir2.listFiles(new FileFilter() {\t\t\n        //自定义筛选条件\n        @Override\n        public boolean accept(File pathname) {\n            if(pathname.getName().endsWith(\".txt\")) {\n                return true;\n            }\n            return false;\n        }\n    });\n    \n    for (File file : files1) {\n        System.out.println(file.getName());\n    }\n}\n\n```\n\n\n\n## 文件操作案例\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args){\n        //......\n    }\n\n    //递归遍历目录\n    public static void listDer(File dir) {\n        File[] files=dir.listFiles();\n        if(files!=null && files.length>0){   //files是目录\n            for(File file:files){\n                if(file.isDirectory()){\n                    listDer(file);\n                }\n                else{\n                    System.out.println(file.getName());\n                }\n            }\n        }\n    }\n    \n    //递归删除目录\n    public static void deleteDir(File dir) {\n        File[] files=dir.listFiles();\n        if(files!=null && files.length>0){\n            for(File file:files){\n                if(file.isDirectory()){\n                    deleteDir(file);\n                }\n                else file.delete();\n            }\n        }\n        dir.delete();\n    }\n}\n```\n\n\n\n# Prioerties类\n\n又称属性集合。使用方式和map类似。\n\n特点：\n\n- 存储属性名和属性值(都是字符串类型)\n- 没有泛型\n- 和流有关\n\n**方法：**\n\n- `public String getProperty(String key)`\n\n  根据key在属性列表里查找value，如果原始属性列表找不到就去默认属性列表找。返回key所对应的value。\n\n- `public void list(PrintWriter out)`\n\n  将属性列表打印在指定的输出流上，在debug时很有用。\n\n- `public Object setProperty(String key,String value)`\n\n  内部调用的是Hashtable的put方法，将key和value成对地保存在属性列表中。返回这个key上一个对应的value，没有就返回null。\n\nProperties可以保存在一个流中或是从一个流中加载，属性列表中的每个键值对都是一个字符串。一个属性列表可以包括另一个第二属性列表来作为它的默认值，如果在原始属性列表中没有找到key时就搜索第二属性列表。\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) throws IOException{\n        Properties properties=new Properties();\n        //添加数据\n        properties.setProperty(\"username\",\"tanghui\");\n        properties.setProperty(\"age\",\"21\");\n        System.out.println(properties.toString());\n\n        //遍历    使用keySet、entrySet的过程与map相近\n        //使用stringPropertyNames() 遍历\n        Set<String> set=properties.stringPropertyNames();\n        for(String string:set){\n            System.out.println(string+\" \"+properties.getProperty(string));\n        }\n\n        //和流有关的方法\n        //list\n        PrintWriter printWriter=new PrintWriter(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\temp1.txt\");\n        properties.list(printWriter);   //properties中的内容写入文件\n        printWriter.close();\n\n        //store保存\n        FileOutputStream fileOutputStream=new FileOutputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\a.properties\");\n        properties.store(fileOutputStream,\"NOTES\");\n        fileOutputStream.close();\n\n        //load加载\n        Properties properties1=new Properties();\n        FileInputStream fileInputStream=new FileInputStream(\"C:\\\\Users\\\\96955\\\\Desktop\\\\tempblog\\\\a.properties\");\n        properties1.load(fileInputStream);   //从properties文件中读取内容\n        fileInputStream.close();\n        System.out.println(properties1.toString());\n    }\n}\n```\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/518f0291d72b4997a64ec76d2e50ee4d.png?x-oss-process=image)\n\n","categories":[],"tags":["JavaSE"]},{"title":"Java 集合框架","url":"/posts/40254/","content":"\n\n# Java集合框架\n\n参考视频:【千锋】Java集合框架详解   BV1zD4y1Q7Fw\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/122465544\n\n# 集合概述\n\n目的：对象的容器，实现了对对象常用的操作\n\n与数组的区别：\n\n1. 数组长度固定，集合长度不固定。\n2. 数组刻意存储基本类型和引用类型，集合只能存储引用类型\n\n位置：java.util.*;\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6e7feccda34d4010a45312e77833cd19.png?x-oss-process=image)\n\n\n\n\n# Colleection接口\n\n特点：代表一组任意类型的对象，无序、无下标、不能重复。\n\n常见方法\n\n```java\nboolean add(Object obj)  //添加一个对象\nboolean addAll(Collection c) //将一个集合中的所有对象添加到此集合中\nvoid clear()    //清空所有对象\nboolean contaions(Object o) //检查此集合种是否包含o对象\nboolean equals(Object o) //比较此集合是否与指定对象相等\nboolean isEmpty()   //判断集合是否为空\nboolean remove(Object o)  //移出集合中的对象o\nint size()  //当前集合中的元素个数\nObject[] toArray()   //将集合转换成数组\n```\n\n\n\n### 测试1\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        Collection testCollection=new ArrayList();\n        //添加元素\n        System.out.println(\"==============添加元素===============\");\n        testCollection.add(\"橘子\");\n        testCollectiwon.add(\"张三\");\n        testCollection.add(\"Terminal\");\n        testCollection.add(\"e\");\n        System.out.println(\"元素个数:\"+testCollection.size());\n        System.out.println(testCollection.toString());\n\n        //删除元素\n        System.out.println(\"==============删除元素===============\");\n        testCollection.remove(1);\n        System.out.println(\"元素个数:\"+testCollection.size());\n        System.out.println(testCollection.toString());\n\n        //普通遍历元素\n        System.out.println(\"=============普通遍历元素=============\");\n        System.out.println(\"元素个数:\"+testCollection.size());\n        for(Object x:testCollection){\n            System.out.println(x.toString());\n        }\n\n        //迭代器遍历元素\n        System.out.println(\"=============迭代器遍历元素=============\");\n        System.out.println(\"元素个数:\"+testCollection.size());\n        Iterator it=testCollection.iterator();\n        while(it.hasNext()){\n            System.out.println(it.next().toString());\n            \n      // 迭代器遍历过程中不能对testCollection使用方法。如testClooection.remove(e);\n      // 不过可以执行it.remove()\n            \n        }\n\n        //判断集合是否为空\n        System.out.println(\"===========判断集合是否为空===========\");\n        System.out.println(\"集合为空？\"+testCollection.isEmpty());\n        System.out.println(\"执行clear方法\");\n        testCollection.clear();\n        System.out.println(\"集合为空？\"+testCollection.isEmpty());\n    }\n}\n\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bea13023154740c09afff80ab9e1ea47.png?x-oss-process=image)\n\n\n\n\n### 测试2\n\n\n\n```java\n/*\n\t学生类\n*/\npublic class Student {\n    private String name;\n    private int age;\n\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}';\n    }\n}\n\n```\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        Collection testCollection=new ArrayList();\n        Student s1=new Student(\"张三\",18);\n        Student s2=new Student(\"李四\", 20);\n        Student s3=new Student(\"王五\", 19);\n\n        //添加数据   同一个对象可以重复添加\n        System.out.println(\"=============添加数据================\");\n        testCollection.add(s1);\n        testCollection.add(s2);\n        testCollection.add(s3);\n        System.out.println(\"元素个数：\"+testCollection.size());\n        System.out.println(testCollection.toString());\n\n        //删除数据\n        System.out.println(\"=============删除数据================\");\n        testCollection.remove(s3);\n        System.out.println(\"元素个数：\"+testCollection.size());\n        System.out.println(testCollection.toString());\n\n        //遍历数据(迭代器)\n        System.out.println(\"=============迭代器遍历================\");\n        Iterator it=testCollection.iterator();\n        while(it.hasNext()){\n            System.out.println(it.next().toString());\n        }\n\n    }\n}\n\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/40defd4181e240a2953ee1d81eb95d8c.png?x-oss-process=image)\n\n\n\n\n# List接口与实现类\n\n## List接口\n\n特点： 有序、有下标、元素可重复\n\n常见方法\n\n```java\nvoid add(int index, Object o)  //在index位置插入对象o\nboolean addAll(index,Collection c) //将集合c中的所有元素添加到该List集合的index位置\nObject get(int index) //返回集合中指定位置的元素\nList subList(int fromIndex, int toIndex) //返回fromIndex和toIndex之间的集合元素\n```\n\n\n\n### 测试\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n\n        //添加数据   同一个对象可以重复添加\n        List testList=new ArrayList();\n        testList.add(\"a\");\n        testList.add(\"b\");\n        testList.add(\"d\");\n        testList.add(0,\"c\");\n        System.out.println(testList.toString());\n\n        //删除数据\n        testList.remove(0);   //等价于testList.remove(\"c\");\n\n\n        //普通遍历\n        for(int i=0;i<testList.size();i++){\n            System.out.println(testList.get(i));\n        }\n\n\n        //迭代器遍历\n        System.out.println(\"从左往右遍历\");\n        ListIterator it=testList.listIterator();\n        while(it.hasNext()){\n            System.out.println(it.next().toString());\n        }\n\n        System.out.println(\"上面遍历完成后从右往左遍历\");\n        while (it.hasPrevious()){\n            System.out.println(it.previous().toString());\n        }\n\n        //判断有没有元素\"c\"\n        System.out.println(testList.contains(\"c\"));\n        //获取位置\n        System.out.println(\"元素b的位置:\"+testList.indexOf(\"b\"));\n        //获取子串\n        List subTest=testList.subList(1,3);\n        System.out.println(subTest.toString());\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/12301fea177d4b95984e89e014f483af.png?x-oss-process=image)\n\n\n\n\n\n\n## 2.2 List实现类\n\n### 2.2.1 ArrayList\n\n数组结构实现，查询快、增删慢。需要开辟连续空间。\n\n\n\n#### ArrayList测试\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n\n        //添加数据   同一个对象可以重复添加\n        ArrayList test=new ArrayList();\n        Student s1=new Student(\"唐\", 21);\n        Student s2=new Student(\"何\", 22);\n        Student s3=new Student(\"余\", 21);\n        test.add(s1);\n        test.add(s2);\n        test.add(s3);\n        System.out.println(\"元素个数：\"+test.size());\n        System.out.println(test.toString());\n\n\n        //删除数据\n        test.remove(s1);\n        //这里不能写成test.remove(new Student(\"唐\",21));\n        //这里新建的对象与s1引用的是不同的对象\n\n\n        //迭代器遍历\n        System.out.println(\"从左往右遍历\");\n        ListIterator it=test.listIterator();\n        while(it.hasNext()){\n            System.out.println(it.next().toString());\n        }\n\n        System.out.println(\"上面遍历完成后从右往左遍历\");\n        while (it.hasPrevious()){\n            System.out.println(it.previous().toString());\n        }\n\n        //判断\n        System.out.println(test.isEmpty());\n\n        //获取位置  -1代表没找到\n        System.out.println(test.indexOf(s1));\n    }\n}\n```\n\n\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b27398f822854d358b81c23d081e30ef.png?x-oss-process=image)\n\n\n\n\n#### 源码分析\n\n默认容量大小：`private static final int DEFAULT_CAPACITY = 10;`\n\n存放元素的数组：`transient Object[] elementData;`\n\n实际元素个数：`private int size;`\n\n\n\n创建对象时调用的无参构造函数：\n\n```java\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n这段源码说明当你没有向集合中添加任何元素时，集合容量为0。\n\n默认的10个容量与下面的add方法相关：\n\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\n```\n\n假设new了一个数组，当前容量为0，size当然也为0。这时调用add方法进入到ensureCapacityInternal(size + 1)\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n```\n\nelementData就是存放元素的数组，当前容量为0，if条件成立，返回默认容量`DEFAULT_CAPACITY`也就是10。这个值作为参数又传入`ensureExplicitCapacity()`方法中，进入该方法查看源码：\n\n```java\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\n已知elementData.length=0，故if条件为真，调用grow()函数\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n这个方法先声明了一个oldCapacity变量将数组长度赋给它，其值为0；又声明了一个newCapacity变量其值为`oldCapacity+一个增量`，可以发现这个增量是和原数组长度有关的量，当然在这里也为0。\n第一个if条件满足，newCapacity的值为10。\n第二个if条件不成立，也可以不用注意，因为MAX_ARRAY_SIZE的定义如下(数值很大)：\n\n```java\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n```\n\n最后一句话是给elementData赋了一个新的长度，`Arrays.copyOf()`方法返回的数组是新的数组对象，原数组对象不会改变，该拷贝不会影响原来的数组。`copyOf()`的第二个变量用于指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值。\n\n这时候再回到add的方法中，接着就向下执行`elementData[size++] = e;`\n\n\n\n\n\n### 2.2.2 Vector\n\n大体内容、特性与ArrayList差不多，现在已不常用。\n\n\n\n### 2.2.3 LinkedList\n\n特点：增删快，查询慢。无需开辟连续空间。\n\n大体方法与ArrayList相近\n\n#### LinkedList测试\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n\n        LinkedList linkedList=new LinkedList<>();\n        Student s1=new Student(\"唐\", 21);\n        Student s2=new Student(\"何\", 22);\n        Student s3=new Student(\"余\", 21);\n        //1.添加元素\n        linkedList.add(s1);\n        linkedList.add(s2);\n        linkedList.add(s3);\n        linkedList.add(s3);\n        System.out.println(\"元素个数：\"+linkedList.size());\n        System.out.println(linkedList.toString());\n        //2.删除元素\n        /*\n         * linkedList.remove(new Student(\"唐\", 21));\n         * System.out.println(linkedList.toString());\n         */\n        //3.遍历\n        //3.1 使用for\n        for(int i=0;i<linkedList.size();++i) {\n            System.out.println(linkedList.get(i));\n        }\n        //3.2 使用增强for\n        for(Object object:linkedList) {\n            Student student=(Student) object;\n            System.out.println(student.toString());\n        }\n        //3.3 使用迭代器\n        Iterator iterator =linkedList.iterator();\n        while (iterator.hasNext()) {\n            Student student = (Student) iterator.next();\n            System.out.println(student.toString());\n        }\n        //3.4 使用列表迭代器（略）\n        //4. 判断\n        System.out.println(linkedList.contains(s1));\n        System.out.println(linkedList.isEmpty());\n        System.out.println(linkedList.indexOf(s3));\n    }\n}\n```\n\n\n\n#### 源码分析\n\nLinkedList首先有三个属性：\n\n链表大小：`transient int size = 0;`\n\n（指向）第一个结点/头结点：` transient Node<E> first;`\n\n（指向）最后一个结点/尾结点：`transient Node<E> last;`\n\nNode类型定义\n\n```java\nprivate static class Node<E> {\n    E item;   //当前结点的数据\n    Node<E> next;    //下一个结点\n    Node<E> prev;    //上一个结点\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n\n\n添加元素：\n\n```java\npublic boolean add(E e) {\n    linkLast(e);    //尾插法\n    return true;\n}\n\n\nvoid linkLast(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);   //初始化要添加的新结点\n    last = newNode;\n    if (l == null)     //添加结点前链表为空\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n\n```\n\n\n\n\n\n# 泛型和工具类\n\n## 泛型概述\n\nJava泛型是JDK1.5中引入的一个新特性，其本质是参数化类型，把类型作为参数进行传递\n\n常见形式：泛型类、泛型接口、泛型方法\n\n语法：`<T,...>` T称为占位符，表示一种引用类型。习惯上会使用T、E、K、V等字母作为占位符。\n\n优点：\n\n1. 提高代码的重用性\n2. 防疫类型转换异常，提高代码的安全性\n\n\n\n## 泛型类\n\n```java\n/**\n * 泛型类\n * 语法：类名<T>\n * T是类型占位符，表示一种引用类型，编写多个使用逗号隔开\n * \n */\npublic class myGeneric<T>{\n\t//1.创建泛型变量\n\t//不能使用new来创建，如T t=new T()，因为泛型是不确定的类型，也可能拥有私密的构造方法。\n\tT t;\n\t//2.泛型作为方法的参数\n\tpublic void show(T t) {\n\t\tSystem.out.println(t);\n\t}\n\t//泛型作为方法的返回值\n\tpublic T getT() {\n\t\treturn t;\n\t}\n}\n```\n\n\n\n```java\nimport java.util.*;\nimport java.lang.*;\n\n\npublic class MainTest {\n    public static void main(String[] args) {\n        //使用泛型类创建对象\n        myGeneric<String> myGeneric1=new myGeneric<String>();\n        myGeneric1.t=\"tang\";\n        myGeneric1.show(\"he\");\n\n        myGeneric<Integer> myGeneric2=new myGeneric<Integer>();\n        myGeneric2.t=10;\n        myGeneric2.show(20);\n        Integer integer=myGeneric2.getT();\n\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/987e63f6d4674049bfdfd52425abccea.png#pic_center)\n\n\n\n\n\n\n\n## 泛型接口\n\n### 实现接口时确定泛型类\n\n```java\n/**\n * 泛型接口\n * 语法：接口名<T>\n * 注意：不能创建泛型静态常量\n */\npublic interface MyInterface<T> {\n    //创建常量\n\tString nameString=\"tang\";\n    \n\tT server(T t);\n}\n\n\n\n/**\n * 实现接口时确定泛型类\n */\npublic class MyInterfaceImpl implements MyInterface<String>{\n\t@Override\n\tpublic String server(String t) {\n\t\tSystem.out.println(t);\n\t\treturn t; \n\t}\n}\n\n```\n\n测试\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        MyInterfaceImpl myInterfaceImpl=new MyInterfaceImpl();\n        myInterfaceImpl.server(\"xxx\");\n    }\n}\n```\n\n\n\n### 实现接口时不确定泛型类\n\n```java\n/**\n * 实现接口时不确定泛型类\n */\npublic class MyInterfaceImpl2<T> implements MyInterface<T>{\n\t@Override\n\tpublic T server(T t) {\n\t\tSystem.out.println(t);\n\t\treturn t;\n\t}\n}\n\npublic class MainTest {\n    public static void main(String[] args) {\n        MyInterfaceImpl myInterfaceImpl=new MyInterfaceImpl();\n        myInterfaceImpl.server(\"xxx\");\n    }\n}\n```\n\n\n\n## 泛型方法\n\n\n\n```java\n/**\n * 泛型方法\n * 语法：<T> 返回类型\n */\npublic class MyGenericMethod {\n\tpublic <T> void show(T t) {\n\t\tSystem.out.println(\"泛型方法\"+t);\n\t}\n}\n\n```\n\n测试\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        MyGenericMethod myGenericMethod=new MyGenericMethod();\n        myGenericMethod.show(\"bbbbb\");\n        myGenericMethod.show(123);\n        myGenericMethod.show(3.14159);\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1e3e8b439b5249dc9cc1f85a1d7133d6.png#pic_center)\n\n\n\n## 泛型集合\n\n定义：参数化类型、类型安全的集合，强制集合元素的类型必须一致\n\n特点：\n\n1. 编译时即可检查，而非运行时抛出异常\n2. 访问时，不必类型转换(即拆箱)\n3. 不同泛型之间的引用不能相互赋值。泛型不存在多态\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        LinkedList<String>list=new LinkedList<String>();\n        list.add(\"aaa\");\n        list.add(\"bbb\");\n        list.add(\"ccc\");\n        //list.add(3); 会直接报错\n        System.out.println(list.toString());\n    }\n}\n```\n\n\n\n相关声明\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable{...}\n```\n\n假如使用泛型集合时不声明相关泛型参数，即`new LinkedList<>();`，会默认传递Object类型。\n\n\n\n\n\n# Set接口与实现类\n\n## Set接口\n\n特点：无序、无下标、元素不可重复\n\n方法：全部继承自Collection中的方法\n\n\n\n```java\n/**\n * 测试Set接口的使用\n * 特点：1.无序，没有下标；2.重复\n * 1.添加数据\n * 2.删除数据\n * 3.遍历\n * 4.判断\n */\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tSet<String> set=new HashSet<String>();\n\t\t//1.添加数据\n\t\tset.add(\"tang\");\n\t\tset.add(\"he\");\n\t\tset.add(\"yu\");\n\t\tSystem.out.println(\"数据个数：\"+set.size());\n\t\tSystem.out.println(set.toString());//无序输出\n\t\t//2.删除数据\n\t\tset.remove(\"tang\");\n        System.out.println(set.toString());\n\n\t\t//3.1 使用增强for\n\t\tfor (String string : set) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t\t//3.2 使用迭代器\n\t\tIterator<String> iterator=set.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t}\n        \n\t\t//4.判断\n\t\tSystem.out.println(set.contains(\"tang\"));\n\t\tSystem.out.println(set.isEmpty());\n\t}\n}\n\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cf780f71a32c467a9415f30b17978e8e.png#pic_center)\n\n\n\n## Set实现类\n\n### HashSet\n\n基于HashCode计算元素存放位置\n\n当存入元素的hashcode相同时，会调用equals进行确认，若结果为true，则拒绝存储\n\n#### 测试\n\n```java\n/**\n * Person类\n */\npublic class Person {\n\tprivate String name;\n\tprivate int age;\n\tpublic Person(String name,int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Peerson [name=\" + name + \", age=\" + age + \"]\";\n\t}\n}\n```\n\n\n\n\n\n```java\n/**\n * HashSet集合的使用\n * 存储结构：哈希表（数组+链表+红黑树）\n * 1.添加元素\n * 2.删除元素\n * 3.遍历\n * 4.判断\n*/\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tHashSet<Person> hashSet=new HashSet<>();\n\t\tPerson p1=new Person(\"tang\",21);\n\t\tPerson p2=new Person(\"he\", 22);\n\t\tPerson p3=new Person(\"yu\", 21);\n\t\t//1.添加元素\n\t\thashSet.add(p1);\n\t\thashSet.add(p2);\n\t\thashSet.add(p3);\n        //重复，添加失败\n        hashSet.add(p3);\n        //直接new一个相同属性的对象，依然会被添加，不难理解。\n        //假如相同属性便认为是同一个对象，怎么修改？\n        hashSet.add(new Person(\"yu\", 21));\n\t\tSystem.out.println(hashSet.toString());\n\t\t//2.删除元素\n\t\thashSet.remove(p2);\n\t\t//3.遍历\n\t\t//3.1 增强for\n\t\tfor (Person person : hashSet) {\n\t\t\tSystem.out.println(person);\n\t\t}\n\t\t//3.2 迭代器\n\t\tIterator<Person> iterator=hashSet.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\t\t\n\t\t}\n\t\t//4.判断\n\t\tSystem.out.println(hashSet.isEmpty());\n        //直接new一个相同属性的对象结果输出是false，不难理解。\n        //注：假如相同属性便认为是同一个对象，该怎么做？\n\t\tSystem.out.println(hashSet.contains(new Person(\"tang\", 21)));\n\t}\n}\n\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b973032b556f4bd29644bf219f7bb3ff.png?x-oss-process=image)\n\n\n\n\n#### 内部哈希表存储过程\n\n1. 根据hashCode计算保存的位置，如果位置为空，则直接保存，否则执行第二步。\n\n2. 执行equals方法，如果方法返回true，则认为是重复，拒绝存储，否则形成<u>链表</u>(当一个位置的链表过长时会改用红黑树存储)。\n\n   \n\n数组+链表的形式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fc2d499c0b1d4fc7a32f85e468d70ef3.png?x-oss-process=image)\n\n\n数组+红黑树的形式\n\n单个哈希地址的结点过多时，为了方便查找，会将同地址结点的存储方式改为红黑树\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d73942a79f97435a8e78669968420f72.png?x-oss-process=image)\n\n\n\n\n要实现一开始所说的两步存储过程，可以重载hashCode和equals代码\n\n```java\n@Override\npublic int hashCode() {\n    final int prime = 31;\n    /*使用31的原因：\n    * 1.31是一个质数，这样的数字在计算时可以尽量减少哈希冲突\n    * 2.可以提高执行效率，31*i=(i<<5)-i,31乘以一个数可以转换成移位操作\n    */\n    int result = 1;\n    result = prime * result + age;\n    result = prime * result + ((name == null) ? 0 : name.hashCode());\n    return result;\n}\n@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    Person other = (Person) obj;\n    if (age != other.age)\n        return false;\n    if (name == null) {\n        if (other.name != null)\n            return false;\n    } else if (!name.equals(other.name))\n        return false;\n    return true;\n}\n\n```\n\n\n\n### TreeSet\n\n- 基于排序顺序实现不重复\n- 实现了SortedSet接口，对集合元素自动排序\n- 元素对象的类型必须实现Comparable接口，指定排序规则\n- 通过CompareTo方法确定是否为重复元素\n\n#### 测试1\n\n```java\npublic class Person implements Comparable<Person>{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\"name='\" + name + '\\'' +\", age=\" + age +'}';\n    }\n\n    //重载conpareTo方法\n    @Override\n    public int compareTo(Person o) {\n        int n1=this.getName().compareTo(o.getName());\n        int n2=this.getAge()-o.getAge();\n        return n1==0?n2:n1;\n    }\n}\n\n```\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        \n        TreeSet<Person> persons=new TreeSet<Person>(new Comparator<Person>() {\n            //自定义排序方式\n            @Override\n            public int compare(Person o1, Person o2) {\n                int n1=o1.getName().compareTo(o2.getName());\n                int n2=o1.getAge()-o2.getAge();\n                return n1==0?n2:n1;\n            }\n        });\n        \n        Person p1=new Person(\"tang\",21);\n        Person p2=new Person(\"he\", 22);\n        Person p3=new Person(\"yu\", 21);\n        persons.add(p1);\n        persons.add(p2);\n        persons.add(p3);\n        for(Person person:persons){\n            System.out.println(person.toString());\n        }\n    }\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1648b581d6734258b62456be4a4d1c09.png#pic_center)\n\n\n### 测试2\n\n```java\n/**\n * 要求：使用TreeSet集合实现字符串按照长度进行排序\n * helloworld tangrui hechengyang wangzixu yuguoming\n * Comparator接口实现定制比较\n */\npublic class Demo6 {\n\tpublic static void main(String[] args) {\n        \n\t\tTreeSet<String> treeSet=new TreeSet<String>(new Comparator<String>() {\n\t\t\t@Override\n\t\t\t//先比较字符串长度\n\t\t\t//再比较字符串\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\tint n1=o1.length()-o2.length();\n\t\t\t\tint n2=o1.compareTo(o2);\n\t\t\t\treturn n1==0?n2:n1;\n\t\t\t}\t\t\t\n\t\t});\n        \n\t\ttreeSet.add(\"helloworld\");\n\t\ttreeSet.add(\"tangrui\");\n\t\ttreeSet.add(\"hechenyang\");\n\t\ttreeSet.add(\"yuguoming\");\n\t\ttreeSet.add(\"wangzixu\");\n\t\tSystem.out.println(treeSet.toString());\n\t}\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f421fd8398254032b4da0cfa7248fb71.png#pic_center)\n\n\n\n\n\n\n# Map接口与实现类\n\n## Map接口\n\n特点：\n\n1. 用于存储任意键值对(Key-Value)。\n2. 键：无序、无下标、不允许重复（唯一）。\n3. 值：无序、无下标、允许重复。\n\n\n\n常见方法：\n\n```java\nV put(K key,V value)   //将对象存入到集合中，关联键值。key重复则覆盖原值。\nObject get(Object key)   //根据键获取相应的值。\nSet<K>     //返回所有的key\nCollection<V> values()   //返回包含所有值的Collection集合。\nSet<Map.Entry<K,V>>   //键值匹配的set集合\n```\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        Map<String,Integer> map=new HashMap<String, Integer>();\n\t\t//1.添加元素\n\t\tmap.put(\"tang\", 21);\n\t\tmap.put(\"he\", 22);\n\t\tmap.put(\"fan\", 23);\n\t\tSystem.out.println(map.toString());\n\t\t//2.删除元素\n\t\tmap.remove(\"he\");\n\t\tSystem.out.println(map.toString());\n\t\t//3.遍历\n\t\t//3.1 使用keySet();\n\t\tfor (String key : map.keySet()) {\n\t\t\tSystem.out.println(key+\" \"+map.get(key));\n\t\t}\n\t\t//3.2 使用entrySet();效率较高\n\t\tfor (Map.Entry<String, Integer> entry : map.entrySet()) {\n\t\t\tSystem.out.println(entry.getKey()+\" \"+entry.getValue());\n\t\t}\n    }\n}\n\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c7ec6256f06040d08cdebd960b694738.png#pic_center)\n\n\n\n\n\n\n## Map实现类\n\n### HashMap\n\nJDK1.2版本，线程不安全，运行效率快；允许用null作为key或是value\n\n#### 测试\n\n```java\n/**\n* Student类\n*/\n  public class Student {\n  \tprivate String name;\n  \tprivate int id;\t\n  \tpublic Student(String name, int id) {\n  \t\tsuper();\n  \t\tthis.name = name;\n  \t\tthis.id = id;\n  \t}\n  \tpublic String getName() {\n  \t\treturn name;\n  \t}\n  \tpublic void setName(String name) {\n  \t\tthis.name = name;\n  \t}\n  \tpublic int getId() {\n  \t\treturn id;\n  \t}\n  \tpublic void setId(int id) {\n  \t\tthis.id = id;\n  \t}\n  \t@Override\n  \tpublic String toString() {\n  \t\treturn \"Student [name=\" + name + \", age=\" + id + \"]\";\n  \t}\n  }\n\n```\n\n\n\n```java\n/**\n   * HashMap的使用\n   * 存储结构：哈希表（数组+链表+红黑树）\n   */\n  public class MainTest {\n  \tpublic static void main(String[] args) {\n  \t\tHashMap<Student, String> hashMap=new HashMap<Student, String>();\n  \t\tStudent s1=new Student(\"tang\", 36);\n  \t\tStudent s2=new Student(\"yu\", 101);\n  \t\tStudent s3=new Student(\"he\", 10);\n  \t\t//1.添加元素\n  \t\thashMap.put(s1, \"成都\");\n  \t\thashMap.put(s2, \"杭州\");\n  \t\thashMap.put(s3, \"郑州\");\n        \n  \t\t//添加失败，但会更新值\n  \t\thashMap.put(s3,\"上海\");\n        \n  \t\t//添加成功，不过两个属性一模一样；\n  \t\t//注：假如相同属性便认为是同一个对象，怎么修改？\n  \t\thashMap.put(new Student(\"he\", 10),\"上海\");\n  \t\tSystem.out.println(hashMap.toString());\n  \t\t//2.删除元素\n  \t\thashMap.remove(s3);\n  \t\tSystem.out.println(hashMap.toString());\n  \t\t//3.遍历\n  \t\t//3.1 使用keySet()遍历\n  \t\tfor (Student key : hashMap.keySet()) {\n  \t\t\tSystem.out.println(key+\" \"+hashMap.get(key));\n  \t\t}\n  \t\t//3.2 使用entrySet()遍历\n  \t\tfor (Map.Entry<Student, String> entry : hashMap.entrySet()) {\n  \t\t\tSystem.out.println(entry.getKey()+\" \"+entry.getValue());\n  \t\t}\n  \t\t//4.判断\n  \t\t//注：同上\n  \t\tSystem.out.println(hashMap.containsKey(new Student(\"he\", 10)));\n  \t\tSystem.out.println(hashMap.containsValue(\"成都\"));\n  \t}\n  }\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6a0213577b164009a8a73239d85aa337.png?x-oss-process=image)\n\n\n和HashSet类似，可以重载hashCode和equals自定义哈希地址运算和处理\n\n```java\n@Override\n  public int hashCode() {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + id;\n      result = prime * result + ((name == null) ? 0 : name.hashCode());\n      return result;\n  }\n  @Override\n  public boolean equals(Object obj) {\n      if (this == obj)\n          return true;\n      if (obj == null)\n          return false;\n      if (getClass() != obj.getClass())\n          return false;\n      Student other = (Student) obj;\n      if (id != other.id)\n          return false;\n      if (name == null) {\n          if (other.name != null)\n              return false;\n      } else if (!name.equals(other.name))\n          return false;\n      return true;\n  }\n```\n\n\n\n#### 源码分析\n\n内部存储过程可以回看HashSet部分，HashSet内部也是用map实现的\n\n\n\n默认初始化容量：`static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 或16`\n\n数组最大容量：`static final int MAXIMUM_CAPACITY = 1 << 30;`\n\n默认加载因子：`static final float DEFAULT_LOAD_FACTOR = 0.75f;`\n\n链表调整为红黑树的链表长度阈值（JDK1.8）：`static final int TREEIFY_THRESHOLD = 8;`\n\n红黑树调整为链表的链表长度阈值（JDK1.8）：`static final int UNTREEIFY_THRESHOLD = 6;`\n\n链表调整为红黑树的数组最小阈值（JDK1.8）：`static final int MIN_TREEIFY_CAPACITY = 64;`\n\nHashMap存储的数组：`transient Node<K,V>[] table;`\n\nHashMap存储的元素个数：`transient int size;`\n\n\n\n> - 默认加载因子是什么？\n>   - 就是判断数组是否扩容的一个因子。假如数组容量为100，如果HashMap的存储元素个数超过了100*0.75=75，那么就会进行扩容。\n> - 链表调整为红黑树的链表长度阈值是什么？\n>   - 假设在数组中下标为3的位置已经存储了数据，当新增数据时通过哈希码得到的存储位置又是3，那么就会在该位置形成一个链表，当链表过长时就会转换成红黑树以提高执行效率，这个阈值就是链表转换成红黑树的最短链表长度；\n> - 红黑树调整为链表的链表长度阈值是什么？\n>   - 当红黑树的元素个数小于该阈值时就会转换成链表。\n> - 链表调整为红黑树的数组最小阈值是什么？\n>   - 并不是只要链表长度大于8就可以转换成红黑树，在前者条件成立的情况下，数组的容量必须大于等于64才会进行转换。\n\nHashMap的数组table存储的就是一个个的<u>Node<K,V>类型</u>，很清晰地看到有一对键值，还有一个指向next的指针:\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n      final K key;\n      V value;\n      Node<K,V> next;\n  }\n```\n\n刚创建HashMap时默认大小为0\n\n```java\npublic HashMap() {\n      this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n  }\n```\n\n\n\n往HashMap中添加元素\n\n```java\npublic V put(K key, V value) {\n      return putVal(hash(key), key, value, false, true);\n  }\n\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                    boolean evict) {\n      Node<K,V>[] tab; Node<K,V> p; int n, i;\n    \n      //判断table是否为空\n      if ((tab = table) == null || (n = tab.length) == 0)\n          n = (tab = resize()).length;  //resize()用于重新设置大小\n    \n      //判断根据hashcode的到的tab中的一个位置是否为空，为空便直接添加元素\n      if ((p = tab[i = (n - 1) & hash]) == null)\n          tab[i] = newNode(hash, key, value, null);\n      else{\n          //......\n      }\n  }\n```\n\n\n\n```java\nfinal Node<K,V>[] resize() {\n      Node<K,V>[] oldTab = table;\n      int oldCap = (oldTab == null) ? 0 : oldTab.length;\n      int oldThr = threshold;   //threshold为阈值\n      if (oldCap > 0){/*......*/};\n      else if (oldThr > 0){/*......*/};\n      else {               // zero initial threshold signifies using defaults\n          newCap = DEFAULT_INITIAL_CAPACITY;\n          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n      } \n      @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n      Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n      table = newTab;\n      return newTab;\n  }\n```\n\n刚创建HashMap时，threshold=0，进入第三个if分支，newCap的值初始化为默认的16。\n接下来创建了一个newCap大小的数组并将其赋给了table，刚创建的HashMap对象就在这里获得了初始容量。\n回到putVal方法执行第二个if。\n当添加的元素超过16*0.75=12时，就会进行扩容\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict){\n      if (++size > threshold)\n          resize();\n  }\n\nfinal Node<K,V>[] resize() {\n      int oldCap = (oldTab == null) ? 0 : oldTab.length;\n      //......\n      int newCap;\n      if (oldCap > 0) {\n          if (oldCap >= MAXIMUM_CAPACITY) {/*略*/}\n          else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                   oldCap >= DEFAULT_INITIAL_CAPACITY){\n              newThr = oldThr << 1; // double threshold\n          }\n      }\n      //......\n  }\n```\n\n#### HashSet源码中的HashMap\n\nHashSet的存储结构就是HashMap\n\n```java\npublic class HashSet<E>\n      extends AbstractSet<E>\n      implements Set<E>, Cloneable, java.io.Serializable\n  {\n      private transient HashMap<E,Object> map;\n      private static final Object PRESENT = new Object();\n      public HashSet() {\n          map = new HashMap<>();\n      }\n  }\n```\n\n```java\npublic boolean add(E e) {\n      return map.put(e, PRESENT)==null;\n  }\n```\n\n可见，HashSet中的add方法调用的就是map的put方法，把元素作为map的key传入。\n\n\n\n#### Hashtable\n\n- JDK1.0版本，线程安全，运行效率慢；不允许null作为key或是value。\n\n- 初始容量11，加载因子0.75。\n\n  这个集合在开发过程中已经不用了，稍微了解即可。\n\n\n\n#### Properties\n\nHashtable的子类，要求key和value都是String。通常用于配置文件的读取。它继承了Hashtable的方法，与流关系密切，此处不详解。\n\n\n\n### TreeMap\n\n#### 测试\n\n```java\n/**\n * Student类\n */\npublic class Student implements Comparable<Student>{\n    private String name;\n    private int id;\n    public Student(String name, int id) {\n        super();\n        this.name = name;\n        this.id = id;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    @Override\n    public String toString() {\n        return \"Student [name=\" + name + \", age=\" + id + \"]\";\n    }\n    \n    @Override\n    public int compareTo(Student o) {\n        int n1 = this.id - o.id;\n        return n1;\n    }\n}\n\n```\n\n\n\n```java\npublic class MainTest {\n    public static void main(String[] args) {\n        TreeMap<Student, Integer> treeMap=new TreeMap<Student, Integer>();\n        Student s1=new Student(\"tang\", 36);\n        Student s2=new Student(\"yu\", 101);\n        Student s3=new Student(\"he\", 10);\n        //1.添加元素\n        treeMap.put(s1, 21);\n        treeMap.put(s2, 22);\n        treeMap.put(s3, 21);\n        //不能直接打印，需要实现Comparable接口，因为红黑树需要比较大小\n        System.out.println(treeMap.toString());\n        //2.删除元素\n        treeMap.remove(new Student(\"he\", 10));\n        System.out.println(treeMap.toString());\n        //3.遍历\n        //3.1 使用keySet()\n        for (Student key : treeMap.keySet()) {\n            System.out.println(key+\" \"+treeMap.get(key));\n        }\n        //3.2 使用entrySet()\n        for (Map.Entry<Student, Integer> entry : treeMap.entrySet()) {\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        //4.判断\n        System.out.println(treeMap.containsKey(s1));\n        System.out.println(treeMap.isEmpty());\n    }\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/551bfa5110ee4dad9cd52b54b0d7c8d6.png?x-oss-process=image)\n\n\n\n#### TreeSet中的TreeMap\n\n类比HashSet和HasMap。TreeSet和TreeMap的关系也类似。\n\n```java\npublic class TreeSet<E> extends AbstractSet<E>\n    implements NavigableSet<E>, Cloneable, java.io.Serializable\n{\n    private transient NavigableMap<E,Object> m;\n    private static final Object PRESENT = new Object();\n    TreeSet(NavigableMap<E,Object> m) {\n        this.m = m;\n    }\n    public TreeSet() {\n        this(new TreeMap<E,Object>());\n    }\n}\n```\n\n```java\npublic boolean add(E e) {\n    return m.put(e, PRESENT)==null;\n}\n```\n\n\n\n\n\n# Collections工具类\n\n内部集成了一些常用的静态方法。可以回想Arrays类的用法\n\n```java\npublic static void reverse(List<?> list)//反转集合中元素的顺序\npublic static void shuffle(List<?> list)//随机重置集合元素的顺序\npublic static void sort(List<T> list)//升序排序（元素类型必须实现Comparable接口）\n```\n\n\n\n\n\n#### 测试\n\n```java\n/**\n * 演示Collections工具类的使用\n *\n */\npublic class MainTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list=new ArrayList<Integer>();\n\t\tlist.add(20);\n\t\tlist.add(10);\n\t\tlist.add(30);\n\t\tlist.add(90);\n\t\tlist.add(70);\n\t\t\n\t\t//sort排序\n\t\tSystem.out.println(list.toString());\n\t\tCollections.sort(list);\n\t\tSystem.out.println(list.toString());\n\t\tSystem.out.println(\"---------\");\n\t\t\n\t\t//binarySearch二分查找\n\t\tint i=Collections.binarySearch(list, 10);\n\t\tSystem.out.println(i);\n\t\t\n\t\t//copy复制\n\t\tList<Integer> list2=new ArrayList<Integer>();\n\t\tfor(int i1=0;i1<5;++i1) {\n\t\t\tlist2.add(0);\n\t\t}\n\t\t//该方法要求目标元素容量大于等于源目标\n\t\tCollections.copy(list2, list);\n\t\tSystem.out.println(list2.toString());\n\t\t\n\t\t//reserve反转\n\t\tCollections.reverse(list2);\n\t\tSystem.out.println(list2.toString());\n\t\t\n\t\t//shuffle 打乱\n\t\tCollections.shuffle(list2);\n\t\tSystem.out.println(list2.toString());\n\t\t\n\t\t//补充：list转成数组\n\t\tInteger[] arr=list.toArray(new Integer[0]);\n\t\tSystem.out.println(arr.length);\n\t\t//补充：数组转成集合 \n\t\tString[] nameStrings= {\"tang\",\"he\",\"yu\"};\n\t\t//受限集合，不能添加和删除\n\t\tList<String> list3=Arrays.asList(nameStrings);\n\t\tSystem.out.println(list3);\n\t\t\n\t\t//注：基本类型转成集合时需要修改为包装类\n\t}\n}\n```\n\n```java\nboolean add(E e) {\n    return m.put(e, PRESENT)==null;\n}\n```\n\n\n\n# Collections工具类\n\n内部集成了一些常用的静态方法。可以回想Arrays类的用法\n\n```java\npublic static void reverse(List<?> list)//反转集合中元素的顺序\npublic static void shuffle(List<?> list)//随机重置集合元素的顺序\npublic static void sort(List<T> list)//升序排序（元素类型必须实现Comparable接口）\n```\n\n\n\n\n\n#### 测试\n\n```java\n/**\n * 演示Collections工具类的使用\n *\n */\npublic class MainTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list=new ArrayList<Integer>();\n\t\tlist.add(20);\n\t\tlist.add(10);\n\t\tlist.add(30);\n\t\tlist.add(90);\n\t\tlist.add(70);\n\t\t\n\t\t//sort排序\n\t\tSystem.out.println(list.toString());\n\t\tCollections.sort(list);\n\t\tSystem.out.println(list.toString());\n\t\tSystem.out.println(\"---------\");\n\t\t\n\t\t//binarySearch二分查找\n\t\tint i=Collections.binarySearch(list, 10);\n\t\tSystem.out.println(i);\n\t\t\n\t\t//copy复制\n\t\tList<Integer> list2=new ArrayList<Integer>();\n\t\tfor(int i1=0;i1<5;++i1) {\n\t\t\tlist2.add(0);\n\t\t}\n\t\t//该方法要求目标元素容量大于等于源目标\n\t\tCollections.copy(list2, list);\n\t\tSystem.out.println(list2.toString());\n\t\t\n\t\t//reserve反转\n\t\tCollections.reverse(list2);\n\t\tSystem.out.println(list2.toString());\n\t\t\n\t\t//shuffle 打乱\n\t\tCollections.shuffle(list2);\n\t\tSystem.out.println(list2.toString());\n\t\t\n\t\t//补充：list转成数组\n\t\tInteger[] arr=list.toArray(new Integer[0]);\n\t\tSystem.out.println(arr.length);\n\t\t//补充：数组转成集合 \n\t\tString[] nameStrings= {\"tang\",\"he\",\"yu\"};\n\t\t//受限集合，不能添加和删除\n\t\tList<String> list3=Arrays.asList(nameStrings);\n\t\tSystem.out.println(list3);\n\t\t\n\t\t//注：基本类型转成集合时需要修改为包装类\n\t}\n}\n```\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5e53edcafa2e4ca2b8882ebc759ea0f1.png?x-oss-process=image)\n\n","categories":[],"tags":["JavaSE"]},{"title":"java 基本语法 (三)：面向对象、异常","url":"/posts/20645/","content":"\n\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/121735812\n\n# java面向对象\n\n以类的方式组织代码，以对象的方式组织(封装)数据\n\n三大特性：封装、继承、多态\n\n## 对象声明\n\n```java\npublic class A {\n    int num=0;\n\t//......\n}\n\npublic class MainTest {\n\n    public static void main(String[] args) {\n        A x=new A();  \n    }\n}\n```\n\nnew为x分配一个内存空间，A()构造一个对象，可以在A类中自定义A的构造器。\n\n若类成员不加private/public关键字，将<u>默认为public</u>(C++中是private)\n\n\n\n## 静态方法\n\n```java\n//类A\npublic class A {\n    public static void staticFunction(){\n        System.out.println(\"This is a static function\");\n    }\n    public void commonFunction(){\n        System.out.println(\"This is a common function\");\n    }\n}\n\n```\n\n```java\n//主类\npublic class MainTest {\n\n    public static void main(String[] args) {\n        A.staticFunction();   //静态方法可以通过类直接调用\n        A x=new A();\n        x.commonFunction();   //非静态方法必须通过实例调用\n    }\n}\n```\n\n静态方法也可以通过实例调用，不过会产生警告\n\n如：Static member 'Mitchell.A.staticFunction()' accessed via instance reference。 IDE会建议只通过类来调用静态方法，可能是考虑到实例会被回收。\n\n## 构造器\n\n```java\n//Student.class\npublic class Student {\n    private String id;\n    private String name;\n    private int age;\n    private int score;\n    \n    public Student(String id,String name,int age,int score){\n        this.id=id;\n        this.name=name;\n        this.age=age;\n        this.score=score;\n        System.out.println(\"学生信息记入成功\");\n    }\n    public String makeString(){\n        return \"[ \"+name+\",学号:\"+id+\",年龄:\"+age+\",成绩:\"+score+\" ]\";\n    }\n}\n```\n\n```java\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        Student a=new Student(\"123456789\",\"张三\",19,90);\n        System.out.println(a.makeString());\n    }\n}\n\n```\n\nIDEA中通过<u>alt+insert键</u>可以快速生成构造器以及其他常用方法。\n\n与C++的相同之处：\n\n1. 如果在已经定义了带参构造器的情况下还想调用无参构造器，则必须在类中写出无参构造器的实现。\n\n与C++的不同之处：\n\n1. java不用手动管理内存(有垃圾回收机制)，不用像C++一样写出析构函数(以及使用delete关键字)。\n2. java构造器中，若成员变量和使用的参数命名冲突，则必须调用this来获取成员变量(如上述Student类中\"this.id=id\")。C++对这种情况不会报错。\n3. 若类成员不加private/public关键字，java将默认为public，C++则默认为private。\n\n### 堆栈调用图解\n\n方法区属于堆\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c64800e5dfd64e0390acf9434eab78e4.png?x-oss-process=image)\n\n## 封装\n\n目的：高内聚，低耦合。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合指仅暴露少量的方法给外部使用。\n\n与C++一样，私有成员若要通过对象操作，需要额外定义一些方法。\n\nIDEA使用alt+insert中的getter和setter选项可以直接生成对特定私有成员变量的最简操作方法。\n\n## 继承\n\njava中只有单继承。（C++允许多继承）\n\njava中所有类都默认继承Object类，所以即使是一个空的类也会内含一些从Object继承过来的方法。\n\njava通过extends关键字表示继承。IDEA中通过ctrl+H可以打开继承树。\n\n### super\n\n|                | this               | super                                                      |\n| -------------- | ------------------ | ---------------------------------------------------------- |\n| 代表的对象不同 | 当前类的引用       | 当前类的父类的引用                                         |\n| 前提           | 没有继承也可以使用 | 必须有继承条件才能使用(一般都能用，因为都会继承自Object类) |\n| 构造方法       | this()本类的构造   | super()父类的构造                                          |\n\n例：\n\n```java\n//Person.java    父类\npackage Mitchell;\n\npublic class Person {\n    public String name=\"UNKNOW\";\n    public int age=-1;\n\n    public Person(){\n    }\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n```java\n//Student    子类\npackage Mitchell;\n\npublic class Student extends Person{\n    public Student(){\n        super();    //调用父类的无参构造方法\n    }\n    public Student(String name) {\n        this.name=name;\n    }\n    public Student(int age){\n        this.age=age;\n    }\n    /*public Student(String name, int age) {   //这个方法与下一个方法效果相同\n        super(name, age);\n    }*/\n    public Student(String name,int age){\n        this(name);   //调用当前类的第二个方法\n        this.age=age;    \n        //this(age);   \n        //this()只能调用一次，因为它必须放在第一句，如果用了两个或两种this()，会报错\n    }\n}\n```\n\n```java\n//测试\npackage Mitchell;\nimport java.util.*;\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        Student x=new Student(\"张三\",18);\n        System.out.println(\"[\"+x.name+\",\"+x.age+\"]\");\n    }\n}\n//输出  [张三,18]\n```\n\n注：\n\n1. super调用父类的构造方法，必须放在构造方法中的第一句。\n2. super必须只出现在子类的方法或构造方法中。\n3. super和this不能同时用在同一个构造方法中。\n\n可参考博客：https://blog.csdn.net/lncsdn_123/article/details/79025525\n\n### 方法重写\n\n重写原因：父类的功能，子类不一定需要，或不一定适合子类使用。\n\n@Override   表示重写，是一个有功能的注释。IDEA中可以通过alt+insert-->override进行方法重载。\n\n例：\n\n```java\n//B.java   父类\npublic class B{\n    public void test(){\n        System.out.println(\"B-->test()\");\n    }\n}\n```\n\n```java\n//A.java   子类\npublic class A extends B{\n    \n    @Override\n    public void test(){\n        System.out.println(\"A-->test()\");\n    }\n}\n```\n\n```java\n//测试\npublic class MainTest{\n    \n    public static void main(String[] args){\n        A a=new A();\n        a.test();   //调用A的test()\n        \n        B b=new A();   //父类的引用指向了子类\n        b.test();    //本来会调用B的test，但是当前的b指向的是类A创建的对象，且test()方法被类A重载了。\n    }\n}\n\n//两个test都输出  \"A-->test()\"\n```\n\n\n\n重写方法注意：\n\n1. 方法名、参数列表必须完全相同。\n2. 修饰符：重载后范围可以扩大，但是不能缩小。  (范围：public>protected>default>private)\n3. 抛出的异常：重载后的异常范围可以缩小，但是不能扩大。如ClassNotFoundException<Exception\n\n\n\n## 多态\n\n同一方法可以根据发送对象的不同而采用多种不同的行为方式。\n\n多态存在的条件：\n\n1. 有继承关系。\n2. 子类重写父类的方法。\n3. 父类引用指向子类的对象。\n\n一个类的实例是确定的，但是指向这个实例的对象不是确定的。\n假设Student继承了Person，则可以如下声明对象\n\n```java\nStudent s1=new Student();\nPerson s2=new Student();  //父类指向直接子类\nObject s3=new Student();  //父类指向间接子类\n\n//一个对象能使用哪些方法跟\"=\"号左边的类型有关。\n//如果同一个方法子类有重载，就会调用子类的方法，否则调用\"=\"号左边类的相关方法。\n```\n\n父类不能直接调用子类独有的方法。\n\n假设Student有一个方法 a()，而其父类Person没有。若父类对象要调用a()，可以如下表示\n\n```java\n((Student)s2).a();   //把父类对象强制转换成子类对象\n```\n\n上述方式的强制转换只是临时的，如果接下来还想调用方法a()的话仍然要按上述方式。\n当然还可以新建一个对象(假设为x)存储强制转换后的s2对象，这样x可以直接调用a()。\n\n类型转换异常：ClassCastException。\n\n带static、final、private关键字的方法不能被重写。\n\n注：\n\n1. 父类引用可以指向子类的对象。\n2. 子类对象转换为父类对象为向上转型，可以自动执行，不过可能会丢失一些子类中的方法。\n3. 父类对象转换为子类对象为向下转型，需要执行强制转换。\n\n\n\n## static静态代码块\n\n```java\npublic class HelloWorld {\n\n    {\n        System.out.println(\"匿名代码块\");\n    }\n\n    //1.最先执行，且只执行一次\n    static{\n        System.out.println(\"静态代码块\");\n    }\n\n    //\n    public HelloWorld(){\n        System.out.println(\"构造方法\");\n    }\n\n    public static void main(String[] args) {\n        HelloWorld x1=new HelloWorld();\n        System.out.println(\"================\");\n        HelloWorld x2=new HelloWorld();\n    }\n}\n\n//输出：\n//静态代码块\n//匿名代码块\n//构造方法\n//================\n//匿名代码块\n//构造方法\n```\n\n\n\n## 抽象类\n\n声明\n\n```java\npublic abstruct class a{\n\tpublic abstruct void function(); //抽象方法\n}\n```\n\n抽象方法通过继承在非抽象子类中进行具体实现。\n\n注：\n\n1. 抽象类不能构建实例。不过抽象类中可以写构造器。\n2. 抽象类中可以写普通方法。\n3. 抽象方法只能写在抽象类中。\n\n\n\n## 接口\n\n**接口可以多继承**\n\n接口可以算作特殊的抽象类，它的内部<u>只有抽象方法</u>。\n\n声明\n\n```java\npublic interface UserServices{\n\t//抽象方法或其他成员\n}\n```\n\n接口中的抽象方法不用写public abstruct这些关键字。直接写函数定义即可，\n如：void function(int x);\n接口默认为抽象方式\n\n接口中也可以定义常量，一般用public static final修饰，不过用处不大。\n\n\n\n接口通过关键字implement实现。\n\n```java\npublic class UserServiceimp implements Uservices{  //可以同时实现多个接口\n\t//......\n}\n```\n\n\n\n## 内部类\n\n更详细内容可参考博客：[https://www.cnblogs.com/dolphin0520/p/3811445.html](https://www.cnblogs.com/dolphin0520/p/3811445.html)\n\n### 成员内部类\n\n```java\npublic class Test {\n    public static void main(String[] args)  {\n        //第一种方式：\n        Outter outter = new Outter();\n        Outter.Inner inner = outter.new Inner();   //必须通过Outter对象来创建\n\n        //第二种方式：\n        Outter.Inner inner1 = outter.getInnerInstance();\n    }\n}\n\nclass Outter {    //外部类\n    private Inner inner = null;\n    private int x=10;\n    public Outter() {\n\n    }\n\n    public Inner getInnerInstance() {\n        if(inner == null)\n            inner = new Inner();\n        return inner;\n    }\n\n    class Inner {   //内部类,可以访问外部类的private类型成员\n        private int b=-1;     //内部类的private只能通过外部类访问，若为public则其他地方都可以直接访问\n        public Inner() {\n            \n        }\n    }\n}\n```\n\n成员内部类可以无条件访问外部类的所有成员属性和成员方法(包括private成员和静态成员)。\n\n### 局部内部类\n\n```java\nclass People{\n    public People() {\n         \n    }\n}\n \nclass Man{\n    public Man(){\n         \n    }\n     \n    public People getWoman(){\n        class Woman extends People{   //局部内部类，当前的类只能访问getWoman()作用域内的资源\n            int age =0;\n        }\n        return new Woman();\n    }\n}\n```\n\n局部内部类的访问仅限于方法内或者该作用域内。\n\n局部内部类不能加private等关键字修饰它的成员。\n\n\n\n### 匿名内部类\n\n这种类不需要提供类名就能直接实例化。而且只能用new来声明匿名内部类的定义\n\n```java\nclass PA {\n   public void display() {\n      System.out.println(\"在 A 类内部\");\n   }\n}\n\nclass Demo {\n   public void createClass() {\n\n      // 创建的匿名类继承了 A 类\n      A p1 = new A() {     //匿名内部类的声明\n         public void display() {\n            System.out.println(\"在匿名类内部\");\n         }\n      };\n      p1.display();\n   }\n}\n\nclass Main {\n   public static void main(String[] args) {\n       Demo an = new Demo();\n       an.createClass();\n   }\n}\n```\n\n匿名内部类不能是抽象类。\n\n匿名内部类不能定义构造器。由于匿名内部类<u>没有类名</u>，所以无法定义构造器，但匿名内部类可以初始化块，可以通过初始化块来完成构造器需要完成的工作。\n\n\n\n### 静态内部类\n\n```java\npublic class Test {\n    public static void main(String[] args)  {\n        Outter.Inner inner = new Outter.Inner();\n    }\n}\n \nclass Outter {\n    int a=10;\n    static int b=5;\n    public Outter() {\n         \n    }\n     \n    static class Inner {  //静态内部类\n        public Inner() {\n             System.out.println(b);  //可以访问外部类的static成员，非static成员(如a)不可访问\n            //外部类的非static成员必须依附于具体的对象\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n# 异常\n\n## 异常的分类\n\n1. 检查性异常：用户的错误(或问题)而导致的异常，程序员无法预见这类异常。比如要打开一个不存在的文件时，会触发相关异常。\n2. 运行时异常：可能被程序员发现并避免。\n3. 错误(ERROR)：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略、例如，当栈溢出时，一个错误就发生了，他们在编译时也检查不到。\n\n## 相关类\n\nJava把异常当作对象来处理，并定义了一个积累java.lang.Throwable作为所有异常的超类。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/97890842bac5426b957acbd1e34fbb6e.png?x-oss-process=image)\n\n\n## Error\n\nError类对象由JVM生成并抛出，大多数错误与代码编写者所执行的操作无关。\n\nJVM运行错误(Virtual MachineErroe)，当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError错误。这类错误发生时，JVM一般会选择终止线程。\n\n还有发生在虚拟机试图执行应用时，如类定义错误(NoClassDefFoundError)、连接错误(LinkageError)，这些错误不可查，因为他们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。\n\n## Exception\n\n常见的运行时异常(RuntimeException)\n\n| 异常名                        | 含义         |\n| ----------------------------- | ------------ |\n| ArrayIndexOutOfBoundException | 数组下标越界 |\n| NullPointerException          | 空指针异常   |\n| ArithmeticException           | 算数异常     |\n| MissingResourceException      | 丢失资源     |\n| ClassNotFoundException        | 找不到类     |\n\n## 捕获和抛出异常\n\n相关关键字：try、catch、finally、throw、throws\n\n### try、catch、finally\n\n例：\n\n```java\npublic class demo{\n    public static void main(){\n        int a=1;\n        int b=0;\n        \n        try{ //监控可能会出现异常的区域\n            System.out.println(a/b);    // 1/0会出现ArithmeticException异常，后两句会直接跳过进入catch\n            a++;\n            b++;\n        }\n        catch(ArithmeticException e){   //若捕获到相关异常，就执行catch中的语句\n            System.out.println(\"程序出现异常，b不能为0\");\n        }\n        finally{   //finally中的语句一定会执行\n            System.out.println(\"finally\");\n        }\n    }\n}\n```\n\n上述代码中，ArithmeticException是Exception的子类，如果catch中定义的是Throwable或Exception对象，则所有异常都可以捕获。异常捕获结束之后程序仍旧会运行。\n\ncatch可以写多个，如下\n\n```java\ntry{\n\t//......\n}\ncatch(...){\n\t//......\n}\ncatch(...){\n\t//......\n}\n..\nfinally{\n\t//......\n}\n```\n\n不过catch中的异常范围必须逐步增大，比如第一个catch()中写了Exception对象，那么第二个catch()中就不能写ArithmeticException等类似的异常对象，因为他们是Exception的子类，范围更小。\n\nIDEA中可以通过ctrl+alt+T快速创建if-else、try-catch等结构语句。\n\n### throw、throws\n\nthrow可以主动抛出异常，这里的异常是一个实例\n\n```java\nint a=1,b=0;\n\nif(b==0) throw new ArithmeticException(); //使用throw会提前报错结束线程\n\nSystem.out.println(a/b);\n```\n\n\n\nthrows用在方法中。主要是声明这个方法会抛出相关类型的异常，使它的调用者知道要捕获这个异常。throws不会像throw一样直接输出错误信息。\n\n```java\nimport java.util.*;\n\npublic class MainTest {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int a,b;\n        while(in.hasNext()) {\n            a = in.nextInt();\n            b = in.nextInt();\n            System.out.println(MainTest.test(a, b));\n        }\n        in.close();\n    }\n\n    public static int test(int a,int b) throws ArithmeticException{\n        if(b==0){\n            throw new ArithmeticException();\n        }\n        return a/b;\n    }\n}\n```\n\n效果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fb9c5a6ee282487bbd5dd9b949d2cec3.png?x-oss-process=image)\n\n## 自定义异常\n\n写一个类来继承Exception类即自定义异常\n\n```java\npublic class MyException extends Exception{\n    private int detail;\n\n    public MyException(int a){\n        this.detail=a;\n    }\n\n    @Override\n    public String toString(){\n        return \"MyException[\"+\" detail=\"+detail+\" ]\";\n    }\n}\n\n```\n\n```java\nimport java.util.*;\n\npublic class MainTest {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int a;\n        while(in.hasNext()) {\n            a = in.nextInt();\n            try{\n                test(a);\n            }catch (MyException e){\n                System.out.println(\"MyException-->\"+e);\n            }\n        }\n        in.close();\n    }\n\n    public static void test(int a) throws MyException{\n        System.out.println(\"传入的参数为\"+a);\n        if(a>10){\n            throw new MyException(a);\n        }\n        System.out.println(\"OK\");\n    }\n}\n```\n\n效果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d93095777e034a90830b6278a03e46be.png?x-oss-process=image)\n\n\n## 注\n\n- 处理运行时异常时，采用逻辑去合理规避的同时，辅助try-catch处理\n- 在多重catch快后面，可以加一个catch(Exception)来处理可能会被遗漏的异常\n- 对于不确定的代码，也可以加上try-catch，处理潜在的异常\n- 尽量去处理异常，切忌只是简单地调用printStackTrace()去打印输出\n- 具体如何处理异常，要更具不同的业务需求和异常类型去决定\n- 尽量添加finally语句块去释放占用的资源\n","categories":[],"tags":["JavaSE"]},{"title":"java 基本语法 (二)","url":"/posts/54575/","content":"\n\n# java过程控制\n\n\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/121721051\n\n\n\n## Scanner对象\n\n### 一般输入\n\n```java\nimport java.util.Scanner;\n```\n\nScanner类可以用来获取用户输入\n\n```java\nScanner  in=new Scanner(System.in)\n```\n\n```java\npublic static void main(String[] args) {\n        Scanner scanner=new Scanner(System.in);\n    \n        System.out.println(\"使用next方式接收\");\n        String str=scanner.nextLine();   //也可以使用next()\n        System.out.println(\"输出的内容为\"+str);\n\n        scanner.close();\n    }\n```\n\nnext():\n\n1. 一定要读取到有效字符后才可以结束输入\n2. 对输入有效字符之前遇到的空包，next()方法会自动将其去掉\n3. 只有输入有效字符后才会把其后面输入的空白符作为分隔符或者结束符\n4. **next()不能获取带空格的字符串**\n\nnextLine():\n\n1. 以Enter作为结束符，返回的是输入回车之前的所有字符\n2. **可以获取带空格的字符串**\n\n例如：同样输入\"hello world\"。next()返回\"hello\"，nextLine()返回\"hello world\"\n\n可参考博客：https://blog.csdn.net/gao_zhennan/article/details/80562548?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.opensearchhbase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.opensearchhbase\n\n个人感觉方法名里的\"next\"是当前指针所指的位置，而不是这个指针的下一个位置。\n\n\n\n### 带判断的输入\n\n```java\npublic static void main(String[] args) {\n        Scanner scanner=new Scanner(System.in);\n\n        int i=0;\n        float f=0.0f;\n        System.out.println(\"请输入一个数：\");\n\n        if(scanner.hasNextInt()){\n            i= scanner.nextInt();\n            System.out.println(\"整数数据：\"+i);\n        }\n        else System.out.println(\"输入的不是一个整数\");\n\n        //假如上一个输入不是整数，那么i不会被赋值，scanner中的内容不会被取出，会留到接下来的分支中\n        System.out.println(\"请输入一个小数：\");\n        if(scanner.hasNextFloat()) {\n            f= scanner.nextFloat();\n            System.out.println(\"小数数据：\"+f);\n        }\n        else System.out.println(\"输入的不是一个小数\");\n        scanner.close();\n    }\n```\n\n- hasNext（） 是检测 还有没有**下一个**输入，没有则会等待输入\n- next（）是指针移动到当前下标，并**取出下一个**输入\n- nextLine（） 把指针移动到**下一行** 让然后**取出当前这一行**的输入\n- hasNextLine（） 是检测**下一行**有没有输入，没有则会等待输入\n\nhasNextInt()等方法与上述方法类似。\n\n## 顺序、循环、分支\n\n大部分和C++无区别\n\n值得注意的是 对于while语句，C++可以这样写\n\n```cpp\nint m=10;\nwhile(m--){\n    //statements\n}//C++会默认把m的值转成bool类型，m==0返回true\n```\n\n但是java中不能这样写，必须严格返回一个boolean值。\n\n同样，C++中可以用while(1)表示死循环，java必须用while(true)。\n\n\n\njava的switch用法跟C++相同，不过java的switch中的<u>case可以判断String类型</u>\n\n\n\njava的for还有另一种用法（C++其实也有）\n\n```java\nint[] nums={1,2,3,4,5};\nfor(int x:nums){\n\t//statements\n}\n```\n\n\n\n# java方法\n\n方法即函数。定义、用法和C++大体相同。\n\n| 参数传递 | 方式                         |\n| -------- | ---------------------------- |\n| 值传递   | 传入函数的参数是一个备份     |\n| 引用传递 | 传入函数的参数是一个引用地址 |\n\n关于参数传递更详细的解释可以参考https://www.zhihu.com/question/385114001\n\n## 重载\n\n重载规则：\n\n1. 方法名相同\n2. 参数列表必须不同(个数不同、或类型不同、或参数排列顺序不同等)\n3. 不区分返回类型\n\n方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去诸葛匹配，以选择对应的方法，如果匹配失败，则编译器报错。\n\n## 可变参数\n\n又称不定项参数，目的是使一个函数可以灵活处理不确定数量的参数。\n\n函数声明时，在指定参数类型后加一个省略号(...)\n\n```java\npublic static void printMax(double... numbers)\n    \n//numbers使用时可以当成数组用，可以通过numbers.length获取参数的数量\n```\n\n<u>一个函数中只能指定一个可变参数，它必须是函数的最后一个参数</u>。任何普通的参数必须在它之前声明。\n\n# 数组\n\n##  声明\n\n### 一维数组\n\n以下两种声明方式等价\n\n```java\nint[] a;\nint a[];\n```\n\n使用new操作符创建数组\n\n```java\ndataType[] arrayRefvar=new dataType[arrRefvar];\n    \nint[] a=new int[10];  //定长声明\n```\n\n静态初始化\n\n```java\nint[] a={1,2,3,4,5};\nAnimal x={new Animal(),new Animal};\n```\n\n动态初始化\n\n```java\nint[] b=new int[10];  //b的元素会有默认值\n```\n\n\n\n### 1.2.多维数组\n\n```java\nint[][] a=new int[r][c];  //int[行数][列数]\n\nint[][] array={{1,2},{2,3},{3,4},{4,5}};\n```\n\n\n\n## java内存初步\n\n堆：\n\n1. 存放new的对象和数组\n2. 可以被所有的线程共享，不会被别的对象引用\n\n栈：\n\n1. 存放基本变量类型(会包含这个基本类型的具体数值)\n2. 引用对象的变量(会存放这个引用在堆里面的<u>具体地址</u>)\n\n方法区：\n\n1. 可以被所有的线程共享\n2. 包含了所有的class和static变量\n\n## 传参\n\n```java\npublic int function(int[] array);\n```\n\n## Arrays类\n\njava.util.Arrays\n\n例\n\n```java\npublic static void main(String[] args) {\n        int a[]={1,2,3,4,5};\n        System.out.println(Arrays.toString(a));\n}\n```\n\n输出如下\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad3becde0c2948f2bef339934b5b9259.png#pic_center)\n\n\n```java\npublic static void main(String[] args) {\n        int a[]={5,2,9,4,5};\n    \tArrays.sort(a);    //升序排序\n        System.out.println(Arrays.toString(a));\n}\n```\n\n\n\n\n\n更多具体方法见官方文档，也可以直接进入Arrays类查看具体实现\n\n## 稀疏数组(数组练习)\n\n如果一个大型数组中0元素过多，称之为稀疏数组，此时没有必要存储它的所有制，只用存储非0值的相关信息即可。\n\n```java\npublic static void main(String[] args) {\n        //创建二维数组11*11    0：没有棋子   1：黑子   2：白子\n        int[][] array1=new int[11][11];\n        array1[1][2]=1;\n        array1[2][3]=1;\n        //输出原始的数组\n        System.out.println(\"输出原始的数组\");\n        for(int i=0;i<11;i++){\n            for(int j=0;j<11;j++){\n                System.out.print(array1[i][j]+\" \");\n            }\n            System.out.println();\n        }\n\n        //转换为稀疏数组\n        //获取有效值的个数\n        int sum=0;\n        for(int i=0;i<11;i++){\n            for(int j=0;j<11;j++){\n                if(array1[i][j]!=0) sum++;\n            }\n        }\n\n        //创建一个稀疏数组的数组\n        /*\n        * array[0][0]存储行数，array[0][1]存储列数，array[0][2]存储非0元素的个数，\n        * 另外，对于array2除了第0行的每一行array2[i]\n        * array[i][0]存储非0元素所在的行\n        * array[i][1]存储非0元素所在的列\n        * array[i][2]存储非0元素的值\n        */\n        int[][] array2=new int[sum+1][3];\n        array2[0][0]=array2[0][1]=11;\n        array2[0][2]=sum;\n\n        int count=0;\n\n        for(int i=0;i<array1.length;i++){\n            for(int j=0;j<array1.length;j++){\n                if(array1[i][j]!=0){\n                    count++;\n                    array2[count][0]=i;\n                    array2[count][1]=j;\n                    array2[count][2]=array1[i][j];\n                }\n            }\n        }\n\n        //输出稀疏数组\n        System.out.println(\"输出稀疏数组\");\n        for(int i=0;i<array2.length;i++){\n            System.out.println(Arrays.toString(array2[i]));\n        }\n        //=========================//\n        System.out.println(\"================================\");\n        System.out.println(\"还原\");\n        //1.读取稀疏数组\n        int[][] array3=new int[array2[0][0]][array2[0][1]];\n\n        //2.还原值\n        for(int i=1;i<array2.length;i++){\n            array3[array2[i][0]][array2[i][1]]=array2[i][2];\n        }\n\n        System.out.println(\"输出还原的数组\");\n        for(int i=0;i<11;i++){\n            System.out.println(Arrays.toString(array3[i]));\n        }\n    }\n```\n\n输出如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/03b1a3a253fa4b399b67a00605e8d820.png?x-oss-process=image)\n\n","categories":[],"tags":["JavaSE"]},{"title":"java 语法基础 (一)","url":"/posts/1098/","content":"\n\n# 语法基础\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/121714143\n\n注：主要记录Java有而C++没有的特点\n\n## 注释\n\n单行多行跟C++无区别\n\n文档注释：\n\n```java\n/**\n*@(注释标题1) 具体内容\n*@(注释标题2) 具体内容\n*/\n```\n\n## 关键字\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91a5ce9c75554b4daf5ac4a36caedb49.png?x-oss-process=image)\n\n\njava可以用中文命名标识符\n\n## 数据类型\n\n跟C++一样，java也是强类型语言\n\n### 基本类型\n\n| 整数类型 | 含义                                                         |\n| -------- | ------------------------------------------------------------ |\n| byte     | 占1个字节：-128~127                                          |\n| short    | 占2个字节：-32768~32767                                      |\n| int      | 占4个字节：-2147483648~2147483647                            |\n| long     | 占8个字                   节： -9223372036854775808~9223372036854775807 |\n\n没有long long类型\n\n```java\nint n1=10;\nlong n2=10L;    //加个L来标定10是long类型，否则报错\n\nint i1=10;   //十进制\nint i2=010;  //八进制0\nint i3=0x10; //十六进制0x\n\nint x=10_00_00    //打印x时下划线不会被输出。这种方法主要是为了更清楚地看一个大数字\n```\n\n\n\n| 浮点类型 | 含义      |\n| -------- | --------- |\n| float    | 占4个字节 |\n| double   | 占8个字节 |\n\n```java\nlong f1=1.1F;     //加个F来标定1.1是float类型，否则报错\ndouble f2=1.1;\n```\n\n| 字符类型 | 含义                                       |\n| :------- | ------------------------------------------ |\n| char     | 占<u>2个</u>字节, Unicode编码(U0000~UFFFF) |\n\n| 布尔类型            | 含义                          |\n| ------------------- | ----------------------------- |\n| boolean（不是bool） | 占一位。只有true、false两个值 |\n\n### 3.2引用类型\n\n类、 接口、数组\n\n## 类型转换\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9264299206854bd59b4405d293c46b9d.png#pic_center)\n\n\n```java\n(类型)变量名     //强制转换   高-->低\n\nlong a=1000000000;\nint b=10;\nlong x=a*b;   //x会输出10000000000,b在计算过程中会自动向上转换\n//如果声明的是int a,那么a*b不会产生类型转换，计算结果会溢出，x会获得溢出值\n```\n\n注：1.不能对boolean进行转换。\n\n​\t   2.不能把对象类型转换位不相关的类型。\n\n​\t   3.在把高容量类型（如long）转换到低容量类型（如int）的时候要执行强制转换。反之会执行自动转换。\n\n​\t   4.转换的时候可能存在内存溢出或精度问题。\n\n## 变量\n\n实例变量若不初始化，一般默认值都是类似0，0.0，null，false的形式\n\n类变量：用static修饰\n\n```java\npublic class Demo{\n    static double salary=2500;\n    double age=25;\n    \n    public static void main(String[] args){\n        Demo demo=new Demo();\n        System.out.print(demo.age); //实例变量必须通过对象调用\n        System.out.print(salary);   //类变量不用通过对象调用\n    }\n}\n```\n\n### 常量\n\njava的常量用final修饰\n\n### 变量命名规范\n\n1. 所有变量、方法、类名：见名知意\n2. 类成员变量：首字母小写和驼峰原则：monthSalary  除了第一个单词以外，后面的单词首字母用大写 monthCommonBonus\n3. 局部变量：首字母小写和驼峰原则\n4. 常量：大写字母和下划线：MAX_VALUE\n5. 类名：首字母大写和驼峰原则：Man，LinkList\n6. 方法名：首字母小写和驼峰原则\n\n## 运算符\n\njava多了一个instanceof，其他跟C++一样\n\ninstance的作用是测试它左边的对象是否是它右边的类的实例，返回boolean 的数据类型。\n\n```java\nboolean result = object instanceof class\n```\n\n```java\npublic static void main(String[] args) {\n   Object testObject = new ArrayList();\n      displayObjectClass(testObject);\n   }\n   public static void displayObjectClass(Object o) {\n      if (o instanceof Vector)\n      System.out.println(\"对象是 java.util.Vector 类的实例\");\n      else if (o instanceof ArrayList)\n      System.out.println(\"对象是 java.util.ArrayList 类的实例\");\n      else\n      System.out.println(\"对象是 \" + o.getClass() + \" 类的实例\");\n   }\n}\n//输出为\"对象是 java.util.ArrayList 类的实例\"\n```\n\n对象若是   类(或直接子类、间接子类，也可以说是同一继承树)   的对象   那么instanceof会返回true。\n\nnull用instanceof跟任何类型比较时都是false。\n\n\n\n```java\n//一个特例\nint a=10,b=10;\nSystem.out.print(\"\"+a+b);   //输出20\nSystem.out.print(a+b+\"\");   //输出1010\n//从左往右看来判断\"+\"号是字符串连接还是算数加法\n```\n\n更多数学运算可以调用Math类\n\n## 包机制\n\n### package\n\n类似于C++的namespace。也可以看成文件夹。可以避免命名冲突\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/da979f45f8e74bf594a9045a3abbb69c.png?x-oss-process=image)\n\n\n\n\n```java\npackage  pkg1[.pkg2[.pkg3...]]\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f01377ad9af64a6c8d6ac7efbe2c7c26.png?x-oss-process=image)\n\n\n类a放在目录Mitchell.tools下，因此编写类a的时候必须在开头加上一句\n\n```java\npackage Mitchell.tools;\n```\n\n编辑类HelloWorld，必须在开头加上一句\n\n```java\npackage Mitchell;\n```\n\n### import导包\n\nimport语句必须放在package语句下面\n\n```java\nimport package1[.package2].(classname | *);    //*代表相关包下的所有类\n```\n\n\n\n## JavaDoc\n\n目的:生成自己的API文档\n\n### 基本内容\n\n| 可用参数 | 含义                      |\n| -------- | ------------------------- |\n| @author  | 作者名                    |\n| @version | 版本号                    |\n| @since   | 指明需要最早使用的jdk版本 |\n| @param   | 参数名                    |\n| @return  | 返回值情况                |\n| @throws  | 异常抛出情况              |\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/053c4577177746df9c2efb85dc09ee9a.png?x-oss-process=image)\n按目录方式打开文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/02964bc8cef84f7c818e8488f61dc010.png?x-oss-process=image)当前文件目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c17e27ad5f51432683963c9b454f8783.png#pic_center)\n\n\n\n### 生成文档的方法\n\n#### 方法1 命令行\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/238255d592b94bc583b4db3438e6b268.png?x-oss-process=image)\n\n\n\n\n#### 方法2 idea内置工具\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/eef35196109b4e4882a9949d93de7e02.png?x-oss-process=image)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/28e12e57ed6c4540aafde209df8a6b46.png?x-oss-process=image)\n\n\n\n\n#### 效果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/423e4928e5b14b7f96f986c3207e54b0.png?x-oss-process=image)\n网页效果![在这里插入图片描述](https://img-blog.csdnimg.cn/727873f7c3a34d13a35a014b005d5152.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n","categories":[],"tags":["JavaSE"]},{"title":"初识 Java（一些常识）","url":"/posts/61970/","content":"\n\n# 初识Java（一些常识）\n\n\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/121709598\n\n\n\n三高：高可用、高性能、高并发\n\nJavaSE：标准版（桌面程序，控制台开发.....）\n\nJavaME：嵌入式开发（手机，小家电.....）\n\nJavaEE：E企业级开发（web端，服务器开发）\n\n\n\nJDK：Java Development Kit       开发者工具\n\nJRE:  Java Runtime Environment          运行环境\n\nJVM:  Java Virtual Machine      Java虚拟机，用于屏蔽底层细节，实现可移植性\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0f61419668af4fccb1c8ab847dda948c.png?x-oss-process=image)\n\n\n\n# 开发环境搭建\n\n## 1.下载资源\n\n先去oracle官网下载jdk安装包，下载完后执行即可。同时要记住安装路径，接下来会用于配置环境变量。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e516697aabd54ea896d996582f45c129.png?x-oss-process=image)\n\n\n这里缺少jre文件，可通过博客[https://blog.csdn.net/weixin_45729500/article/details/110509807](https://blog.csdn.net/weixin_45729500/article/details/110509807)解决。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d4fab92462724db1b6fe15fa3f70c8b2.png?x-oss-process=image)\n\n\n## 2.配置环境变量\n\n设置-->搜索“环境”-->编辑系统环境变量\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b9dc267e263e4a9283b987c003b41caa.png?x-oss-process=image)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/021ba7c43de04f1f8648cb111f323aed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## 3.检验\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b10ff75e44864b61987685f3741f84d8.png#pic_center)\n\n\n\n\n# 命令行运行java文件\n\n```bash\ncd.>hello.java\n```\n\n在当前目录下创建java文件\n\n```java\n//hello.java\npublic class hello {\n    public static void main(String[] args) {\n        System.out.println(\"hello world\");\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d3cf59bb8f184b34b2468f5d3825e3b9.png?x-oss-process=image)\n\n\n\n\n# 程序运行机制\n\n1.编译型。 类似于把一本书先完全翻译后再拿来读。\n\n2.解释型。 类似于读原文，读的过程中一句一句翻译。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2fdaa11c26ee4b298b7e1e005c5b54ba.png#pic_center)\n\n","categories":[],"tags":["JavaSE"]},{"title":"常见 Dos 命令","url":"/posts/42218/","content":"\n\n# 常见Dos命令\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/121708336\n\nCMD(Powershell也可)\n\n## 打开方式\n\n1.开始+系统++命令提示符\n\n2.win+R 输入cmd控制台\n\n3.在任意文件夹下面，按住shift+鼠标右键点击\n\n4.资源管理器的地址栏前加上cmd路径\n\n按右键可以选择以管理员方式运行\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0fe8e6b4ca7d42078aac057181699b62.png#pic_center)\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MgtXkgfU-1638541393287)(images/%E4%B8%A4%E4%B8%AA%E6%A8%A1%E5%BC%8F.png)]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3eef496d293847b893c0eaac0d76cecc.png?x-oss-process=image)\n\n\n注：这里用的是windows terminal(微软商城上有)，它可以运行多种命令行界面(前提是已经配置好的)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ab39dc786b064afd929133c33513872f.png?x-oss-process=image)\n\n\n\n\n## 常用命令\n\n下面忽略\"C:\\xxx\\xxx>\"的部分\n\n### 盘符切换\n\n```bash\nF:     //切换至F盘\n```\n\n### 查看当前目录下的所有文件\n\n```bash\ndir\n```\n\n![](https://img-blog.csdnimg.cn/8905e34163c04b38ad672c97f0ab2833.png?x-oss-process=image)\n\n### 切换目录\n\n```bash\ncd 文件路径    \n```\n\n可以是绝对路径，也可以是相对路径。\n\n相对路径中：**./** 代表当前目录，**../**代表当前目录的上一级目录\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fa29b4511cfa4c4a965680ff9dd33562.png#pic_center)\n\n### 清理屏幕\n\n```bash\ncls\n```\n\n### 退出终端\n\n```bash\nexit\n```\n\n### 网络相关\n\n#### 查看电脑的ip\n\n```bash\nipconfig\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4fa768aa41504fbea3a84da6930dc4bc.png?x-oss-process=image)\n\n#### ping命令\n\n```bash\nping  [各种可用参数]  网页地址\n```\n\nping命令可以获取指定网址的ip信息\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/16b28e90a214437c8af54fdf4b68b509.png?x-oss-process=image)\n\n\nping 还有其他可用参数，具体可以通过直接输入ping查看\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef3574b97f1249b0870c77a866070cf1.png?x-oss-process=image)\n\n### 打开应用\n\n```bash\ncalc  \t\t\t\t//计算器\nmspaint\t\t\t\t//画板\nnotepad\t\t\t\t//文本编辑器\n```\n\n### 文件操作\n\n#### md创建目录\n\n注：这个命令只是创建目录(即平时所说的文件夹)而不是 .txt 这类文件。\n\n```bash\nmd  目录名        //make directory\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4e9a5d096f4d484fb3ccff0eaace8d76.png?x-oss-process=image)\n\n#### rd删除目录\n\n```bash\nrd 目录名     //remove directory\n```\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-POkgqQyP-1638541393294)(images/rd%E5%91%BD%E4%BB%A4.png)]\n\n#### 打开文件\n\n```bash\n相对路径或绝对路径+文件名\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/50b6249afc804562b55d221620da3265.png#pic_center)\n\n#### 创建文件\n\n```bash\ncd.> 文件名.文件类型    //文件会创建在当前目录\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/423bcfd5dbd842e6836e05315a3d6774.png#pic_center)\n\n#### 删除文件\n\n```bash\ndel 文件名.文件类型\n```\n\n文件\n\n```bash\ncd.> 文件名.文件类型    //文件会创建在当前目录\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b803eaf5d07e4437b0f1b944f2014e72.png?x-oss-process=image)\n\n#### 删除文件\n\n```bash\ndel 文件名.文件类型\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/54487c4f9b4a4aabaca5714be82ebf6d.png?x-oss-process=image)\n\n","categories":[],"tags":["操作系统"]},{"title":"《C 和指针》阅读笔记","url":"/posts/46293/","content":"\n\n《C和指针》 Kenneth著\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/121294114\n\n\n# 快速上手\n\n预处理指令：\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define MAX_COLS 20\n#define MAX_INPUT 1000\n```\n\n这些指令由预处理器解释，预处理器读入源代码，根据预处理指令对其进行<u>修改</u>，然后把修改过的源代码递交给编译器。\n\n用#define定义的常量一般用大写加以区分，且该变量不能被赋值。\n\n当预处理语句过多时，可以把它们打包到一个自定义头文件中，然后直接引用该头文件即可，这样还能避免由于同一个声明的多份拷贝而导致的维护性问题。\n\n```c\n/*\n*  读取、处理和打印剩余的输入行\n*/\nwhile (gets(input)!=NULL){\n    printf(\"Original input : $s\\n\",input);\n    rearrange(output, input, n_columns,columns);\n    printf(\"Rearranged line: %s\\n\", output);\n}\n```\n\n要多在代码中写进必要的注释，以此来解释清楚什么地方的代码是什么功能，这样过一段时间后别人(或自己)重看一遍这部分代码会很容易理解，更有利于维护。同时，更新代码时也要注意相关注释的更新。\n\n\n\n\n```c\n/*\n* 读取列标号，如果超出规定范围则不予理会\n*/\nint read_column_numbers(int columns[],int max);\n```\n\n\n声明的数组不用附带长度，这种特性允许函数操纵任意长度的一维数组， 缺点就是不能获取数组的长度。\n\n```c\nch=getchar();\nwhile(ch!=EOF && ch!='\\n')   //EOF 本质上是个整数值\n    ch=getchar();\n```\n\n这块代码用于一个个读取字符直至到达文件末尾（或者读到换行符）。\n\n\n\n```c\n/*\n*  处理输入行，将指定列的字符连接在一起，输出行以NULL结尾\n*/\nvoid rearrange(char *output,char const *input,\n              int n_columns,int const columns[])\n```\n\n数组本质上就是指针，因此传入的参数不是数组的备份而是指针，也就是说，在函数内对数组参数的修改会影响函数外部的实际数组。为了避免修改数组，可以将参数声明为 const 。\n\n\n\n## 警告与总结\n\n1.在scanf函数的标量参数前未添加&字符。\n\n2.机械的把printf函数的格式代码照搬于scanf函数。\n\n3.在应该使用&&操作符的地方误用了&操作符。\n\n4.误用=操作符而不是==操作符来测试相等性。\n\n## 编程提示的总结\n\n1.使用#include指令避免重复声明\n\n2.使用#define指令给常量值取名。\n\n3.在#include文件中放置函数原型。\n\n4.在使用下标前先检查它们的值。\n\n5.在while或if表达式中蕴含赋值操作。\n\n6.如何编写一个空循环体。\n\n7.始终要进行检查，去日报数组不越界。\n\n\n\n\n\n\n\n# 基本概念\n\n## 环境\n\n### 翻译环境\n\n翻译阶段，一个(或多个)源文件(Source code)通过编译(Complier)过程分别转换为目标代码(Object code)。然后，这些目标代码由链接器(linker)捆绑在一起，形成一个可执行(executable)程序。\n\n编译过程：\n\n​\t1.预处理器处理。预处理在源代码上执行一些文本操作。如：用实际值代替#define等命令，读入#include包含的文件。\n\n​\t2.解析，判断语句的意思。随后产生目标代码(机器指令的初步形式，用于实现程序的语句)。   如果我们在编译程序的命令行中假如了要求进行优化的选项，优化器(optimizer)可以进一步处理目标代码，使其效率更高(优化过程更耗时间)。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fa5282ca3d5a4ee08e03a2b4a024ded8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n下面以UNIX为例进行编译和链接\n\n```c\n//1、编译并连接一个完全包含于一个源文件的C程序\ncc program.c\n//会产生一个a.cout可执行程序。中间会产生program.o目标文件,不\n//过它在连接过程完成后会被删除。\n\n//2、编译并链接几个C源文件\ncc main.c sort.c lookup.c\n//当编译的源文件超过一个时，目标文件不会被删除\n\n//3、编译一个C源文件，并把它和现存的目标文件链接在一起\ncc main.o lookup.o sort.c\n\n//4、编译单个C源文件，并产生一个目标文件，以后再进行链接\ncc -c program.c\n\n//5、编译几个C源文件，并为每个文件产生一个目标文件\ncc -c main.c sort.c lookup.c\n\n//6、链接几个目标文件\ncc main.o sort.o lookup.o\n```\n\n### 执行环境\n\n执行过程：\n\n​\t1.程序被载入到内存中（由操作系统完成）。哪些不存储在堆栈中的尚未初始化的变量将会初始化。\n\n​\t2.通过一个小型启动程序和目标程序链接在一起。然后调用main函数。\n\n​\t3.程序会使用一个运行时**堆栈**，它用于存储函数的局部变量和返回地址。   同时程序也会使用**静态**内存，其中的变量在整个过程中会一直保留原本的值。\n\n​\t4.程序结束。可以是末尾return 0；正常结束，也可以是中途报错直接结束。\n\n## 词法规则\n\n### 三字母词\n\n通过??x的形式可以转义出其他符号，部分样例如下表\n\n| ??(  | [    |      | ??<  | {    |      | ??=  | #    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| ??)  | ]    |      | ??>  | }    |      | ??/  | \\    |\n| ??!  | \\|   |      | ??'  | ^    |      | ??-  | ~    |\n\n现在转义一般用 ‘ \\ ’。三字母词平时其实非常少见。\n\n# 数据\n\n## 基本数据类型\n\n### 整型\n\n#### 整型字面值\n\n字面值如 1，2，FF这些数值，它们本身不能再改变。\n\n变量的最小范围\n\n| 类型               | 最小范围               |\n| ------------------ | ---------------------- |\n| char               | 0-127                  |\n| signed char        | -127-127               |\n| unsigned char      | 0-255                  |\n| short int          | -32767-32767           |\n| unsigned short int | 0-65535                |\n| int                | -32767-32767           |\n| unsigned int       | 0-65535                |\n| long int           | -2147483647-2147483647 |\n| unsigned long int  | 0-4294967295           |\n\n\n\n头文件limits.h说明了各种不同的整数类型的特点。\n\n如：CHAR_BIT 是字符型的位数，CHAR_MIN、CHAR_MAX定义了缺省字符类型的范围。 MB_LEN_MAX规定了一个多字节字符最多允许的字符数量。\n\n|        | signed    | signed    | unsigned  |\n| ------ | --------- | --------- | --------- |\n| 类型   | 最小值    | 最大值    | 最大值    |\n| 字符   | SCHAR_MIN | SCHAR_MAX | UCHAR_MAX |\n| 短整型 | SHRT_MIN  | SHRT_MAX  | USHRT_MAX |\n| 整型   | INT_MIN   | INT_MAX   | UNIT_MAX  |\n| 长整型 | LONG_MIN  | LONG_MAX  | ULONG_MAX |\n\n事实上，不同的机器中char可能有不同范围的值。\n\n#### 枚举类型(enumerated)\n\n```c\nenum Jar_Type{CUP=8,PINT=16,QUART=32,\n\t\t\tHALF_GALLON=64,GALLON=128};\n```\n\n上例中，Jar_Type被声明为一个枚举类型，CUP、PINT等为符号常量，后续可以直接引用。\n\n假如没有设置CUP、PINT等符号等于什么值，那么默认CUP=0、PINT=1 以此类推。\n\n假如有的符号有设置值，而有的没有，那未设置值的符号，默认比前一个符号大1。\n\n### 浮点类型\n\n头文件float.h 定义了名字FLT_MAX、DBL_MAX和LDBL_MIN，分别表示float、double和long double所能存储的最大值。对应的xxx_MIN存最小值。\n\n### 指针\n\n#### 指针常量\n\n每次调用一个函数时，它的局部变量可能每次分配的内存位置都不一样。\n\n#### 字符串常量\n\n定义：一串以NULL字节结尾的零个或多个字符。存入字符数组中。\n\n## 声明\n\n### 数组声明\n\nC编译器不会检查数组下标是否越界。\n\n如果下标值是从那些已知是正确的值 (比如直接声明a[100]) 计算得来的，就不用检查它的值。如果是其他方法或者用户输入得到的 (比如a[n]，这里的n可以计算得出，也可以用户输入) , 就需要检查它的值防止越界。\n\n### 指针声明\n\n```c\n//声明一个指针\nint *a;\n//声明多个指针\nint *b,*c,*d;\n//字符串\nchar *message=\"Hello world!\";\n//上一句的具体过程\nchar *message;\nmessage=\"Hello world!\";\n```\n\n### 隐式声明\n\n```c\nf(x){\n\treturn x+1;\n}\n//编译器会默认f返回整型\n```\n\n隐式声明建议不用，很容易降低代码可读性。\n\n## typedef\n\ntypedef的目的：为各种数据类型定义新名字。\n\n```c\ntypedef char *ptr_tp_char;\nptr_to_char a;   //等价于char *a;\n```\n\n定义类型名最好用typedef而不是用#define，后者无法正确地处理指针类型。\n\n## 常量\n\n```c\nint const *p;   //等价于int *const p;\n//该指针所指向的内容可以修改，但是不能修改地址。\nconst int *p;\n//该指针可以修改地址，但不能修改所指向的值\nconst int *const p;\n//该指针一初始化就不能修改。\n\n//一般常量声明\n#define MAX_ELEMENTS 50\nint const max_elements=50;\n```\n\n定义一个名字常量的好处在于，后续维护程序时，只用修改声明部分就能修改所有相关的地方。\n\n## 链接属性\n\n连接属性分类：external(外部)、internal(内部)、none(无)\n\n```c\nextern int k;\n//声明为extern的k将是外部文件的一个同名变量\n\nstatic int b;\n//声明为static的b将为当前的源文件私有\n//在其他源文件中，若链接到一个叫做b的变量，那么它引用的将\n//是另一个不同的变量\n\n//对函数也可以如此声明，这样可以防止外部文件的调用。\nstatic int f(int x);\n```\n\n## 存储类型\n\n分类：普通内存、运行时堆栈、硬件寄存器\n\n使用频率高的变量可以声明为寄存器变量(register关键字)。\n\n寄存器变量的创建和销毁时间和局部变量相同，但它需要一些额外工作。在一个使用寄存器变量的函数返回之前，这些寄存器先前存储的值必须恢复，确保调用者的寄存器变量未被破坏。 \n\n当函数开始执行时，它把需要使用的所有寄存器的内容都保存到堆栈中，当函数返回时，这些值再复制回到寄存器中。\n\n某个特定的寄存器在不同的时刻所保持的值不一定相同。因此，机器不会提供寄存器变量的地址。\n\n#### 初始化\n\n静态变量若不显式地初始化，将默认赋值为0。\n\n局部变量若不显式地初始化，将会有更多开销，因为当程序链接时还无法判断局部变量的存储位置。<u>局部变量最好显式初始化</u>。\n\n## static 关键字\n\nstatic有两种用法：\n\n1.用于函数定义、或用于代码块之外的变量声明时，static用于修改标识符的链接属性，从external改为internal，但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明它们的源文件中访问。\n\n2.用于代码块内部的变量声明时，static用于修改变量的存储类型，将局部变量转为静态变量，但是变量的链接属性和作用域不受影响。\n\n\n\n## 小结\n\n| 变量类型 | 声明位置       | 是否存于堆栈 | 作用域           | 如果声明为static                                     |\n| -------- | -------------- | ------------ | ---------------- | ---------------------------------------------------- |\n| 全局     | 所有代码块之外 | F            | 从声明出到文件尾 | 不允许从其他源文件访问                               |\n| 局部     | 代码块起始处   | T            | 整个代码块       | 变量不存储与堆栈中，它们的值在程序整个执行期一直保持 |\n| 形式参数 | 函数头部       | T            | 整个函数         | 不允许                                               |\n\n## 警告的总结\n\n1.在声明指针变量时采用容易误导的写法。\n\n2.误解指针声明中初始化的含义。\n\n\n\n## 编程提示总结\n\n1.为了保持最佳的可移植性，把字符的值限制在有符号和无符号字符范围的交集之内，或者不要在字符上执行算术运算。\n\n2.用它们在使用时最自然的形式来表示字面值。\n\n3.不要把整型值和枚举值混为一谈。\n\n4.不要依赖隐式声明。\n\n5.在定义类型的新名字时，使用typedef而不是#define\n\n6.用const声明其值不会修改的变量。\n\n7.使用名字常量而不是字面值常量。\n\n8.不要再嵌套的代码块之间使用相同的变量名。\n\n9.除了实体的具体定义位置之外，在它的其他声明位置都使用extern关键字。\n\n\n\n# 语句\n\n## 警告的总结\n\n1.编写不会产生任何结果的表达式。\n\n2.确信在if语句中的语句列表前后加上花括号。\n\n3.在switch语句中，执行流意外地从一个case顺延到下一个case。\n\n## 编程提示总结\n\n1.在一个没有循环体的循环中，用一个分号表示空语句，并让它独占一行。\n\n2.for循环的可读性比whlie循环强，因为它把用于控制循环的表达式收集起来放在同一处。\n\n3.switch语句中必要时使用default子句。\n\n# 操作符和表达式\n\n# 操作符\n\n### 5.1.1算术操作符\n\n+、-、*、/、%\n\n### 5.1.2移位操作符\n\n操作对象：整数类型\n\n左移：>>\n\n右移：<<\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1fa72c6ed15f44e19b422c6f3fb51bae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n对于有符号值，到底是采用逻辑移位还是算数移位(会保持当前符号)取决于编译器。\n\n```c\n/*\n* 该函数返回参数值二进制中值为1的位的个数 （初级版本）\n*/\nint count_one_bits(unsigned value){\n    int ones;\n    //当这个值还有一些值为1的位时。\n    for(ones=0;value!=0;value=value>>1)\n    \tif(value%2!=0)  \n            ones+=1;\n    \n    return ones\n}\n```\n\n### 位操作符\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/803a3f7cef044dc18166e9a9973009b8.png#pic_center)\n\n\n例：\n\n| a    | 00101110 |\n| ---- | -------- |\n| b    | 01011011 |\n| a&b  | 00001010 |\n| a\\|b | 01111111 |\n| a^b  | 01110101 |\n\n### 赋值\n\n```c\na=x=y+3\n```\n\n该语句a和x被赋的值可能不同。\n\n假如x是一个字符型变量，那么y+3会被截去一段，以便容纳于字符类型的变量中。那么a的值将会是这个被截取后的值。\n\n```c\nchar ch;\n...\nwhile((ch=getchar())!=EOF)...\n```\n\nEOF需要的位数比字符型值所能提供的位数要多，这也是getchar返回一个整型值而不是字符值的原因。然而，getchar的返回值首先存入ch中会导致它被截短，然后这个截短的值又会和EOF比较。\n\n在使用<u>有符号字符集</u>的机器上运行时，若读取了一个值为\\377的字节时，循环会终止，因为这个值截短再提升之后会和EOF相等。  在使用<u>无符号字符集</u>的机器上运行时，这会成为死循环。\n\n### 条件操作符\n\nexpression1 ? expression2 : expression3\n\n### 逗号操作符\n\nexpression1 , expression2 ,....,expressionN\n\n### 下标引用、函数调用和结构成员\n\n```c\n//下面两种下标引用方式等价\narray[下标]\n*(array+(下标))\n    \n//结构变量访问成员\ns.a\n//结构指针访问成员\np->a\n```\n\n## 左值和右值\n\n一般来说，左值就是那些能够出现在赋值符号左边的东西，右值就是那些可以出现在赋值符号右边的东西。\n\n```c\na=b+10;\n//a是左值，b+10这个整体是右值。\n//a在后续使用可以出现 xxx=a的形式，因此，a还可以当作右值\n//b+10不能出现b+10=xxx的形式，因此，b+10不能当作左值\n```\n\n## 表达式求值\n\n### 隐式类型转换\n\n```c\nchar a,b,c;\n...\na=b+c;\n//b、c的值被提升为普通整型再做加法运算，结果将被截短再存入a中\n```\n\n### 算术转换\n\n```c\nint a=5000;\nint b=25;\nlong c=a*b;\n//第三行在32位整数的机器上运行无问题，但是在16位整数的机器\n//上会出现乘法运算溢出。  可以改为以下形式\nlong c=(long)a*b\n```\n\n### 操作符的属性\n\n复杂表达式的求值顺序由3个因素决定：操作符的优先级、操作符的结合性、操作符是否控制执行的顺序。\n\n## 警告的总结\n\n1.有符号值得右移位操作是不可移植的。\n\n2.移位操作的位数是个负值。\n\n3.连续赋值中各个变量的长度不一。\n\n4.误用=而不是==进行比较。\n\n5.误用|替代||，或误用&替代&&。\n\n6.在不同的用于表示布尔值的非零值之间进行比较。\n\n7.表达式赋值的位置并不决定表达式计算的精度。\n\n8.编写结果依赖于求值顺序的表达式。\n\n## 编程提示总结\n\n1.使用复合赋值符可以使程序更易于维护。\n\n2.使用条件操作符替代if语句以简化表达式。\n\n3.使用逗号操作符来消除多余的代码。\n\n4.不要混用整型和布尔型值。\n\n\n\n\n\n\n\n# 指针\n\n## 内存和地址\n\n变量名字和内存位置之间的关联并不是由硬件所提供的，它是由编译器为我们实现的。所有这些变量给我们一种更方便的方法记住地址--**硬件仍然通过地址访问内存位置**。\n\n\n\n## 间接访问操作符\n\n间接访问：通过一个指针访问它所指向的地址的过程。又称引用指针。\n\n```c\nint a=100;\nint *p=a;\n//p本身存储的是a的地址。通过*p可以访问到a的地址获取值100.\n```\n\n## 未初始化和非法指针\n\n```c\nint *a;\n*a=12;\n//a指针未初始化，我们不知道a所存储的地址到底是何处。\n//因此，每次构建指针的时候一定要初始化指针所存储的地址。\n\n//比如\nint p=12;\na=p;    //这一步给了a一个地址\n*a=1；\n//同样的还可以  int *a=p;\n```\n\n## NULL指针\n\nNULL指针表示不指向任何东西。要使一个指针变量未NULL，你可以给它赋一个零值。   它可以用来判断某个特定指针目前是否有指向什么东西。\n\n在使用一个指针前，可以优先判断它是不是NULL指针。\n\n\n\n## 指针、间接访问和左值\n\n指针变量可以作为左值，是因为它们是变量，而不是因为它们是指针。\n\n\n\n## 指针、间接访问和变量\n\n```c\n*&a=25；\n//&操作符产生a的地址，*操作访问这个地址，最后将25存入该地址。\n```\n\n上句结果和a=25相同。但是上句设计更多的操作，容易降低代码的可读性。\n\n\n\n## 指针常量\n\n```c\nint a=100;\n*(int *)100=25;  \n//强制类型转换把100从“整型”变为“指向整型的指针”\n```\n\n这个技巧的主要用途是访问某个具体的地址。例如，操作系统需要与输入输出设备控制器通信，启动I/O操作并从前面的操作中获得结果。\n\n## 指针表达式\n\n```c\nchar ch='a';\nchar *cp=ch;\n*cp+1  //取出cp指向地址的内容'a'并+1\n*(cp+1) //获取cp所指向地址的后一个地址。数组的下标操作基于此式\ncp++  //将cp所指向的地址移向下一块地址\n    \n*cp++  //1.++操作符产生cp的一份拷贝。2.++操作符增加cp的值。\n       //3.在cp的拷贝上执行间接访问操作\n```\n\n```c\nstrlen(char *string){\n\tint length=0;\n    //依次访问字符串的内容，计算字符数，直到遇见NULL终止符\n    while(*string++ != '\\0')\n        length+=1;\n    return length;\n}\n//这个函数统计的确实是字符串的长度，但是没有统计首个字符，\n//而是用'\\0'代替首字符进行统计\n```\n\n\n\n## 指针运算\n\n如果p是指向x类型的指针，那么p+1就是指向下一个x类型的指针。\n\n1.p+i得到p之后第i个x类型的指针。\n\n2.指针-指针，结果是两个指针在内存中的距离\n\n\n\n```c\nfor(vp=&values[N_VALUES];vp>&values[0]; )\n\t*--vp=0;\n\nfor(vp=&values[N_VALUES-1];vp>=&values[0];vp--)\n    *vp=0;\n//第二个循环结束之后vp会发生越界\n```\n\n\n\n## 警告的总结\n\n1.错误地对一个未初始化的指针变量进行解引用。\n\n2.错误地对一个NULL指针进行解引用。\n\n3.像函数错误地传递NULL指针。\n\n4.未检测到指针表达式的错误，从而导致不可预测的结果。\n\n5。对一个指针进行减法运算，是它非法地指向了数组第1个元素的前面的内存位置。\n\n\n\n## 编程提示的总结\n\n1.一个值应该只具有一种意思。\n\n2.如果指针并不只想任何有意义的东西，就把它设置为NULL。\n\n# 函数\n\n\n\n## 递归和迭代\n\n对于计算阶乘和斐波那契数列来说，递归并没有提供任何优越之处，而且效率非常低。\n\n递归通过栈实现。\n\n迭代即递推。计算阶乘和斐波那契数列用迭代效率会高非常多。\n\n## 可变参数列表\n\n目的：让一个函数在不同时候接受不同数目的参数。\n\n### stdarg宏\n\n头文件:stdarg.h\n\n这个头文件声明了 一个类型va_list 和三个宏——va_start、va_arg、va_end。\n\n函数声明一个名叫var_arg的变量，用于访问参数列表的未确定部分。该变量通过va_start初始化。它的第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数。初始化过程把var_arg变量设置为指向可变参数部分的第1个参数。\n\n为了访问参数，需要使用va_arg，这个宏接受两个参数：va_list变量和参数列表中下一个参数的类型。    在有些函数中，你可能要通过前面获得的数据来判断下一个参数的类型。va_arg返回这个参数的值，并使var_arg指向下一个可变参数。\n\n最后，当访问完毕最后一个可变参数之后，我们需要调用va_end。\n\n```c\n//计算指定数量的值的平均值\n#include<stdarg.h>\nfloat average(int n_values,...)\n{\n    va_list var_arg;\n    int count;\n    float sum=0;\n    //准备访问可变参数\n    va_start(var_arg,n_values);\n    //添加取自可变参数列表的值\n    for(count=0;count<n_values;count++){\n        sum+=va_arg(var_arg,int );//第二个参数表示下一个参\t\t\t\t\t\t\t\t\t//数的类型\n    }\n    //完成处理可变参数\n    va_end(var_arg);\n    return sum/n_values;\n}\n```\n\n不过，va_arg无法正确识别作用于可变参数之上的缺省参数类型提升。char、short、float类型的值实际上将作为int或double类型的值传递给函数。\n\n\n\n## 警告的总结\n\n1.错误地在其他函数的作用域内编写函数原型。\n\n2.没有为那些返回值不是整型的函数编写原型。\n\n3.把函数原型和旧式风格的函数定义混合使用。\n\n4.在va_arg中使用错误的参数类型，导致未定义的结果。\n\n\n\n## 编程提示的总结\n\n1.在函数原型中使用参数名，可以给使用该函数的用户提供更多的信息。\n\n2.抽象数据类型可以减少程序对模块实现细节的依赖，从而提高程序的可靠性。\n\n3.当递归定义清晰的有点可以补偿它的效率开销时，就可以使用这个工具。\n\n# 数组\n\n数组本质是指针。\n\n## 一维数组\n\n### 下标引用\n\n```c\n//这两句话等价\narray[subscript];\n*(array+(subscript));\n```\n\n```c\nint *ap=array+2;\n\n*ap+6   //相当于array[2]+6\n*(ap+6) //相当于array[2+6]\nap[-1]  //array[1]\n\n2[array] //等价于array[2],不过不推荐写\n```\n\n指针有时比下标更有效率。\n\n### 数组和指针\n\n```c\nint a[5];\nint *b;\n//*a合法，*b不合法。因为*b会访问内存中的未知位置\n//b++合法，a++非法。因为a的值是个常量\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f046617758484a1c82c01cddb19053fe.png#pic_center)\n\n\n### 初始化\n\n```c\n//完整初始化\nint vector[5]={10,20,30,40,50};\n//不完整初始化\nint vector[5]={1,2,3}; //未初始化的部分默认为0。不能出现超出数\t\t\t\t\t//组范围的初始化\n//自动计算长度\nint vector[]={1,2,3};\n\n//字符数组初始化\nchar message[]={'H','e','l','l','o',0};\nchar message[]=\"Hello\";\n```\n\n\n\n```c\nchar message1[]=\"Hello\";\nchar *message2=\"Hello\";\n//这两种声明方式的结果有区别，见下图\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d2d87e0a8cb04607a8d21cfffa3ebc9f.png#pic_center)\n\n\n\n\n## 多维数组\n\n```c\nint array[3][6];\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4997fed084a44f968a91a7b7ce3a6603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 下标\n\n```c\nint matrix[3][10];\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/902d4976d75043479557dc15bcb0d04f.png#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/9e36d195a27b405882161ac1868c841e.png#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/301a2eb948cc4186a1c3306115b04d9c.png#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/754c2e734dfd478fbb5393393c8c63ef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/18027cd177c34864ab75d92b7c9c755e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n### 指向数组的指针\n\n```c\nint vector[10], *vp=vector;  //合法\nint matrix[3][10], *mp=matrix;  //非法\n//matrix是一个指向整型数组的指针\n\n//声明一个指向整型数组的指针\nint (*p)[10];\n//初始化\nint (*p)[10]=matrix;  //p指向matrix的第一行\n\n\n//两种方式创建一个简单的整型指针\nint *pi=&matrix[0][0];\nint *pi=matrix[0];\n```\n\n\n\n### 作为函数参数的多维数组\n\n```c\nint matrix[3][10];\n//两种等价引用\nvoid func(int (*matrix)[10]);\nvoid func(int mat[][10]);\n```\n\n\n\n### 初始化\n\n```c\nint matrix[2][3]={100,101,102,110,111,112};\n\nint matrix[3][5]={\n    {00,01,02,03,04},\n    {10,11,12,13,14},\n    {20,21,22,23,24}\n};\n\n//初始化一个三维数组\nint three_dim[2][3][5]={\n    {\n        {000,001,002,003,004},\n        {010,011,012,013,014},\n        {020,021,022,023,024}\n    },\n    {\n        {100,101,102,103,104},\n        {110,111,112,113,114},\n        {120,121,122,123,124}\n    }\n};\n\n\n//初始化一个四维数组\nint four_dim[2][2][3][5]={\n    {\n        {\n            {0000,0001,0002,0003,0004},\n            {0010,0011,0012,0013,0014},\n            {0020,0021,0022,0023,0024}\n        },\n        {\n            {0100,0101,0102,0103,0104},\n            {0110,0111,0112,0113,0114},\n            {0120,0121,0122,0123,0124}\n        }\n    },\n    {\n        {\n            {1000,1001,1002,1003,1004},\n            {1010,1011,1012,1013,1014},\n            {1020,1021,1022,1023,1024}\n        },\n        {\n            {1100,1101,1102,1103,1104},\n            {1110,1111,1112,1113,1114},\n            {1120,1121,1122,1123,1124}\n        }\n    }\n};\n\n\n\n\n//长度自动计算\nint matrix[][5]={\n    {00,01,02},\n    {10,11},\n    {20,21,22,23}\n};\n```\n\n## 指针数组\n\n```c\nint *api[10];  //api数组存的是整数型指针\n\nchar const keyword[]={\n    \"do\",\n    \"for\",\n    \"if\",\n    \"register\",\n    \"return\",\n    \"switch\",\n    \"while\"\n};\n```\n\n\n\n## 警告的总结\n\n1.当访问多维数组的元素时，误用逗号分隔下标。\n\n2.在一个指向未指定长度的数组的指针上执行指针运算。\n\n## 编程提示的总结\n\n1.一开始就编写良好的代码显然比依赖编译器来修正劣质代码更好。\n\n2.源代码的可读性几乎总是比程序的运行时效率更为重要。\n\n3.只要有可能，函数的指针形参都应该声明为const。\n\n4.在有些环境中，使用register关键字提高程序的运行时效率。\n\n5.在多维数组的初始值列表中使用完整的多层花括号能提高可读性。\n\n# 字符串、字符和字节\n\n## 字符串长度\n\n```c\nif(strlen(x)>=strlen(y)) ...\nif(strlen(x)-strlen(y)>=0)...\n//第二个判断将永远为真，因为strlen返回一个无符号数，无符号数\n//不可能减出一个负值\n```\n\n## 字符串查找基础\n\n### 查找一个字符\n\n```c\nchar *strchr(char const *str, int ch);//查找ch第一次出现的位置\nchar *strrchr(char const *str, int ch);//查找ch最后出现的位置\n\nchar string[20]=\"Hello there, honey.\";\nchar *ans;\nans=strchr(string,'h');\n//ans所致的位置将是string+7\n```\n\n\n\n### 查找任何几个字符\n\n```c\nchar *strpbrk(char const *str, char const *group);\n//该函数返回一个指向str中第1个匹配group中任何一个字符的字符位置，未找到则返回NULL指针\n\nchar string[20]=\"Hello there, honey.\";\nchar *ans;\nans=strchr(string,'aeiou');\n//ans将指向string+1\n```\n\n\n\n### 查找一个字串\n\n```c\nchar *strstr(char const *s1, char const *s2);\n//该函数在s1中查找整个s2第一次出现的 起始位置\n//不过标准库中没有 strrstr 函数，需要自己实现。\n\n#include<string.h>\nchar *my_strrstr(char const *s1, char const *s2){\n    //在s1中查找字符串s2最右出现的位置，并返回一个该位置的指针\n    register char *last;\n    register char *current;\n    //把指针初始化为我们已经找到的前一次匹配位置\n    last=NULL;\n    //旨在第2个字符串不为空时才进行查找，若s2为空，返回NULL。\n    if(*s2!='\\0'){\n        //查找s2在s1中第1次出现的位置\n        current=strstr(s1,s2);\n        //我们每次找到字符串时，让指针指向它的起始位置，然后查找该字符串的下一个匹配位置\n        while(current!=NULL){\n            last=current;\n            current=strstr(last+1,s2);\n        }\n    }\n    //返回指向我们找到的最后一次匹配的起始位置的指针\n    return last;\n}\n```\n\n\n\n## 高级字符串查找\n\n### 查找一个字符串前缀\n\n```c\nsize_t strspn(char const *str, char const *group);\n//返回str起始部分匹配group中仍以字符的字符数\nint len1,len2;\nchar buffer[]=\"25,142,330,Smith,J,239-4123\";\n\nlen1=strspn(buffer,\"0123456789\");  //len1=2\nlen2-strspn(buffer,\",0123456789\");  //len2=11\n\n\nsize_t strcspn(char const *str, char const *group);\n//返回str字符串起始部分中不与group中任何字符匹配的字符数。\n```\n\n\n\n### 查找标记\n\n```c \nchar *strtok(char *str, char const *sep);\n//sep定义了用作分隔符的 字符集合 。strtok找到str的下一个标记，并将其用NULL结尾，然后返回一个指向这个标记的指针。\n//str会被修改\n//如果第1个参数是NULL，函数就在同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记\n\n\n#include<stdio.h>\n#include<string.h>\nvoid print_tolens(char *line){\n//从一个字符数组中提取空白字符分割的标记并把它们打印出来(每行一个)。\n    static char whitespace[]=\" \\t\\f\\r\\v\\n\";\n    char *token;\n    \n    for(token=strtok(line,whitespace);\n       token!=NULL;\n       token=strtok(NULL,whitespace)) //第一个参数为NULL，因此直接从token的位置开始寻找下一处分隔标记\n          printf(\"Next token is %s\\n\",token);\n}\n```\n\n## 错误信息\n\n```c\nchar *strerror(int error_number);\n//该函数把其中一个错误代码作为参数并返回一个指向用于描述错误的字符串指针\n```\n\n\n\n## 字符操作\n\n头文件：ctype.h\n\n### 字符分类\n\n| 函数     | 如果它的参数复合下列条件就返回真                             |\n| -------- | ------------------------------------------------------------ |\n| iscntrl  | 任何控制字符                                                 |\n| isspace  | 空白字符：空格' '、换页'\\f'、换行'\\n'、回车'\\r'、制表符'\\t \\v' |\n| isdigit  | 十进制数字0~9                                                |\n| isxdigit | 十六进制数字，包括所有十进制数字。a(A)~f(F)                  |\n| islower  | 小写字母a~z                                                  |\n| isupper  | 大写字母A~Z                                                  |\n| isalpha  | 大小写字母                                                   |\n| isalnum  | 字母或数字                                                   |\n| ispunct  | 标点符号，任何不属于数字或字母的图形字符                     |\n| isgraph  | 任何图形字符                                                 |\n| isprint  | 任何可打印字符，包括图形字符和空白字符                       |\n\n### 9.8.2字符转换\n\n```c\nint tolower(int ch); //字母转小写\nint toupper(int ch);\n```\n\n\n\n## 内存操作\n\n目的：避免非字符串数据内部包含零值的情况，这类情况无法使用字符串函数来处理，因为当它们遇到第一个NULL字节时将停止工作。\n\n注：任何类型的指针都可以转换为void* 指针\n\n```c \nvoid *memcpy(void *dst, void const *src, size_t length);\n//从src的起始位置赋值length个字节到dst的内存起始位置\nvoid *memmove(void *dst, void const *src, size_t length);\nvoid *memcmp(void const *a, void const *b, size_t length);\nvoid *memchr(void const *a, int ch, size_t length);\nvoid *memset(void *a, int ch, size_t length);\n\n//这些函数整体功能和str系列函数差不多，但它们可以处理包括NULL字节在内的任意字节\n```\n\n\n\n## 警告的总结\n\n1.应该使用有符号数的表达式中使用strlen函数。\n\n2.在表达式中混用有符号数和无符号数。\n\n3.使用strcpy函数把一个长字符串复制到一个较短的数组中，导致溢出。\n\n4.使用strcat函数把一个字符串添加到一个数组中，导致数组溢出。\n\n5.使用strcmp函数返回值当作布尔值进行测试。\n\n6.把strcmp函数的返回值与1和-1比较。\n\n7.使用并非以NULL字节结尾的字符序列。\n\n8.使用strncpy函数产生不以NULL字节结尾的字符串。\n\n9.把strncpy函数和strxxx族函数混用。\n\n10.忘了strtok函数将会修改它所处理的字符串。\n\n11.strtok函数是不可再入的。\n\n\n\n## 编程提示总结\n\n1.不要试图自己编写技能相同的函数来取代库函数。\n\n2.使用字符分类和转换函数可以提高函数的移植性。\n\n\n\n\n\n# 结构体和联合\n\n与数组不同，每个结构体成员都有自己的名字，它们都是通过名字访问的。\n\n## 结构体基础\n\n### 结构体声明\n\n```c\nstruct {\n    int a;\n    char b;\n    float c;\n}x;\n\nstruct {\n    int a;\n    char b;\n    float c;\n}y[20],*z;   //这种声明和上一个声明再编译器中是两种不同的类型，即\t\t\t使它们的成员列表完全相同。\n//因此，z=&x;  非法\n```\n\n```c\n//利用标签创建变量\nstruct SIMPLE{\n    int a;\n    char b;\n    float c;\n};\nstruct SIMPLE x;\nstruct SIMPLE y[20],*z;\n\n//利用typedef\ntypedef struct{\n    int a;\n    char b;\n    float c;\n}Simple;\n\nSimple x;\nSimple y[20],*z;\n```\n\n### 成员访问\n\n```c\ntypedef struct{\n    int a;\n    char b;\n    float c;\n}Simple;\n\n//一般访问\nSimple x;\nx.a;\n//指针访问\nSimple *p=&x;\n(*p).a;     p->a;\n```\n\n\n\n### 结构体自引用\n\n```c\nstruct SELF_REF{\n\tint a;\n\tint c;\n\tstruct SELF_REF *b;   \n};//自引用必须是指针而不是一般结构体，因为编译器再结构体的长度确定之前就已经知道指针的长度。\n```\n\n### 不完整声明\n\n```c\n//构建两个互相引用的结构体\nstruct B;  //不完整声明\nstruct A{\n\tstruct B *partner;\n};\nstruct B{\n\tstruct A *partner;\n};\n```\n\n\n\n### 结构体初始化\n\n```c\ntypedef struct{\n    int a;\n    char b;\n    float c;\n}Simple;\n\nstruct INIT_EX{\n    int a;\n    short b[10];\n    Simple c;\n}x={\n    10,\n    {1,2,3,4,5},\n    {25,'x',1.9};\n}\n```\n\n\n\n## 结构的存储分配\n\n```c\nstruct ALIGN{\n    char a;\n    int b;\n    char c;\n};  //成员在编译时会按声明顺序进行存储\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/141678bd480d48ccb3648f5b301e9291.png#pic_center)\n显然，a后面会先浪费3个空间再存b，为了节省空间，可以如下声明\n\n```c\nstruct ALIGN{\n    int b\n    char a；\n    char c;\n}; \n\n//sizeof操作可以得出一个结构体的整体长度，包括上述浪费的空间。\n\n//如果必须确定结构某个成员的实际位置，可以使用offsetof宏(stddef.h)\noffsetof(type , memeber);\n//如 offsetof(struct ALIGN, b); 会返回b的首地址\n```\n\n## 作为函数参数\n\n若不使用指针传递，一个大体量的结构体的值传递将会花费较大资源拷贝一个备份传入堆栈，函数调用完之后又要删除，这样效率很低。\n\n推荐使用指针传递，为了防止结构体被修改，可以将指针引用声明为const。\n\n另外，还可以把参数声明为寄存器变量，从而进一步提高指针传递方案的效率。\n\n```c\nvoid f(register SIMPLE const *trans);\n```\n\n\n\n## 位段\n\n```c\n//声明\nstruct CHAR{\n    unsigned ch\t\t:7;\n    unsigned font\t:6;\n    unsigned size\t:19;\n};\nstruct CHAR ch1;\n//该结构体可以处理128(2^7)个不同的字符值、64(2^6)种不同的字体、0~524287个单位的长度。\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dfc12bddf6db4a2e9a62a500cb192fd2.png#pic_center)\n另一个使用位段的理由就是它们可以很方便地访问一个整型值得部分内容。\n\n例：操作系统中，用于操作软盘的代码必须与磁盘控制器通信。这些设备控制器常常包含了几个寄存器，每个寄存器又包含了许多包装在一个整型值内的不同的值。位段就是一种方便访问这些单一值得方法。假定磁盘控制器其中一个寄存器是如下定义的：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/05a40d45b9504366845c805038ae5167.png#pic_center)\n\n\n前5个位段每个都占1位，其余几个位段更长一些。在一个从右向左分配位段的机器上，下面这个声明允许程序方便对这个寄存器的不同位段进行访问。\n\n```c\nstruct DISK_REGISTER_FORMAT{\n    unsigned command\t\t:5;\n    unsigned sector\t\t\t:5;\n    unsigned track\t\t\t:9;\n    unsigned error_code\t\t:8;\n    unsigned head_loaded\t:1;\n    unsigned write_protect\t:1;\n    unsigned disk_spinning\t:1;\n    unsigned error_occurred\t:1;\n    unsigned ready\t\t\t:1;\n};\n\n\n//假如磁盘寄存器是在内存地址0xc0200142进行访问的，我们可以声明下面的指针常量\n#define DISK_REGISTER \\\n\t((struct DISK_REGISTER_FORMAT *)0xc0200142)\n\n//告诉控制器从哪个扇区哪个磁道开始读取\nDISK_REGISTER->sector=new_sector;\nDISK_REGISTER->track=new_track;\nDISK_REGISTER->command=new_READ;\n\n//等待，知道操作完成(ready变量变成真)\nwhile(!DISK_REGISTER->ready)  ;\n\n//检查错误\nif(DISK_REGISTER->error_occurred){\n    switch(DISK_REGISTER->error_code){\n            ...\n    }\n}\n\n\n//赋值\n#define DISK_REGISTER (unsigned int*)0xc0200142  //与前一个define作用相同\n*DICK_REGISTER &=0XFFFFFC1F; //使用与操作把sector字段清零，但不影响其他字段\n*DISK_REGISTER |= (new_sector & 0x1f) <<5; //接受new_sector的值，&确保这个值不会超过这个位段的宽度。接着，把它左移到合适的位置，然后再用 | 把这个字段设置为重要的值\n```\n\n\n\n## 联合\n\n目的：在<u>不同的时刻</u>把不同的东西存储在同一个位置。\n\n```c\nunion{\n\tfloat f;\n\tint i;\n}fi;\n//分配给联合的内存数量取决于它的最长成员的长度\n```\n\n事实上，假如union的存储长度很长，但是某一时刻它实际存入的内容很短，这就会造成资源浪费。为了节省空间，可以让union存储不同类型的指针，所有指针的存储长度是相同的。\n\n### 初始化\n\n```c\nunion{\n\tint a;\n\tfloat b;\n\tchar c[4];\n}x={5}; //初始值必须是联合第1个成员的类型\n```\n\n## 警告的总结\n\n1.具有相同成员列表的结构声明产生不同类型的变量。\n\n2.使用typedef位一个自引用的结构体定义名字时应该小心。\n\n3.向函数传递结构参数是低效的。\n\n## 编程提示总结\n\n1.把结构标签声明和结构的typedef声明放在头文件中，当源文件需要这些声明时可以通过#include进行引用。\n\n2.结构成员的最佳排列方式并不一定就是考虑边界对齐而浪费内存空间最少的那种排列形式(要在可读性和省空间之间有所权衡)。\n\n3.把位段成员显式地声明为signed int 或unsigned int 类型。\n\n4.位段是不可移植的。\n\n5.位段使源代码中位的操作表达得更为清楚。\n\n# 动态内存分配\n\n基本函数：malloc(分配内存)、free(释放内存)\n\n头文件：stdlib.h\n\n```c\nvoid *malloc(size_t size); //分配一个指定大小的连续内存，若操作系统无法向malloc提供更多内存，malloc会返回NULL指针\ncoid free(void *pointer); //参数要么是NULL，要么是先前从malloc、calloc、realloc返回的值\n```\n\n## calloc和realloc\n\n```c\nvoid *calloc(size_t num_elements, size_t element_size);//返回的指针会顺便初始化\nvoid *realloc(void *ptr, size_t new_size);//修改一个原先已经分配的内存块的大小\n```\n\n## 使用例\n\n```c\nint *pi;\npi=malloc(100);\nif(pi==NULL){ //错误检查\n    printf(\"Out of memory.\\n\");\n    exit(0);\n}\n\n//分配一个足够存储25个整数的内存\npi=malloc(25*sizeof(int)); //可移植\n//对pi既可以进行*pi++操作，还可以进行pi[i]操作\n```\n\n## 常见的动态内存错误\n\n错误分类：\n\n1.对NULL指针进行解引用。\n\n2.对分配的内存进行操作时越界。\n\n3.释放并非动态分配的内存。\n\n4.试图释放一块动态分配的内存的一部分。\n\n5.一块动态内存被释放之后被继续使用。\n\n```c\nalloc.h\n//定义一个不易发生错误的内存分配器\n#include<stdlib.h>\n#define malloc     //不要直接调用malloc\n#define MALLOC(num , type)  (type*)alloc((num)*sizeof(type))\nextern void *alloc(size_t size);\n//alloc可以调用malloc并进行检查，确保返回的指针不是NULL\n```\n\n```c\n//接口\n#include<stdio.h>\n#include \"alloc.h\"\n#undef malloc\nvoid *alloc(size_t size){\n    void *new_mem;\n    //请求所需的内存，并检查确实分配成功\n    new_mem=malloc(size);\n    if(new_mem==NULL){\n        printf(\"Out of memory.\\n\");\n        exit(1);\n    }\n    return new_mem;\n}\n```\n\n```c \n//实现\n#include \"alloc.h\"\nvoid function(){\n    int *new_memory;\n    //获得一串整型数的空间\n    new_memory=MALLOC(25,int);\n}\n```\n\n#### 不要访问被free释放的内存\n\n```c\nint *p=malloc(100);\nint *q=p;\nfree(p);\n//p释放后，q也不能再使用，除非改变了q的内容\n```\n\n#### 内存泄漏\n\n分配内存但在使用完毕后不释放将引起内存泄露(memory leak)。这会一点点榨干可用内存，除非重启系统。\n\n## 警告的总结\n\n1.不检查从malloc函数返回的指针是否为NULL。\n\n2.访问动态分配内存之外的区域。\n\n3.向free函数传递一个并非由malloc番薯返回的指针。\n\n4.在动态内存被释放之后再访问它。\n\n## 编程提示总结\n\n1.动态内存分配有助于消除程序内部存在的限制。\n\n2.使用sizeof计算出具类型的长度，提高程序的可移植性。\n\n\n\n\n\n# 使用结构和指针\n\n\n\n## 双链表\n\n注：读代码时可以在草稿纸上模拟链表操作\n\n```c\n//双链表结点定义   doubly_linked_list_node.h\ntypedef struct NODE{ \n    struct NODE *fwd;\n    struct NODE *bwd;\n    int value;\n}Node;\n```\n\n### 双链表插入操作的优化\n\n```c\n//一般的双链表插入函数\n#include<stdlib.h>\n#include<stdio.h>\n#include \"doubly_linked_list_node.h\"\nint dll_insert(Node *rootp, int value)\n{\n    Node *this;\n    Node *next;\n    Node *newnode;\n    /*\n    \t查看value是否已经存在于链表中，如果是就返回。\n    \t否则，为心的值创建一个新节点(newnode指向它)\n    \t\"this\"指向新节点之前的那个结点\n    \t\"next\"指向新节点之后的那个结点\n    */\n    for(this=rootp ; (next=this->fwd)!=NULL;this=next){\n        if(next->value==value) return 0;\n        if(next->value>value) break;\n    }\n    \n    newnode=(Node *)malloc(sizeof(Node));\n    if(newnode==NULL) return -1;\n    newnode->value=value;\n    \n    //把新值添加到链表中\n    if(next!=NULL){\n        //情况1、2：并非位于链表尾部\n        \n        if(this!=rootp){//情况1：并非位于链表起始位置\n            newnode->fwd=next;\n            this->fwd=newnode;\n            newnode->bwd=this;\n            next->bwd=newnode;\n        }\n        else{\t\t\t//情况2：位于链表起始位置\n            newnode->fwd=next;\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n            next->bwd=newnode;\n        }\n    }\n    else{\n        //情况3、4：位于链表尾部\n        \n        if(this!=rootp){//情况3：并非位于链表起始位置\n            newnode->fwd=NULL;\n            this->fwd=newnode;\n            newnode->bwd=this;\n            rootp->bwd=newnode;\n        }\n        else{\t\t\t//情况4：位于链表起始位置\n            newnode->fwd=NULL;\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n            rootp->bwd=newnode;\n        }\n    }\n    return 1;\n}\n```\n\n仔细分析可以发现，不同情况中存在相同的操作，可以进行提炼化简代码\n\n```c\n//第一次逻辑提炼\nif(next!=NULL){\n        //情况1、2：并非位于链表尾部\n        \n        newnode->fwd=next;\n        if(this!=rootp){//情况1：并非位于链表起始位置\n            this->fwd=newnode;\n            newnode->bwd=this;\n        }\n        else{\t\t\t//情况2：位于链表起始位置\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n        }\n    \tnext->bwd=newnode;\n    }\n    else{\n        //情况3、4：位于链表尾部\n        \n        newnode->fwd=NULL;\n        if(this!=rootp){//情况3：并非位于链表起始位置\n            this->fwd=newnode;\n            newnode->bwd=this;\n        }\n        else{\t\t\t//情况4：位于链表起始位置\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n        }\n        rootp->bwd=newnode;\n    }\n```\n\n这个过程其实还可以简化。先看一个例子\n\n```c\nif(pointer !=NULL) field=pointer;\nelse field=NULL;\n\n//上面的判断本质上等价于下句\nfield=pointer\n\n//因此，之前代码的if(next != NULL)判断可以用这种方法化简\nnewnode->fwd=next;\nif(this!=rootp){\n    this->fwd=newnode;\n    newnode->bwd=this;\n}\nelse{\n    rootp->fwd=newnode;\n    newnode->bwd=NULL;\n}\n\nif(next!=NULL) next->bwd=newnode;\nelse rootp->bwd=newnode;\n```\n\n```c\n//最终版本\n\n#include<stdlib.h>\n#include<stdio.h>\n#include \"doubly_linked_list_node.h\"\nint dll_insert(Node *rootp, int value)\n{\n    register Node *this;\n    register Node *next;\n    register Node *newnode;\n    /*\n    \t查看value是否已经存在于链表中，如果是就返回。\n    \t否则，为心的值创建一个新节点(newnode指向它)\n    \t\"this\"指向新节点之前的那个结点\n    \t\"next\"指向新节点之后的那个结点\n    */\n    for(this=rootp ; (next=this->fwd)!=NULL;this=next){\n        if(next->value==value) return 0;\n        if(next->value>value) break;\n    }\n    \n    newnode=(Node *)malloc(sizeof(Node));\n    if(newnode==NULL) return -1;\n    newnode->value=value;\n    \n    //把新值添加到链表中\n    newnode->fwd=next;\n    this->fwd=newnode;\n    \n    if(this!=rootp) newnode->bwd=this;\n    else newnode->bwd=NULL;\n    \n    if(next!=NULL) next->bwd=newnode;\n    else rootp->bwd=newnode;\n    \n    return 1;\n}\n```\n\n\n\n## 警告的总结\n\n1.落到链表尾部的后面。\n\n2.使用指针时应格外小心，因为C并没有对它们的使用提供安全网。\n\n3.从if语句中提炼语句可能会改变测试结果。\n\n\n\n## 编程提示的总结\n\n1.消除特殊情况使代码更易于维护。\n\n2.通过提炼语句消除if语句中的重复语句。\n\n3.不要仅仅根据代码的大小评估它的质量。\n\n# 高级指针话题\n\n## 高级声明\n\n```c\nint *f();   //声明一个函数，它返回一个指向整型的指针\nint (*f)(); //声明一个函数的指针，它指向的函数返回一个整型值\n\nint *(*f)(); //和上一句相同，但必须对其进行间接访问操作才能得到整型值\n\nint *f[]; //f是一个数组，它的元素类型是指向整型的指针。\nint f()[];  //f是一个函数，它的返回值是一个整型数组。不过这个声明是非法的，因为这里的函数只能返回标量值。\nint f[]();   //f是个数组，它的元素类型是返回值为整型的函数。这个声明也是非法的，因为数组元素必须有相同的长度。\n\nint (*f[])(); //这个声明是合法的。先求*f[]，f是一个元素为某种类型的指针的数组。然后看()号，说明f的数组元素是函数指针，这些指针所指向的函数的返回值是一个整型值\n\nint *(*f[])(); //与上一句同理，只是多了个间接访问符\n\n\n/*==============================================================*/\n\n\nint (*f)(int ,float);\nint *(*g[])(int ,float);\n//前者把f声明为一个函数指针，这个函数接受int和float两个类型的参数。\n//后者则是一个存函数指针的数组\n```\n\n\n\n## 函数指针\n\n```c\nint f(int);\nint (*pf)(int)=&f;\n\n//调用\nint ans;\nans=f(25);\nans=(*pf)(25);\nans=pf(25);\n```\n\n### 回调函数\n\n向函数传递一个指向值的指针而不是值本身。函数有一个void* 形参，用于接收这个参数。  这样字符串和数组对象也可以被调用。字符串和数组无法作为参数传递给函数，但是指向它们的指针可以。\n\n```c\n/*\n\t在一个单链表中查找一个指定值的函数，它的参数是一个指向链表第1个结点的指针，一个指向我们需要查找的值的指针和一个函数指针，它所指向的函数用于比较存储与链表中的类型的值。\n*/\n#include<stdio.h>\n#include \"node.h\"\n\nNode* search_list(Node *node, void const *value.\n          int(*compare)(void const *, void const *))\n{\n    while(node!=NULL){\n        if(compare(&node->value,value)==0) break;\n        node=node->link;\n    }\n    return node;\n}//类型无关的链表查找\n```\n\n### 转换表\n\n```c\n//简易计算器\nswitch(oper){\n    case ADD:\n        result=add(op1,op2);\n        break;\n    case SUB:\n    \tresult=sub(op1,op2);\n    \tbreak;\n    case MUL:\n        result=mul(op1,op2);\n        break;\n    case DIV:\n        result=div(op1,op2);\n        break;\n}\n\n//函数声明\ndouble add(double,double);\ndouble sub(double,double);\ndouble mul(double,double);\ndouble div(double,double);\n...\ndouble (*oper_func[])(double,double)={\n    add,sub,mul,div...\n};\n\n//这一句可以取代一开始的switch语句\nresult=oper_func[oper](op1,op2);\n//oper从数组中选择正确的函数指针，而函数调用操作符将执行这个函数\n```\n\n\n\n## 命令行参数\n\nC的main函数有两个形参。第1个通常称为argc，它表示命令行参数的数目。第2个通常称为argv，它指向一组参数值的首元素。这些元素的每个都是指向一个参数文本的指针。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/88e9265027894b09b20bbc12a94ff49a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n\n\n\n```c\n//处理命令行参数\n#include<stdio.h>\n#define TRUE 1\n\n//执行实际任务的函数的原型\nvoid process_standard_input(void);\nvoid process_file(char *file_name);\n\n//选项标志，缺省初始化为FALSE\nint option_a, option_b;\n\nvoid main(int argc, char **argv){\n    //处理选项参数:跳到下一个参数，并检查它是否以一个横杠开头\n    while(*++argv!=NULL && **argv=='-'){\n        //检查横杠后面的字母\n        switch(*++*argv){\n            case 'a':\n                option_a=TRUE;\n                break;\n            case 'b':\n                option_b=TRUE;\n                break;\n        }\n    }\n    \n    //处理文件名参数\n    if(*argv==NULL) process_standard_input();\n    else {\n        do{\n            process_file(*argv);\n        }while(*++argv!=NULL);\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4834227285ee42b0be740071fbfaf504.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e7184cea80084c7b836aa5ccec45e4be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 字符串常量\n\n```c\n\"xyz\"     //这就是一个字符串常量，可以通过\"xyz\"[2]得到第3个字符\n\"xyz\"+1;\n*\"xyz\";   //返回'y'\n\nputchar(\"0123456789ABCDEF\"[value%16]);\n//使用余数作为下标打印指定位置的字符串\n```\n\n```c\n//打印星号\n#include<stdio.h>\nvoid f(int n){\n    n+=5;\n    n/=10;\n    printf(\"%s\\n\",\"**********\"+10-n);\n}\n```\n\n\n\n## 警告的总结\n\n1.对一个未初始化的指针执行间接访问操作。\n\n2.在转移表中使用越界下标。\n\n\n\n## 编程提示总结\n\n1.如果并非必要，避免使用多层间接访问。\n\n2.cdecl程序可以帮助你分析复杂的声明。\n\n3.把void* 强制转换为其他类型的指针式必须小心。\n\n4.使用转移表时，应始终验证下标的有效性。\n\n5.破坏性的命令行参数处理方式会使你以后无法再次进行处理。\n\n6.不寻常的diamagnetic始终应该加上一条注释，描述它的目的和原理。\n\n\n\n# 预处理器\n\n## 预定义符号\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b4996750fa554fc3bb2cbdc3197506af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## #define\n\n```c\n#define name stuff\n//每当有符号name出现在这条指令后面使，预处理器就会把它替换成stuff\n#define reg register\n#define do_forever for(;;)\n#define CASE break;case\n\n#define DEBUG_PRINT printf(\"File %s line %d:\"\\\n\t\t\t\t\t\t\"x=%d,y=%d,z=%d\",\\\n\t\t\t\t\t\t__FILE__,__LINE__,\\\n\t\t\t\t\t\tx,y,z)\n//内容过长可以用\\代表分行\n#define PROCESS_LOOP  \\\n\tfor(i=0;i<10;i+=1){  \\\n\t\tsum+=i;\t\t\t\\\n\t\tif(i>0) prod*=i;  \\\n\t}\n```\n\n### 14.2.1宏\n\n把参数替换到文本中，这种实现叫做宏（macro）。\n\n```c\n#define SQUARE(x) (x)*(x)    //宏不用分号结尾\nSQUARE(5)  //会被替换成5*5\n    \n//第一句若不写为(x)*(x)，则会出现问题，见下例\nSQUARE(a+1)   //会替换成   a+1*a+1而不是(a+1)*(a+1)\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cdefcd2dc8f047b49dbe42908a52bce3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n## #undef\n\n```c\n#undef name\n//如果一个现存的名字需要重新定义，那么它的旧定义首先必须用#undef移除\n```\n\n\n\n## 条件编译\n\n```c\n#if constant-expression\n\tstatements\n#elif constant-expression\n        other statements\n#else\n        other statements\n#endif\n//如果常量表达式的值非零，那么statements部分会被正常编译，否则预处理器会删除它们\n```\n\n## 是否被定义\n\n```c\n#if defined(symbol)\n#ifdef symbol\n\n#if !defined(symbol)\n#ifndef symbol\n\n//例\n#if x>0 || defined(A) && defined(B)\n```\n\n## 文件包含\n\n一个头文件如果被包含到10个源文件中，它实际上被编译了10次。\n\n```c\n#include<filename>   //标准库文件\n#include\"filename\"   //自定义头文件\n```\n\n#### 避免多重包含\n\n```c\n#ifdef _HEADERNAME_H\n#define _HEADERNAME_H 1  //如果头文件再次被包含，通过条件编译，它的所有内容被忽略\n\t...//included filenames\n#endif\n```\n\n## 其他指令\n\n```c\n//#error\n#error text of error message    //生成错误信息\n\n//例\n#if defined(OPTION_A)\n\tstuff needed for option A\n#elif defined(OPTION_B)\n\tstuff needed for option B\n#elif defined(OPTION_C)\n\tstuff needed for option C\n#else\n     #error No option selected!\n#endif\n        \n        \n//#line\n#line number \"string\"\n//通知预处理器number是下一行输入的行号。如果给出了可选部分\"string\"，预处理器就把它作为当前文件的名字。\n        \n        \n//#progma   语法因编译器而异\n```\n\n## 警告的总结\n\n1.不要在一个宏定义的末尾加上分号，使其称为一条完整的语句。\n\n2.在宏定义中使用参数，但忘了在它们周围加上括号。\n\n3.忘了在整个宏定义的两边加上括号。\n\n\n\n## 编程提示的总结\n\n1.避免用#define指令定义可以用函数实现的很长序列的代码。\n\n2.在那些对表达式求值的宏中，每个宏参数出现的地方都应该加上括号，并且在整个宏定义的两边也加上括号。\n\n3.避免使用#define宏创建一种新语言。\n\n4.采用命名约定，使程序员很容易看出某个标识符是否为#define宏。\n\n5.只要合适就应该使用文件包含，不必担心它的额外开销。\n\n6.头文件只应该包含一组函数和(或)数据的声明。\n\n7.把不同集合的声明分离到不同的头文件中可以改善信息隐藏。\n\n8.嵌套的#include文件使我们很难判断源文件之间的依赖关系。\n\n\n\n\n\n# 输入/输出函数\n\n## 错误报告\n\n```c\n//stdio.h\nvoid perror(char const *message);\n//如果message不是NULL并且指向一个非空的字符串，perror函数就打印出这个字符串，后面跟一个分号和一个空格，然后打印出一条用于解释errno当前错误代码的信息\n//只有当一个库函数失败时，errno才会被设置。因此，只有当被调用的函数提示有错误发生时检查errno的值才有意义\n```\n\n## 终止执行\n\n```c\n//stdlib.h\nvoid exit(int status);   //直接结束程序，status参数返回给操作系统，用于提示程序是否正常完成\n```\n\n## ANSI I/O概念\n\n### 流\n\nANSI C 中。所有的I/O操作只是简单地从程序移进或移出字节的事情。这种字节流被称为流。\n\n绝大多数流时完全缓冲的，这说明\"读取\"和\"写入\"实际上是从一块被称为缓冲区的内存区域来回复制数据。\n\n用于输出流的缓冲区只有当它写满是才会被刷新(flush, 物理写入)到设备或文件中。 一次性把写满的缓冲区写入和逐片把程序产生的输出分别写入相比效率更高。类似，输入缓冲区当它为空时通过从设备或文件读取下一块较大的输入，重新填充缓冲区。\n\n\n\n### 15.4.2文件\n\nstdio.h中定义了FILE结构，用于访问一个流。\n\n对于每个ANSI C程序，运行时必须提供至少三个流：标准输入(standard input)、标准输出(standard output)和标准错误(standard error)。这些流的名字分别为stdin、stdout、stderr，它们都是一个指向FILE结构的指针。\n\n### 15.4.3标准I/O常量\n\nFOPRN_MAX定义了至少能同时打开多少文件。\n\nFILENAME_MAX用于提示一个字符数组应该多大以便容纳编译器所支持的最长合法文件名\n\n\n\n## 流I/O总览\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2d2ae90eef6470295b8204d9d414ccc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/84428521ae904aadb5f267d295b0ef61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n## 打开流\n\n```c\nFILE *fopen(char const *name, char const *mode);\n//第一个参数是相关的文件名，第二个参数是提示流是用于只读、只写还是读写\n//每次调用这个函数时最好都检查一下它的返回值\nFILE *input;\ninput=fopen(\"data3\",\"r\");\nif(input==NULL){\n    perror(\"data3\");\n    exit(EXIT_FAILURE);\n}\n```\n\n|        | 读取 | 写入 | 添加 |\n| ------ | ---- | ---- | ---- |\n| 文本   | \"r\"  | \"w\"  | \"a\"  |\n| 二进制 | \"rb\" | \"wb\" | \"ab\" |\n\n```c\nFILE *freopen(char const *filename, char const *mode, FILE *stream);\n//这个函数首先试图关闭这个流，然后用指定的文件和模式重新打开这个流。如果打开失败，函数返回一个NULL值。反之，返回它的第3个参数值。\n```\n\n\n\n## 关闭流\n\n```c\nint fclose(FILE *f);\n//对于输出流，该函数在文件关闭之前刷新缓冲区。成功则返回零值，反之返回EOF\n```\n\n## 字符I/O\n\n\n\n```c\n//获取字符\nint fgetc(FILE *stream);\nint getc(FILE *stream);\nint getchar(void);\n\n//输出字符\nint fputc(int character, FILE *stream);\nint putc(int character, FILE *stream);\nint putchar(int cahracter);\n\n//撤销字符\nint ungetc(int character, FILE *stream);\n```\n\n\n\n```c\n//把一串从标准输入读取的数字转换为整数\n#include<stdio.h>\n#include<ctype.h>\nint read_int(){\n    int value=0;\n    int ch;\n    \n    //转换从标准输入读取的数字，当我们得到一个非数字字符时就停止\n    while((ch=getchar())!=EOF && isdigit(ch)){\n        value*=10;\n        value+=ch-'0';\n    }\n    //把非数字字符退回到流中，这样它就不会丢失\n    ugetc(ch,stdin);\n    return value;\n}\n\n//如果用fseek、fsetpos或rewind函数改变了流的位置，所有退回的字符都将被丢弃\n```\n\n## 未格式化的行I/O\n\n未格式化的I/O简单读取或写入字符。而格式化的I/O则执行数字和其他变量的内部和外部表示形式之间的转换。\n\n```c\n//把标准输入读取的文本行逐行复制到标准输出\n#include<stdio.h>\n#define MAX_LINE_LENGTH 1024\n\nvoid copylines(FILE *input. FILE *output){\n    char buffer[MAX_LINE_LENGTH];\n    \n    while(fgets(buffer,MAX_LINE_LENGTH,input)!=NULL)\n        fputs(buffer,output);\n}\n```\n\n\n\n## 格式化的行I/O\n\n## scanf族\n\n```c\nint fscanf(FILE *stream, char const *format,...);\nint scanf(char const *format,...);\nint sscanf(char const *string, char const *format,...);\n//这些函数都从输入源读取字符并根据format字符串给出的格式化代码对它们进行转换\n\n\n//使用例\nnfields=fscanf(input,\"%4d %4d %4d\",&a,&b,&c);\n//这个宽度参数把整数值的宽度限制为4个数字或更少。\n//输入 1  2 。  此时a=1,b=2,c不变,nfields=2.\n//输入 12345 67890。 此时a=1234,b=5,c=6789,nfields=3\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8611cd67cf44746a28ef2c17b832cb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n\n```c\n//用sscanf处理行定向(line-oriented)的输入\n#include<stdio.h>\n#define BUFFER_SIZE 100\n\nvoid function(FILE *input){\n    int a,b,c,d,e;\n    char buffer[BUFFER_SIZE];\n    \n    while(fgets(buffer,BUFFER_SIZE,input)!=NULL){\n        if(sscanf(buffer,\"%d %d %d %d %d\",\n                 &a,&b,&c,&d,&e)!=4){\n            \t\tfprintf(stderr,\"Bad input skipped: %s\",\n                            buffer);\n            \t\tcontinue;\n        }\n        //处理输入\n    }\n}\n```\n\n```c\n//使用sscanf处理可变格式的输入\n#include<stdio.h>\n#include<stdlib.h>\n\n#define DEFAULT_A 1\n#define DEFAULT_B 2\n\nvoid function(char *buffer){\n    int a,b,c;\n    //查看3个值是否都已经给出\n    if(sscanf(buffer,\"%d %d %d\",&a,&b,&c)!=3){\n        //否，对a使用缺省值，看看其他两个值是否已经给出\n        a=DEFAULT_A;\n        if(sscanf(buffer,\"%d %d\",&b,&c)!=2){\n            //为b使用缺省值，寻找剩余的值\n            b=DEFAULT_B;\n            if(sscanf(buffer,\"$d\",&c)!=1){\n                fprintf(stderr,\"Bad input: %s\",buffer);\n                exit(EXIT_FAILURE);\n            }\n        }\n    }\n    //处理a,b,c\n}\n```\n\n\n\n### 15.10.3 printf族\n\n```c\nint fprintf(FILE *stream, char const *format, ...);\nint printf(char const *format,...);\nint sprintf(char *buffer, char const *format,...);\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce890255007c49239b452f6495e403ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3970b1b5dd344867b55c9cafa3a215ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3e100005d3dd47909168b415fc412e1f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n## 二进制I/O\n\n```c\nsize_t fread(void *buffer, size_t size, size_t count, FILE *stream);\nsize_t fwrite(void *buffer, size_t size, size_t count, FILE *stream);\n//buffer时一个指向用于保存数据的内存位置的指针，size时缓冲区中每个元素的字节数，count时读取或写入的元素数\n```\n\n## 刷新和定位函数\n\n```c\nint fflush(FILE *stream);\n//该函数迫使输出流的缓冲区内的数据进行物理写入，不管它是否已满\n\n//随机访问I/O\nlong ftell(FILE *stream);//返回流当前的位置\nint fseek(FILE *stream, long offset, int from);//改变读写位置\n```\n\n\n\n| 如果from是... | 你将定位到                                                   |\n| ------------- | ------------------------------------------------------------ |\n| SEEK_SET      | 从流的起始位置起offset个字节，offset必须是一个非负值。       |\n| SEEK_CUR      | 从流的当前位置起offset个字节，offset可正可负。               |\n| SEEK_END      | 从流的尾部位置起offset个字节，offset可正可负。如果为正，它将定位到文件尾的后面 |\n\n```c\nvoid rewind(FILE *stream);\n//rewind将读/写指针设置回指定流的起始位置。同时清除流的错误提示信息\nint fgetpos(FILE *stream, fpos_t *position);\nint fsetpos(FILE *stream, fpos_t const *position);\n//后两个函数是rewind的替代方案\n```\n\n## 改变缓冲方式\n\n```c\nvoid setbuf(FILE* stream, char *buf);\n//setbuf设置了另一个数组，用于对流进行缓冲\nint setvbuf(FILE *stream,char *buf, int mode,size_t size);\n//mode参数用于指定缓冲的类型。_IOFBF指定一个完全缓冲的流，_IONBF指定一个不缓存的流，_IOLBF指定一个行缓冲流。\n```\n\n### 流错误函数\n\n```c\n//判断流的状态\nint feof(FILE *stream);\n//如果流当前处于文件尾，feof返回真。这个状态可以通过对流执行feseek、rewind或fsetpos函数来清除\n\nint ferror(FILE *stream);\n//ferror报告流的错误状态，如果出现任何读写错误就返回真\nvoid clearerr(FILE *stream);\n//clearerr对指定流的错误标志进行重置\n```\n\n## 临时文件\n\n```c\nFILE *tmpfile(void);\n//创建一个文件，当文件被关闭或程序终止时这个文件会自动删除\nchar *tmpnam(char *name);\n//给临时文件起名\n```\n\n## 文件操纵函数\n\n```c\nint remove(char const *filename);\n//删除一个指定文件\nint rename(char const *oldname, char const *newname);\n//重命名指定文件\n```\n\n\n\n## 警告的总结\n\n1.忘了在一条调试用的printf语句后跟一个fflush调用。\n\n2.不检查fopen函数的返回值。\n\n3.改变文件的位置将丢弃任何被退回到流的字符。\n\n4.在使用fgets时指定太小的缓冲区。\n\n5.使用gets的输入溢出缓冲区且违背检测到。\n\n6.使用任何scanf/printf系列函数时，格式代码和参数指针类型不匹配。\n\n7.在任何scanf系列函数的每个非数组、非指针参数前忘了加上&符号。\n\n8.注意在使用scanf系列函数转换double、long double、short和long整型时，在格式化代码中加上合适的限定符。\n\n9.sprintf函数的输出溢出了，且缓冲区未检测到。\n\n10.混淆printf和scanf格式代码。\n\n11.在有些长整数长于普通整数的机器上打印长整数值时，忘了在格式代码中指定l修改符。\n\n12.使用自动数组作为流的缓冲区时多加小心。\n\n\n\n## 编程提示总结\n\n1.在可能出现错误的场合，检查并报告错误。\n\n2.操纵文本行而无需顾及它们的外部表示形式，这有助于提高程序的可移植性。\n\n3.使用scanf限定符提高可移植性。\n\n4.当你打印长整数时，即使你所使用的机器并不重要，坚实使用l修改符可以提高可移植性。\n\n# 标准函数库\n\n按需学习，可以直接参考官方文档\n\n## 警告的总结\n\n1.忘了包含math.h头文件导致数学函数产生错误结果。\n\n2.clock函数可能只产生处理器时间的近似值。\n\n3.time函数的返回值并不一定是以秒为单位的。\n\n4.longjmp不能返回到一个已经不在处于活动状态的函数。\n\n5.避免exit函数的多重调用。\n\n\n\n## 编程提示总结\n\n1.滥用setjmp和longjmp可能导致晦涩难懂的代码。\n\n2.对信号进行处理将导致程序的可移植性变差。\n\n3.使用断言可以简化程序的调试。\n\n# 经典抽象数据类型\n\n## 堆栈\n\n### 接口\n\n```c\n//stack.h\n#define STACK_TYPE int  //堆栈存储的值的类型\n\n/*\npush\n把一个新值压入栈中\n*/\nvoid push(STACK_TYPE value);\n\n/*\npop\n弹出栈顶的值\n*/\nvoid pop(void);\n\n/*\ntop\n返回栈顶值\n*/\nSTACK_TYPE top(void);\n\n/*\nis_empty\n判断栈是否为空\n*/\nint is_empty(void);\n\n/*\nis_full\n判断栈是否已满\n*/\nint is_full(void);\n```\n\n\n\n### 17.1.1静态数组实现\n\n```c\n/*\n\t用一个静态数组实现堆栈，数组的长度只能通过修改#define定义\n\t并对模块重新进行编译实现\n*/\n\n#include\"stack.h\"\n#include<assert.h>\n\n#define STACK_SIZE 100   //栈的规模\n\n//存储栈中值得数组和一个指向栈顶元素得指针\nstatic STACK_TYPE stack[STACK_SIZE];\nstatic int    top_element=-1;\n\n//push\nvoid push(STACK_TYPE value){\n    assert(!is_full());\n    top_element+=1;\n    stack[top_element]=value;\n}\n\n//pop\nvoid pop(void){\n    assert(!is_empty());\n    top_element-=1;\n}\n\n//top\nSTACK_TYPE top(void){\n    assert(!is_empty());\n    return stack[top_element];\n}\n\n//is_empty\nint is_empty(void){\n    return top_element==-1;\n}\n\n//is_full\nint is_full(void){\n    return top_element==STACK_SIZE-1;\n}\n```\n\n### 17.1.2动态数组实现\n\n先在stack.h文件中加入以下接口\n\n```c\n/*\ncreate_stack\n创建堆栈，参数指定堆栈可以保存多少元素\n*/\nvoid create_stack(size_t size);\n\n/*\ndestory_stack\n销毁堆栈，释放内存\n*/\nvoid destory_stack(void);\n```\n\n\n\n```c\n/*\n一个用动态分配数组实现得堆栈\n堆栈的长度在创建时给出\n*/\n#include\"stack.h\"\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#include<assert.h>\n\n//用于存储栈元素的数组和指向堆栈顶部元素的指针\nstatic STACK_TYPE *stack;\nstatic size_t stack_size;\nstatic int top_element=-1;\n\n//create_stack\nvoid create_stack(size_t size){\n    assert(stack_size==0);\n    stack_size=size;\n    stack=malloc(stack_size*sizeof(STACK_TYPE));\n    assert(stack!=NULL);\n}\n\n//destory_stack\nvoid destory_stack(void){\n    assert(stack_size>0);\n    stack_size=0;\n    free(stack);\n    stack=NULL;\n}\n\n//push\nvoid push(STACK_TYPE value){\n    assert(!is_full());\n    top_element+=1;\n    stack[top_element]=value;\n}\n\n//pop\nvoid pop(void){\n    assert(!is_empty());\n    top_element-=1;\n}\n\n//top\nSTACK_TYPE top(void){\n    assert(!is_empty());\n    return stack[top_element];\n}\n\n//is_empty\nint is_empty(void){\n    return top_element==-1;\n}\n\n//is_full\nint is_full(void){\n    return top_element==stack_size-1;\n}\n```\n\n\n\n\n\n### 17.1.3链式堆栈\n\n```c\n//链表实现栈，这个栈没有长度限制\n#include\"stack.h\"\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#include<assert.h>\n\n#define FALSE 0\n\n//定义一个结构体来存储栈元素，next字段指向下一个元素\ntypedef struct STACK_NODE{\n    STACK_TYPE value;\n    struct STACK_NODE *next;\n}\n\nstatic StackNode *stack;\n\n\n//create_stack\nvoid create_stack(size_t size){\n}\n\n//destory_stack\nvoid destory_stack(void){\n    while(!is_empty()) pop();\n}\n\n//push\nvoid push(STACK_TYPE value){\n    StackNode *new_node;\n    \n    new_node=malloc(sizeof(StackNode));\n    assert(new_node!=NULL);\n    new_node->value=value;\n    new_node->next=stack;\n    stack=new_node;\n}\n\n//pop\nvoid pop(void){\n    StackNode *first_node;\n    \n    assert(!is_empty());\n    first_node=stack;\n    stack=first_node->next;\n    free(first_node);\n}\n\n//top\nSTACK_TYPE top(void){\n    assert(!is_empty());\n    return stack->value;\n}\n\n//is_empty\nint is_empty(void){\n    return stack==NULL;\n}\n\n//is_full\nint is_full(void){\n    return FALSE;\n}\n```\n\n\n\n## 队列\n\n### 接口\n\n```c\n//queue.h\n#include<stdlib.h>\n#define QUEUE_TYPE int //队列元素类型\n\n/*\ncreate_queue\n创建一个队列，参数指定队列最大容量\n*/\nvoid create_queue(size_t size);\n\n/*\ndestory_queue\n销毁一个队列\n*/\nvoid destory_queue(void);\n\n/*\ninsert\n向队列添加一个新元素\n*/\nvoid insert(QUEUE_TYPE value);\n\n/*\ndelete\n从队列中删除一个元素\n*/\nvoid delete(void);\n\n/*\nfirst\n返回队头\n*/\nQUEUE_TYPE first(void);\n\n/*\nis_empty\n判断队列是否为空\n*/\nint is_empty(void);\n\n/*\nis_full\n判断队列是否已满\n*/\nint is_full(void);\n```\n\n\n\n### 静态数组实现\n\n```c\n//用静态数组实现队列\n\n#include \"queue.h\"\n#include<stdio.h>\n#include<assert.h>\n\n#define QUEUE_SIZE 100 //队列中元素的最大数量\n#define ARRAY_SIZE (QUEUE_SIZE + 1) //数组长度\n\n//存储队里了元素的数组和指向队列头和尾的指针\nstatic QUEUE_TYPE queue{ARRAY_SIZE};\nstatic size_t front=1;\nstatic size_t rear=0;\n\n//insert\nvoid insert(QUEUE_TYPE value){\n    assert(!is_full());\n    rear=(rear+1)%ARRAY_SIZE;\n    queue[rear]=value;\n}\n\n//delete\nvoid delete(void){\n    assert(!is_empty());\n    front=(front+1)%ARRAY_SIZE;\n}\n\n//first\nQUEUE_TYPE first(void){\n    assert(!is_empty());\n    return queue[front];\n}\n\n//is_empty\nint is_empty(void){\n    return (rear+1)%ARRAY_SIZE==front;\n}\n\n//is_full\nint is_full(void){\n    return (rear+2)%ARRAY_SIZE==front;\n}\n```\n\n\n\n## 树\n\n### 接口\n\n```c\n//tree.h\n#define TREE_TYPE int  //树的值类型\n\n/*\ninsert\n向树添加一个值，这个值原先不存在树中\n*/\nvoid insert(TREE_TYPE value);\n\n/*\nfind\n查找一个特定的值\n*/\nTREE_TYPE *find(TREE_TYPE value);\n\n/*\npre_order_traverse\n先序遍历\n*/\nvoid pre_order_traverse(void (*callback)(TREE_TYPE value));\n```\n\n\n\n## 静态数组实现\n\n```c\n//静态数组实现二叉搜索树\n#include \"tree.h\"\n#include<assert.h>\n#include<stdio.h>\n\n#define TREE_SIZE 100  //树的规模\n#define ARRAY_SIZE  (TREE_SIZE+1)\n\n//用于存储树所有节点的数组\nstatic TREE_TYPE tree[ARRAY_SIZE];\n\n/*\nleft_child\n计算一个节点左孩子的下标\n*/\nstatic int left_child(int current){\n    return current*2;\n}\n\n/*\nright_child\n计算一个节点右孩子的下标\n*/\nstatic int right_child(int current){\n    return current*2+1;\n}\n\n//insert\nvoid insert(TREE_TYPE value){\n    int current;\n    //从根节点开始，直到找到那个值，进入合适的子树\n    current=1;\n    \n    while(tree[current]!=0){\n        //根据情况，进入左子树或右子树(确信未出现重复的值)\n        if(value<tree[current])\n            current=left_child(current);\n        else{\n            assert(value!=tree[current]);\n            current=right_child(current);\n        }\n        assert(current<ARRAY_SIZE);\n    }\n    tree[current]=value;\n}\n\n//find\nTREE_TYPE *find(TREE_TYPE value){\n    int current;\n    //确保值非零，因为零用于提示一个未使用的节点\n    assert(value!=0);\n    \n    //从根节点开始\n    current=1;\n    \n    //从合适的子树开始，直到到达一个叶节点\n    while(current<ARRAY_SIZE && tree[current]!=value){\n        //根据情况，进入左子树或右子树\n        if(value<tree[current])\n            current=left_child(current);\n        else\n            current=right_child(current);\n    }\n    if(current<ARRAY_SIZE) return tree+current;\n    else return 0;\n}\n\n\n/*\ndo_pre_order_traverse\n执行一层先序遍历，这个辅助函数用于保存我们当前正在处理的节点信息\n*/\nstatic void do_pre_order_traverse(int current,\n                   void (*callback)(TREE_TYPE value))\n{\n    if(current<ARRAY_SIZE && tree[current]!=0){\n        callback(tree[current]);\n        do_pre_order_traverse(left_child(current),callback);\n        do_pre_order_traverse(right_child(current),callback);\n    }\n}\n\n//pre_order_traverse\nvoid pre_order_traverse(void (*callback)(TREE_TYPE value)){\n     do_pre_order_traverse(1,callback);\n}\n```\n\n\n\n### 链表实现\n\n```c\n//链表实现树\n#include \"tree.h\"\n#include<assert.h>\n#include<stdio.h>\n#include<malloc.h>\n\n//TreeNode结构包含了值和两个指向某个树节点的指针\ntypedef struct TREE_NODE{\n    TREE_TYPE value;\n    struct TREE_NODE *left;\n    struct TREE_NODE *right;\n}TreeNode;\n\n//指向树根节点的指针\nstatic TreeNode *tree;\n\n//insert\nvoid insert(TREE_TYPE value){\n    TreeNode *current;\n    TreeNode **link;\n    \n    //从根节点开始\n    link=&tree;\n    //持续查找值，进入合适的子树\n    while((current=*link)!=NULL){\n        //根据情况，进入左子树或右子树(确认无重复值)\n        if(value<current->value) link=&current->left;\n        else{\n            assert(value!=current->value);\n            link=&current->right;\n        }\n    }\n    \n    //分配一个新节点，使适当节点的link字段指向它\n    current=malloc(sizeof(TreeNode));\n    assert(current!=NULL);\n    current->value=value;\n    current->left=NULL;\n    current->right=NULL;\n    *link=current;\n}\n\n//find\nTREE_TYPE *find(TREE_TYPE value){\n    TreeNode *current;\n    \n    //从根节点开始\n    current=tree;\n    \n    //从合适的子树开始，直到到达一个叶节点\n    while(current!=NULL && current->value!=value){\n        //根据情况，进入左子树或右子树\n        if(value<current->value)\n            current=current->left;\n        else\n            current=current->right;\n    }\n    if(current!=NULL) return &current->value;\n    else return NULL;\n}\n\n/*\ndo_pre_order_traverse\n执行一层先序遍历，这个辅助函数用于保存我们当前正在处理的节点信息\n*/\nstatic void do_pre_order_traverse(TreeNode *current,\n                   void (*callback)(TREE_TYPE value))\n{\n    if(current!=NULL){\n        callback(tree[current]);\n        do_pre_order_traverse(current->left,callback);\n        do_pre_order_traverse(current->right,callback);\n    }\n}\n\n//pre_order_traverse\nvoid pre_order_traverse(void (*callback)(TREE_TYPE value)){\n     do_pre_order_traverse(tree,callback);\n}\n```\n\n\n\n## 实现的改进\n\n1.有时可能会拥有超过一个的堆栈。\n\n可以从堆栈的实现模块中取出数组和top_element的声明，并把它们放入用户代码。\n\n然后，它们通过参数被堆栈函数访问，这些函数便不再固定于某个数组。缺点是这样会丢失封装性，造成非法访问。\n\n2.拥有超过一个类型\n\n有时可能同时需要一个整型栈和一个浮点型栈。\n\n可以把整个堆栈模块实现为一个#define宏，把目标类型作为参数。\n\n还可以让它存储void* 类型的值，绕过类型检查。但是很容易出错。如：一个整数被压入一个元素类型为指针的栈中。\n\n可以设计一个泛型ADT。\n\n3.名字冲突\n\n\n\n## 警告的总结\n\n1.不要使用断言检查内存是否分配成功。\n\n2.数组形式的二叉树节点位置计算公式假定数组的下标从1开始。\n\n3.把数据封装于对它进行操纵的模块可以防止用户不正确地访问数据。\n\n4.与类型无关地函数没有类型检查，所以要确保传递正确类型地数据。\n\n\n\n## 编程提示的总结\n\n1.避免使用具有副作用的函数。\n\n2.一个模块的接口应该避免暴露它的实现细节。\n\n3.将数据类型参数化，使它容易修改。\n\n4.只有模块对外公布的接口才应该使公用的。\n\n5.使用断言来防止非法操作。\n\n6.几个不同的实现使用同一个接口使模块具有更强的可互换性。\n\n7.服用现有的代码而不是对它进行改写。\n\n8.迭代比尾部递归效率更高。\n\n\n\n\n\n# 运行时环境\n\n不同机器生成的汇编代码可能会有所不同\n\n## 判断运行时环境\n\n### 静态变量和初始化\n\n```c\n//静态初始化\nint static_variable=5;\n.data\n.enen\n.global _static_variable\n_static_variable:\n.long   5\n```\n\n汇编代码的一开始是两个指令，分别表示进入程序的数据区以及确保变量开始于内存的偶数地址。变量被声明为全局类型，变量名以一个下划线开始。许多C编译器会在C代码所声明的外部名字前加一个下划线，以免与各个库函数所使用的名字冲突。\n\n最后，编译器为变量创建控件，并用适当的值对它进行初始化。\n\n\n\n### 堆栈帧\n\n函数分为三部分：函数序(prologue)、函数体(body)、函数跋(epilogue)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/db2f96e630c148169779ddc511216786.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n第一条指令( .text )表示进入程序的代码段。为函数创建堆栈帧，堆栈帧是堆栈中的一个区域，里面存入函数的变量和其他值。\n\n.globl是函数的全局声明\n\n0x3cfc表示寄存器d2到d7、a2到a5中的值需要被存储。（存入堆栈帧）\n\n### 18.1.4寄存器变量\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d2a82b2a7f504abc88437639c2cb81eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1-6存在了一个寄存器中，7-10存到了其他地方。说明最多只能有6个整型值可以被存放在数据寄存器。\n\n\n\n机器使用的地址模型执行间接寻址和索引操作。这种组合工作颇似数组的下标引用。\n\n寄存器a6称为帧指针(frame pointer)，它指向堆栈帧内部的一个\"引用\"位置。a6@(-28)指定了一个偏移地址-28。这个偏移位置从-4开始，每次增长4。（整型值和指针都占4个字节）\n\n\n\n### 18.1.5外部标识符的长度\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6ab22148f9ee4e28a7fa35b920343256.png#pic_center)\n\n\n变量名的长度一般没有限制\n\n### 18.1.6判断堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fb7d25fa4e5e4615862230aca047673e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n前三条指令把函数的参数压入堆栈。被压入的第1个参数存储于a6@(-16)，包含变量i10。然后被压入的是d7，包含变量i1。\n\npea指令简单地把它的操作数压入堆栈。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/730bfba5a8dc42a38bf815edab84884a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\njbsr是跳转子程序(jump subroutine)。它把返回地址压入堆栈，并跳转到_func_ret_int 的起始位置。当被调用函数结束仍无后需要返回到它的调用位置，就要用到这个压入到堆栈中的返回地址。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/99b65c51a0ef4130a84448c6c75d781f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n#### 函数序\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5ac4b52f193c4188b3db5824c5353e2e.png#pic_center)\n\n\n首先，a6的内容被压入栈中。其次，堆栈指针的当前值被复制到a6\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/043db02c1e054d2ea966ba6d159c7580.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n最后，link指令从堆栈指针中-8。这将会创建空间用于保存局部变量和被保存的寄存器值。\n\n下一条指令把一个单一的寄存器保存到堆栈帧。 0x80指定寄存器d7。寄存器存储在堆栈的顶部，它提示堆栈帧的顶部就是寄存器值保存的位置。堆栈帧剩余的部分必然是局部变量存储的地方。\n\n最后(mov指令) 从堆栈复制一个值到d7。\n\n#### 堆栈中的参数顺序\n\n被调用函数使用帧指针加一个偏移量来访问参数。当参数以反序压入到堆栈时，参数列表的第1个参数便位于堆栈中这些参数的顶部，它距离帧指针的偏移量是个常数。\n\n#### 最终的堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/52bb66a4548f40978f535a6a1317dae3.png#pic_center)\n\n\n第1条movl指令是把第2个参数复制到d0。下一条指令将这个值-6，第3条指令把结果存入局部变量d。d0的作用是计算过程中的\"中间结果暂存器\"。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/12fec6e95363444a881c7027a10e6cb3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n接下来的3条指令对return语句进行求值。结果存入d0。\n\n#### 函数跋\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/919b5628fb194e1ba03ae5ff4b123b53.png#pic_center)\n\n\n当返回到调用程序之后执行的第1条指令就是把12加到堆栈指针。这个假发能把参数值从堆栈中取出。\n\n#### 返回值\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9654fe42346a4a63acca44981026d35a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n这个函数没有参数，所以没有东西压入堆栈。这个函数返回后，d0和d1的值都被保存。double的长度为8，返回需要同时用到d0和d1。\n\n## C和汇编语言的接口\n\n#### 汇编语言程序调用C\n\n1.如果寄存器d0、d1、a0、a1保存了重要的值，它们必须在调用C之前进行保存，因为C不会保存它们的值。\n\n2.任何函数的参数必须以参数列表相反的顺序压入到堆栈中。\n\n3.函数必须由一条\"跳转子程序\"类型的指令调用，它会把返回地址压入堆栈。\n\n4.当C函数返回时，汇编程序必须清楚堆栈中的任何参数。\n\n5.如果汇编程序期望接受一个返回值，它将保存在d0。\n\n6.任何在调用之前进行过保存的寄存器此时可以恢复。\n\n#### C调用汇编程序\n\n1.保存任何你希望修改的寄存器(除了d0、d1、a0、a1)。\n\n2.参数值从堆栈中获得，因为调用它的C函数把参数压入堆栈。\n\n3.如果函数应该返回一个值，它的值应保存在d0中。\n\n4.返回之前，函数必须清楚任何它压入堆栈中的内容。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1ff9747cc8be4bbe8b8291962bce0a20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## 运行时效率\n\n虚拟内存：由操作系统实现，它在需要时把程序的活动部分放入内存并把不活动的部分复制到磁盘中，这样就允许运行大型的程序。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e37be83bd52343fb98135df9cfd84cbe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1.在耗费时间最多的函数中，有些是库函数。\n\n2.有些函数之所以耗费了大量的实践是因为它们被调用的次数多。\n\n3.有些函数调用的次数并不多，但是每次调用所花费的时间很长。\n\n## 警告的总结\n\n1.决定 外部标识符最大长度 的是链接器而不是编译器。\n\n2.你无法链接由不同编译器产生的程序。\n\n\n\n## 编程提示总结\n\n1.使用stdarg实现可变参数列表。\n\n2.改进算法比优化代码更有效率。\n\n3.使用某种环境特有的技巧会导致程序不可移植。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n否分配成功。\n\n2.数组形式的二叉树节点位置计算公式假定数组的下标从1开始。\n\n3.把数据封装于对它进行操纵的模块可以防止用户不正确地访问数据。\n\n4.与类型无关地函数没有类型检查，所以要确保传递正确类型地数据。\n\n\n\n## 编程提示的总结\n\n1.避免使用具有副作用的函数。\n\n2.一个模块的接口应该避免暴露它的实现细节。\n\n3.将数据类型参数化，使它容易修改。\n\n4.只有模块对外公布的接口才应该使公用的。\n\n5.使用断言来防止非法操作。\n\n6.几个不同的实现使用同一个接口使模块具有更强的可互换性。\n\n7.服用现有的代码而不是对它进行改写。\n\n8.迭代比尾部递归效率更高。\n\n\n\n\n\n# 运行时环境\n\n不同机器生成的汇编代码可能会有所不同\n\n## 判断运行时环境\n\n### 静态变量和初始化\n\n```c\n//静态初始化\nint static_variable=5;\n.data\n.enen\n.global _static_variable\n_static_variable:\n.long   5\n```\n\n汇编代码的一开始是两个指令，分别表示进入程序的数据区以及确保变量开始于内存的偶数地址。变量被声明为全局类型，变量名以一个下划线开始。许多C编译器会在C代码所声明的外部名字前加一个下划线，以免与各个库函数所使用的名字冲突。\n\n最后，编译器为变量创建控件，并用适当的值对它进行初始化。\n\n\n\n### 堆栈帧\n\n函数分为三部分：函数序(prologue)、函数体(body)、函数跋(epilogue)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2821c6aa3864495791b72057f087b08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n第一条指令( .text )表示进入程序的代码段。为函数创建堆栈帧，堆栈帧是堆栈中的一个区域，里面存入函数的变量和其他值。\n\n.globl是函数的全局声明\n\n0x3cfc表示寄存器d2到d7、a2到a5中的值需要被存储。（存入堆栈帧）\n\n### 寄存器变量\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91d4c46bcdf04c4382c6cd44d28c9ead.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1-6存在了一个寄存器中，7-10存到了其他地方。说明最多只能有6个整型值可以被存放在数据寄存器。\n\n\n\n机器使用的地址模型执行间接寻址和索引操作。这种组合工作颇似数组的下标引用。\n\n寄存器a6称为帧指针(frame pointer)，它指向堆栈帧内部的一个\"引用\"位置。a6@(-28)指定了一个偏移地址-28。这个偏移位置从-4开始，每次增长4。（整型值和指针都占4个字节）\n\n\n\n### 外部标识符的长度\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c093e565c3484953ad4965fdb9222588.png#pic_center)\n\n\n变量名的长度一般没有限制\n\n### 判断堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1e80fada00484e358a581858795fb5a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n前三条指令把函数的参数压入堆栈。被压入的第1个参数存储于a6@(-16)，包含变量i10。然后被压入的是d7，包含变量i1。\n\npea指令简单地把它的操作数压入堆栈。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e00c8110b6694d6dba6cd16a19166a59.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\njbsr是跳转子程序(jump subroutine)。它把返回地址压入堆栈，并跳转到_func_ret_int 的起始位置。当被调用函数结束仍无后需要返回到它的调用位置，就要用到这个压入到堆栈中的返回地址。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0693fbee23b54c8997d538cd88024f3d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n#### 函数序\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2e09d26d1a3a4db288e5003b709e2472.png#pic_center)\n\n\n首先，a6的内容被压入栈中。其次，堆栈指针的当前值被复制到a6\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94e767c9ad394c60bac01cd603ed4fef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n最后，link指令从堆栈指针中-8。这将会创建空间用于保存局部变量和被保存的寄存器值。\n\n下一条指令把一个单一的寄存器保存到堆栈帧。 0x80指定寄存器d7。寄存器存储在堆栈的顶部，它提示堆栈帧的顶部就是寄存器值保存的位置。堆栈帧剩余的部分必然是局部变量存储的地方。\n\n最后(mov指令) 从堆栈复制一个值到d7。\n\n#### 堆栈中的参数顺序\n\n被调用函数使用帧指针加一个偏移量来访问参数。当参数以反序压入到堆栈时，参数列表的第1个参数便位于堆栈中这些参数的顶部，它距离帧指针的偏移量是个常数。\n\n#### 最终的堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6de3b4d9b2ab40f6a9421be75d865ecb.png#pic_center)\n\n\n第1条movl指令是把第2个参数复制到d0。下一条指令将这个值-6，第3条指令把结果存入局部变量d。d0的作用是计算过程中的\"中间结果暂存器\"。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3f218f778f544eca67a8bf5d75ab033.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n接下来的3条指令对return语句进行求值。结果存入d0。\n\n#### 函数跋\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/736bffced19a4aaa944fe163ed7dd513.png#pic_center)\n\n\n当返回到调用程序之后执行的第1条指令就是把12加到堆栈指针。这个假发能把参数值从堆栈中取出。\n\n#### 返回值\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cb1b6504bd204711aea8f2a7823ee5c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n这个函数没有参数，所以没有东西压入堆栈。这个函数返回后，d0和d1的值都被保存。double的长度为8，返回需要同时用到d0和d1。\n\n## C和汇编语言的接口\n\n#### 汇编语言程序调用C\n\n1.如果寄存器d0、d1、a0、a1保存了重要的值，它们必须在调用C之前进行保存，因为C不会保存它们的值。\n\n2.任何函数的参数必须以参数列表相反的顺序压入到堆栈中。\n\n3.函数必须由一条\"跳转子程序\"类型的指令调用，它会把返回地址压入堆栈。\n\n4.当C函数返回时，汇编程序必须清楚堆栈中的任何参数。\n\n5.如果汇编程序期望接受一个返回值，它将保存在d0。\n\n6.任何在调用之前进行过保存的寄存器此时可以恢复。\n\n#### C调用汇编程序\n\n1.保存任何你希望修改的寄存器(除了d0、d1、a0、a1)。\n\n2.参数值从堆栈中获得，因为调用它的C函数把参数压入堆栈。\n\n3.如果函数应该返回一个值，它的值应保存在d0中。\n\n4.返回之前，函数必须清楚任何它压入堆栈中的内容。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0358630ffc9b4ce391b0488aaecab8d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 运行时效率\n\n虚拟内存：由操作系统实现，它在需要时把程序的活动部分放入内存并把不活动的部分复制到磁盘中，这样就允许运行大型的程序。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8b46ef0f59044d3992c2410bb6ca2170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1.在耗费时间最多的函数中，有些是库函数。\n\n2.有些函数之所以耗费了大量的实践是因为它们被调用的次数多。\n\n3.有些函数调用的次数并不多，但是每次调用所花费的时间很长。\n\n## 警告的总结\n\n1.决定 外部标识符最大长度 的是链接器而不是编译器。\n\n2.你无法链接由不同编译器产生的程序。\n\n\n\n## 编程提示总结\n\n1.使用stdarg实现可变参数列表。\n\n2.改进算法比优化代码更有效率。\n\n3.使用某种环境特有的技巧会导致程序不可移植。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":[],"tags":["C/C++"]},{"title":"MySQL80 操作要点笔记","url":"/posts/26678/","content":"\n\n# 前言\n\n参考视频：BV1Vy4y1z7EX\n\nCSDN: https://blog.csdn.net/INFINITE_WAR/article/details/120408155\n\n一些频繁出现的用例名字：\nemp  员工信息表\ndept  部门信息表\nename  员工名\njob  工作\nsal  工资\ndeptno  部门编号\n\n# 开始\n\nSQL现为手动模式（cmd操作，要管理员模式）\n\n```sql\nnet start MySQL80  //打开MySQL80服务\nnet stop MySQL80   //关闭\t\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/21fd39ea59774c04b87944f482587c35.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16)\n![请添加图片描述](https://img-blog.csdnimg.cn/c98d0c774349457a895089d75fd2664e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16)\n需要提前注册mysql账号\n\n\nxxxx.sql   为sql脚本文件，里面编写了大量的sql语句，在mysql中使用命令‘source   (文件路径)’ 即可执行脚本文件里的所有语句。\n\n开始会有一个基础数据库databases，里面嵌套着其他数据库。\n\nmysql> show databases;\n+-----------------------------+\n| Database                    |\n+-----------------------------+\n| first_database             |              //自己测试用的表在这里。也可以另行开辟\n| information_schema   |\n| mysql                          |\n| performance_schema|\n| sakila                          |\n| sys                              |\n| world                           |\n+-----------------------------+\n7 rows in set (0.00 sec)\n\n通过 ‘use （数据库名）’可以打开指定数据库，可以在该数据库中建立表并继续操作。\n\n打开first_database后使用show tables 命令显示所有的表。\n\nmysql> show tables;\n+--------------------------+\n| Tables_in_first_database |\n+--------------------------+\n| score                    |\n| student                  |\n| tab1                     |\n+--------------------------+\n3 rows in set (0.00 sec)\n\nstudent的创建：\n\nmysql> CREATE  TABLE  student (\n    -> id  INT(10)  NOT NULL  UNIQUE  PRIMARY KEY  ,\n    -> name  VARCHAR(20)  NOT NULL ,\n    -> sex  VARCHAR(4)  ,\n    -> birth  YEAR,\n    -> department  VARCHAR(20) ,\n    -> address  VARCHAR(50)\n    -> );\nQuery OK, 0 rows affected, 1 warning (0.07 sec)\n\nscore的创建：\nmysql> CREATE  TABLE  score (\n    -> id  INT(10)  NOT NULL  UNIQUE  PRIMARY KEY  AUTO_INCREMENT ,\n    -> stu_id  INT(10)  NOT NULL ,\n    -> c_name  VARCHAR(20) ,\n    -> grade  INT(10)\n    -> );\n\n# 基本命令\n\n## part1\n\n(命令不区分大小写)\n\nexit//退出\n\n==（以下命令要分号结尾，否则会出现无限的“-->”符号让你输入）==\n\nshow databases;   //显示已有的数据库。 mysql默认自带了**4**个数据库。\n\nuse (数据库名);        //表示正在使用对应的数据库\n\ncreate database （数据库名）;  //建立一个新的数据库\n\nshow tables;           //查看**某个**数据库下有哪些表\n\n## part2\n\nselect version();   //查看当前mysql版本号\n\nrowback    //撤销一步\n\n\\c   //强制停止当前语句（可以跳出“-->”死循环）\n\n# SQL语句分类\n\n## DOL\n\n数据库查询语言(凡是带有select关键字的都是查询语句)\n\nselect .....;\n\n==注：select本身是不会对原本的数据库进行修改操作的。==\n\n## DML\n\n数据库操作语言(凡是对表当中的数据进行增删改的都是DML)\n\ninsert(增) \n\ndelete(删) \n\nupdate(改)\n\n注DML主要操作的是<u>表中的数据</u>\n\n## DDL\n\n数据定义语言(凡是带有create、drop、alter的都是DDL)\n\n注：DDL主要操作的是<u>表的结构</u>，而不是表中的数据。\n\ncreate:新建\n\ndrop:删除\n\nalter：修改\n\n## TCL\n\n事务控制语言\n\ncommit;   //事务提交\n\nrollback;  //事务回报\n\n## DCL\n\n数据控制语言\n\ngrant;     //授权\n\nrevoke;\t//撤销权限\n\n# 导入数据\n\nmysql> source  路径+文件名\n\n注：路径不能用中文\n\n查看表中数据： select * from 表名；\n\n查看表的结构：desc 表名;        //<---desc是describe的缩写，可以用原词作命令\n\n# 查询(单表查询part1)\n\n## 查询一个字段\n\nselect 字段名 from 表名;           //select 和from都是关键字，字段名和表名都是标识符\n\n## 查询多个字段\n\nselect 字段名1，字段名2，....，字段名n   from   表名;\n\n## 查询所有字段\n\n方法一，把所有字段都写上：\n\n​\t\tselect 字段名1，字段名2，....，字段名n   from   表名;\n\n方法二，使用*：   //缺点：效率低，可读性差\n\n​\t\tselect  *   from   表名;      //回想一下查看表中数据的命令\n\n## 查询所有字段并去重\n\nselect    ==distinct==   字段名   from   表名     //distinct关键字必须出现在所有字段名之前\n\n## 给查询的列起别名\n\nselect   (字段名  as  自定义新字段名)   from 表名;     \n\n//只是修改名字后显示出来，原本的数据库没有改变。\n\n//若字段名有空格，要以  **‘新字段名’**  的形式写入命令（字符串统一使用单引号）。as可以用空格代替。\n\n可以对字段使用数学表达式，例如：\n\n​\t\tselect  name ,  <u>score*12</u>  from student;       //可以用  as  给score*12换名\n\n会显示：\n\n+----------------------+-----------------------+\n\n​     name              |        score*12\n\n+----------------------+-----------------------+\n\n|      .................        .......................   |\n\n## 条件查询\n\n### 关系运算符\n\n|          =           |              等于               |\n| :------------------: | :-----------------------------: |\n|       <> 或 !=       |             不等于              |\n|     <、<=、>、>=     |         小(大)(等)于，          |\n| between (a)  and (b) |          >=a   && <=b           |\n|       is null        |              为空               |\n|         and          |               与                |\n|          or          |               或                |\n|          in          |        包含,相当于多个or        |\n|         not          |               非                |\n|         like         | 模糊查询，支持 % 或 下划线 匹配 |\n|          %           |          匹配任意字符           |\n|     下划线（_）      |          匹配一个字符           |\n\n### 条件查询语法格式\n\n（为了直观，句子将不写在一行里）\n\n```sql\nselect \n\n      字段1，字段2，字段3  ......\n\nfrom\n\n      表名\n\nwhere\n\n​      条件;\n```\n\n\n\n###  比较不熟悉的关系运算符\n\n####   in    的用法\n\n例：筛选出工资为5000 或 6000 或 7000的所有员工\n```sql\n不用in：select     num , name , job  from  tab1 \n\n​\t\t\twhere  wage=5000  or  wage=6000   or  wage=7000;\n\n使用in: select     num , name , job  from  tab1 \n\n​\t\t\twhere  wage  in  (5000,6000,7000);\n```\n\n####  like   的用法\n\n例：\n```sql \nselect  name  from  table  where   name  like   \"%A%\";\n```\n\n筛选出姓名中含有“A”的姓名。\n\n\n\n其他例：\n```sql\n\n找出名字以T结尾的：\n\n​\t\tselect  name  from  table  where   name  like   \"%T\";\n\n找出名字以K开始的：\n\n​\t\tselect  name  from  table  where   name  like   \"K%\";\n\n找出第二个字母是A的：\n\n​\t\tselect  name  from  table  where   name  like   \"_A%\";\n\n找出第三个字母是R的：\n\n​\t\tselect  name  from  table  where   name  like   \"__R%\";\n\n```\n\n==从上例可以看出，所谓的模糊查找本质上和正则表达式匹配类似。==\n\n\n\n\n\n# 排序(单表查询part2)\n\n## 语法\n\n```sql\n\n​select \n\n​\t\t字段名1，字段名2.......\n\n​from\n\n​\t\t表名\n\n​order by\n\n​\t\t指定字段名  ；    //==默认升序==\n```\n\n指定降序，则要写成       指定字段名\tdesc   ;\t\n\n指定升序，则要写成       指定字段名\tasc   ;\t\n\n## 多字段排序\n\n```sql\n\nselect \n\n​\t\t字段名1，字段名2.......\n\n​from\n\n​\t\t表名\n\n​order by\n\n​\t\t指定字段名1   （指定顺序）  ，指定字段名2  （指定顺序），......  ；\n```\n<u>从左到右优先排序</u>；\n\n## 根据字段位置排序\n\n```sql\nselect    name   from   table   order  by    2\n```\n(指定字段名所在的列数，例句中指定第二列的字段) ;\n\n## 综合案例\n\n找出工资在1250和3000之间的员工信息，要求按照薪资降序排列。\n```sql\n\nselect  \n\n​\t\tename ,sal\n\nfrom\n\n​\t\temp\n\nwhere\n\n​\t\tsal  between  1250  and  3000\n\norder by\n\n​\t\tsal  desc  ; \n```\n语句执行顺序：\n\n​\t\tstep1：from\n\n​\t\tstep2：where\n\n​\t\tstep3：select\n\n​\t\tstep4：order  by\n\n\n\n\n\n# 数据处理函数(单表查询part3)\n\n## 单行处理函数\n\n特点：输入一行，输出一行。\n\n| lower/upper |     转换成小(大)写     |\n|-------------|----------------------|\n|   substr    |         取子串         |\n|   length    |         取长度         |\n| trim(字符串)   |         去空格         |\n| str_to_date |   将字符串转换成日期   |\n| date_format |       格式化日期       |\n|    round(数值，保留几位小数(-1是保留到十位))    |        四舍五入        |\n|   rand()   (直接使用会生成[0,1)的随机数)   |       生成随机数       |\n| ifnull(数据，该数据的null情况用什么值取代) | 将null转换成一个具体值 |\n| concat(字符串1，字符串2) | 连接两个字符串 |\n\n```sql\n用法：select    函数名(参数1，参数2，......)   as   自定义列名     from   表名;\n```\n\n注：null加上数值的结果还是null，故要使用ifnull修改最初的null值。\n\n**分支处理**(类似于编程里的if else语句)：\n\n例：当员工的工作岗位时MANAGER时，工资上调10%；当工作岗位时SALESMAN时，工资上调50%；其他不变。\n```sql\nselect\n\n​\t\tename , job ,\n\n​\t\t==(case  job  when   'MANAGER'   then  sal * 1.1     when    'SALESMAN'    then   sal * 1.5  else sal  end )   as  newsal==\n\n​from \n\n​\t\temp;\n```\n\n\n\n## 多行处理函数(分组函数)\n\n特点：输入多行，输出一行。\n\n| count(字段名) | 计数   |\n| ------------- | ------ |\n| sum(字段名)   | 求和   |\n| avg(字段名)   | 平均值 |\n| max(字段名)   | 最大值 |\n| min(字段名)   | 最小值 |\n\n注：1.分组函数在使用的时候必须先进行分组，然后使用。\n\n2.如果没有对数据进行分组，整张表默认为一组。\n\n3.==分组函数会自动处理null值。==\n\n4.count(具体字段)：表示统计该字段下所有不为null的元素的个数。\n\n   count(*):统计表当中的总行数。\n\n5.分组函数<u>不能</u>中介用在 where 语句中。\n\n\n\n# 分组查询(单表查询part4)\n\n实际需求：先分组，再对每一组的数据进行操作。\n\n例：计算每个部门的工资和\n\n计算每个工作岗位的平均薪资\n\n找出每个工作岗位的最高薪资\n\n## 语法\n```sql\nselect             //==若有 group   by，则应该只能写group  by   后面跟着的字段名==,或分组函数\n\n​\t\t.....\n\nfrom\n\n​\t\t.....\n\n(where  .....)\n\ngroup  by       //后面只能跟  参加分组的字段，以及分组函数\n\n​\t\t（字段名）.....\n\n(having......)    //作用和where 差不多，但是必须接在group  by后面\n\n(order by .....)\n```\n\n执行顺序：\n\nfrom  -->  where  -->  group by  -->  select  -->  order by \n\n\n\n例：找出<u>每个部门、不同岗位</u>的最高薪资\n```sql\nselect\n\n​\t\tdeptno,job,max(sal)\n\nfrom\n\n​\t\temp\n\ngroup by\n\n​\t\tdeptno  ,  job;\n```\n\n==综合案例：==\n\n找出每个岗位的平均薪资，要求平均薪资大于1500的，除MANAGER岗位之外，要求按照平均薪资降序排序。\n```sql\nselect\n\n​\t\tjob  ,  avg(sal)  as  avgsal\n\nfrom\n\n​\t\temp\n\nwhere\n\n​\t\tjob  !=  'MANAGER'\n\ngroup by\n\n​\t\tjob\n\nhaving\n\n​\t\tavg(sal)  >  1500\n\norder by\n\n​\t\tavgsal  desc;\n```\n\n# 连接查询\n\n**注：可以先去了解一下关系数据库的连接运算**。\n\n连接查询的<u>目的</u>：多张表联合起来查询数据。\n\n连接的底层原理是<u>笛卡尔积</u>。若连接查询不附带任何注释，则会返回一个数据库字段之间笛卡尔积的结果。\n\n简单案例：查询每一个人所在的工作部门。\n\n//SQL92的解法\n```sql\n\nselect   \n\n​\t\te.ename  ,  d.dname        //最好将字段所属的表名通过这种方式标出\n\nfrom\n\n​\t\temp  e,  dept  d            //表名空格后面为别名。\n\nwhere\n\n​\t    emp.deptno  =  dept.deptno  ;          //表的连接条件，通过and可以写入进一步的过滤条件\n````\n\n## 内连接\n\n### 等值连接\n\n上例SQL99的语法\n```sql\n\nselect\n\n​\t\te.ename  ,  d.dname\n\nfrom\n\n​\t\temp e\n\njoin\n\n​\t\tdept d\n\non               //独立出来的连接条件\n\n​\t\te.deptno  =  d.deptno ;\n```\n\nSQL92缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件都放在了where中。\n\nSQL99的优点：表连接的条件是独立的，连接之后，若还要进一步筛选，再写where语句。\n\nSQL99连接语法：\n```sql\nselect\n\n​\t\t......\n\nfrom\n\n​\t\ta\n\njoin\n\n​\t\tb\n\non\n\n​\t\ta和b的连接条件\n\nwhere\n\n​\t\t筛选条件\n```\n\n### 非等值连接\n\nwhere   下的筛选条件不是一个等量关系\n\n### 自连接\n\n样例表：\n\n| 员工编号 | 姓名   | 上司编号 |\n| -------- | ------ | -------- |\n| 7369     | SMITH  | 7902     |\n| 7499     | ALLEN  | 7698     |\n| 7521     | WARD   | 7698     |\n| 7566     | JONES  | ==7839== |\n| 7654     | MARTIN | 7698     |\n| 7698     | BLAKE  | ==7839== |\n| 7782     | CLARK  | ==7839== |\n| 7788     | SCOTT  | 7566     |\n| ==7839== | KING   | NULL     |\n| 7844     | TURNER | 7698     |\n| 7876     | ANAMS  | 7788     |\n| 7900     | JAMES  | 7698     |\n| 7902     | FORD   | 7566     |\n| 7934     | MILLER | 7782     |\n\n内连接用法：查询员工的上司，要求显示员工名和对应的领导名。\n\n注：同一个表用两个名称\n```sql\n\nselect\n\n​\t\ta.姓名   as  '员工名'  ，  b.姓名   as   ‘上司名’\n\nfrom\n\n​\t\temp  a\n\njoin \n\n​\t\temp  b\n\non\n\n​\t\ta.上司编号  =  b.员工编号\n```\n\n## 外连接\n\n例：给定一个存储员工信息的表emp  ，一个存储部门信息的表dept。\n\n要求连接员工姓名与他对应的部门，并将空的部门也一起显示。（因为有可能有的部门的人都不在表emp中）\n```sql\nselect             （右外连接或右链接） （emp  和  dept之间存在主次关系。dept为主）\n\n​\t\te.ename , d.dname\n\nfrom\n\n​\t\temp  e    right  join  dept  d       //right 表示 右边的表中没有匹配成功的记录也要\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t显示\n\n//(左外连接)\t\tdept   d   **left**    emp   e            这句话与上句话相同\n\n//关键字right表示右边的表一定要全部显示出，left同理。\n\non\n\n​\t\te.deptno = d.deptno  ;\n\n```\n\n## 多表连接\n\n语法：\n```sql\n\nselect\n\n​\t  .............\n\nfrom\n\n​\t\t a\n\njoin     b\n\non\n\n​\t\t a 和 b 的连接条件\n\njoin     c\n\non\n\n​\t\t a 和 c 的连接条件\n\n。\n\n。\n\n。\n\njoin     n\n\non\n\n​\t\t a  和  n  的连接条件  ;\n```\n\n<u>注：内连接和外连接可以混合使用。</u>\n\n例：找出每个员工的部门名称以及工资等级，要求：显示出员工名、部门名、薪资、薪资等级。\n```sql\n\nselect\n\n​\t\te.ename , e.sal , d.dname , s.grade\n\nfrom\n\n​\t\temp  e\n\njoin \n\n​\t\tdept  d\n\non\n\n​\t\te.deptno  =  d.deptno\n\njoin\n\n​\t\tsalgrade  s\n\non\n\n​\t\te.sal  between   s.losal    and   s.hisal  ;\n\n```\n\n## union 关键字\n\n数据量大的情况下union比普通连接效率高\n\n前提：连接的两个表选出的列数相同\n\n例：\n```sql\nselect ename, job from  emp  where  job='MANAGER'\n\nunion\n\nselect  ename ,  job from emp  where  job='SALESMAN';\n```\n\n# 子查询\n\nselect语句中嵌套select语句，嵌入的select语句称为子查询\n\n如：\n```sql\nselect\n\n​\t\t.....（select）.....\n\nfrom\n\n​\t\t.....（select）.....\n\nwhere\n\n​\t\t.....（select）.....\n```\n\n## where中的子查询\n\n例：找出比最低工资高的员工姓名和工资。\n\n错误方法：\n```sql\nselect：\n\n​\t\tename  ,  sal\n\nfrom\n\n​\t\temp\n\nwhere\n\n​\t\tsal > min(sal) ;           //此句错误，min这种多组函数使用前必须先分组。\n```\n\n思路：\n```sql\n//step1：查询最低工资\n\nselect    min(sal)   from   emp ;    //假设查出为800\n\n//step2：找出大于最小工资的员工\n\nselect    ename , sal   from   emp   where   sal>800 ;\n\n//step3：合并前两步\n\nselect    ename , sal   from   emp   where   sal> <u>(select  min(sal)   from  emp )</u> ;\n```\n## from中的子查询\n\n这种子查询可以将子查询的查询结果当成一个临时表。（技巧）\n\n例：找出每个岗位的平均工资的薪资等级。\n\n思路：\n```sql\n//step1：找出每个岗位的平均工资（按照岗位分组求平均值）\n\nselect   job  ,  avg(sal)   from   emp    group   by   job;\n\n//step2：第一步得到了临时表 t 。现有薪资评级表 salgrade。\n```\n\nt  和  salgrade 连接\n```sql\n\nselect\n\n​\t\tt.* , s.grade\n\nfrom\n\n​\t\tt\n\njoin\n\n​\t\tsalgrade s\n\non\n\n​\t\tt.avg(sal)       between   s.losal   ans  s.hisal ;\n\n//step3：合并前两步\n\nselect\n\n​\t\tt.* , s.grade\n\nfrom\n\n​\t\t(select  job , <u>avg(sal)  as  avgsal</u>  from  emp  group  by  job)  t\n\njoin\n\n​\t\tsalgrade s\n\non\n\n​\t\t<u>t.avgsal</u>       between   s.losal   ans  s.hisal ;\n```\n\n## select中的子查询\n\n例：找出每个员工的部门名称，要求显示员工名，部门名。\n```sql\n\nselect\n\n​\t\te.ename , (select  d.dname  from   dept  d    where    e.deptno = d.deptno) as \t\t\tdname\n\nfrom\n\n​\t\temp;\n```\n注：对于每一条记录，若子查询超过一条就会报错。\n\n# 分页查询\n\n##  limit关键字\n\n目的：将查询结果集的一部分取出来。（搜索引擎搜索结果的分页）\n\n用法：\n```sql\nlimit    startindex，length       //写在order  by  后面\n```\n\n例：按照薪资排序，取出排名前5的员工。\n```sql\nselect  \n\n​\t\tename , sal\n\nfrom\n\n​\t\temp\n\norder by \n\n​\t\tsal desc\n\nlimit    0,5        //也可以写成  limit   5。表中的记录从0开始。\n```\n\n## 分页\n\n每页显示pageSize条记录\n\n​\t\t第pageNo页：limit （pageNo - 1）* pageSize  ， pageSize\n\n如：\n第1页：limit 0，3    [0  1  2]\n\n第2页：limit 3，3    [3  4  5]\n\n第3页：limit 6，3    [6  7  8]\n\n第4页：limit 9，3    [0  1  2]\n\n# 建表\n\n```sql\n创建表格式：create  table  表名（字段名1  数据类型，字段名2  数据类型，。。）;\n\n删除表格式：drop  table  if   exists    (要删除的表名) ;\n\n添加记录：insert  into   表名  values(字段名和值一一对应)  ;\n```\n\n常见数据类型：varchar(动态分配字符串内存)，char(静态分配)，int，bigint，float，double，date(短日期)，datetime（长日期），clob(字符大对象)，blob(二进制大对象)\n\nclob：可以存储最多4G 的大字符串（如文章）。\n\nblob：存储图片、声音、视频等流媒体数据。需要使用IO流\n\n## 修改（update）\n\n```sql\nupdate  \n\n​\t\t表名  \n\nset  \t\t//修改具体值\n\n​\t\t字段名1=值1，字段名2=值2，。。。\n\nwhere... ;//指定特定条件的记录，不写where默认修改所有记录\n```\n\n## 删除记录delete（DML）\n\n```sql\ndelete   from   表名   where  ......；//不写where会删除所有数据\n```\n\n## 插入多条记录\n\n```sql\ninsert  into  表名（字段名1，字段名2。。。）   values\n\n（元组一），\n\n（元组二），\n\n。。。，\n\n（元组n）;   //元组数据类型必须与第一行的字段名一一对应\n```\n\n## 快捷命令\n\n### 快速创建表\n\n```sql\ncreate    table   新表名   as   select   *  from   原表名;   //select语句可以按需求扩充内容（如where，order by等）\n```\n\n### 快速删除数据\n\n```sql\ntruncate  table  表名 ;   //与‘delete   from   表名’     相同\n```\n\ntruncate和delete的区别\n\n| truncate                                                     | delete                                                       |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 删除效率相对比较高，表被依次截断，物理删除                   | 表中的数据被删除了，但是删除的数据在硬盘上的真实存储空间不会被释放 |\n| 缺点：不支持撤销操作                                         | 缺点：删除效率较低（一亿条记录时要1小时才能删完）            |\n| 有点：快速（数据量非常大的时候推荐使用。一亿条记录是删除时间不到1秒） | 优点：支持撤销操作                                           |\n| 是DDL语句                                                    | 是DML语句                                                    |\n\n\n\n# 约束\n\n目的：确保数据的完整性、有效性。\n\n常见约束：非空约束(not null)、唯一性约束(unique)、主键约束(primary key ，PK)、外键约束(foreign key，FK)、检查约束(check)\n\n## 非空约束\n\nnot null 约束的字段不能为NULL。\n\n```sql\ndrop  table  if  exist  t_vip;\n\ncreate  table  t_vip(\n\n    id  int,\n\n    name   carchar(255)   **not  null**\n\n);\n```\n\n## 唯一性约束\n\nunique约束的字段不能重复，但是可以为NULL。\n\n使用例：\n\n```sql\ndrop  table  if  exist  t_vip;\n\ncreate  table  t_vip(\n\n    id  int,\n\n    name   carchar(255)   **unique**,            //该字段的内容不能重复\n\n    email  varchar(255)\n\n);\n```\n\n推广：不同字段在特定条件下可以联合设置为唯一性约束。（如：两个人姓名相同，但是电话号码不同。或者说一个人有多个电话号码记录）\n\n\n\n```sql\ndrop  table  if  exist  t_vip;\n\ncreate  table  t_vip(\n\n\tid  int,\n\n\tname   carchar(255) ，   \n\n\temail  varchar(255)  ，\n\n\tunique(name , email)      //联合唯一性\n\n);\n```\n\n下例为unique和not  null  联合使用\n\n```sql\ndrop  table  if  exist  t_vip;\n\ncreate  table  t_vip(\n\n\tid  int,\n\n\tname   carchar(255)   **not  null  unique**,   //该字段的内容不能重复也不能为空\n\n\temail  varchar(255)\n\n);\n```\n\n这种联合的效果就是主键约束，也就是说，可以直接用PK约束实现前两种约束的联合。\n\n## 主键约束\n\n术语：主键约束、主键字段、主键值\n\n主键例：学号、身份证......\n\n建议设为主键的类型：int、bigint、char等。（varchar不建议）\n\n<strong>注：一个表中只能设置一个主键</strong>\n\n特征：not  null  、 unique\n\n### 单一主键和复合主键（分类一）\n\n使用例：\n\n```sql\ndrop  table  if  exist  t_vip;\n\ncreate  table  t_vip(\n\n\tid  int,\n\n\tname   carchar(255)   **primary  key **   ， \n\n\temail  varchar(255)\n\n);\n```\n\n复合主键使用例：\n\n```sql\ndrop  table  if  exist  t_vip;\n\ncreate  table  t_vip(\n\n\tid  int,\n\n\tname   carchar(255) ，    \n\n\temail  varchar(255)，\n\n\tprimary  key（id，name）     //号码、姓名同时相同时才算重复。\n\n);\n```\n\n\n\n### 自然主键和业务主键（分类二）\n\n自然主键：主键值是一个自然数，和业务无关。<==使用较多\n\n业务主键：主键值和业务关联，例如银行卡号。\n\n自动维护主键值使用例：\n\n```sql\ndrop  table  if  exist  t_vip;\n\ncreate  table  t_vip(\n\n\tid  int    **primary  key   auto_increment**  \n\n\tname   carchar(255) ，\n\n\temail  varchar(255)\n\n);\n```\n\n\n\n## 外键约束\n\n相关术语：外键约束、外键字段(添加了外键约束的字段)、外键值(可以为null)。\n\n应用场景：处理学生和班级时，应当把班级额外设置为一个表再对学生进行外键约束。（t_class   ,  t_student）\n\nt_class\n\n| classno | classname |\n| ------- | --------- |\n| 100     | 一班      |\n| 101     | 二班      |\n\nt_student\n\n| no   | name     | cno  |\n| ---- | -------- | ---- |\n| 1    | jack     | 100  |\n| 2    | lucy     | 100  |\n| 3    | lilei    | 100  |\n| 4    | bob      | 100  |\n| 5    | ben      | 101  |\n| 6    | alice    | 101  |\n| 7    | alex     | 100  |\n| 8    | zhangsan | 101  |\n\nt_class 是父表，t_student是子表。\n\n删除表的顺序：先删子，再删父。\n\n创建表的顺序：先创建父，再创建子。\n\n删除数据的顺序：先删子，再删父。\n\n插入数据的顺序：先插入父，再插入子。\n\n```sql\ndrop  table  if  exist   t_student;\n\ndrop  table  if  exist   t_class;\n\n\n\ncreate  table  t_class(\n\n​\t\tclassno  int  primary  key,\n\n​\t\tclassname   varchar(255)\n\n)\n\n\n\ncreate  table  t_student(\n\n​\t\tno  int  primary   key  auto_increment,\n\n​\t\tname  varchar(255),\n\n​\t\tcno  int,\n\n​\t\t**foreign  key(cno)  references  t_class(classno)**  \n\n)\n```\n\n# 存储引擎\n\n注：存储引擎是mysql的特有术语。\n\n存储引擎即数据内容的存储方式，如：ANSI,UTF-8等。\n\n查看mysql支持哪些存储引擎：show  engines\n\n展示新建表的存储引擎：show  create  table  (表名)\n\n指定引擎使用例：\n\n```sql\ncreate  table  t_product(\n\n​\t\tid  int  primary  key ,\n\n​\t\tname  varchar(255)\n\n)engine=InnoDB  default  charset=utf8;\n```\n\n## My ISAM存储引擎\n\n使用三个文件表示每一个表：\n\n​\t\t格式文件：存储表结构的定义   xxx.frm\n\n​\t\t数据文件：存储表行的内容  xxx.MYD\n\n​\t\t索引(目录)文件：存储表上索引   xxx.MYI\n\n特点：可以转换为压缩、只读表来节省空间。\n\n## InnoDB存储引擎（默认引擎）\n\nInnoDB支持事务，支持数据库崩溃后自动恢复机制\n\n特点：非常安全，效率不高，不能压缩或转换为只读。\n\nInnoDB管理的表的特征：\n\n​\t\t每个InnoDB表再数据库目录中以 .frm  格式文件表示\n\n​\t\tInnoDB表空间tablespace被用于存储表的内容\n\n​\t\t提供一组用来记录事务性活动的日志文件\n\n​\t\t用COMMIT(提交)，SAVEPOINT以及ROOLBACK支持事务处理\n\n​\t\t提供全ACID兼容\n\n​\t\t在mysql服务器崩溃后会自动回复\n\n​\t\t多版本(MVCC)和行级锁定\n\n​\t\t支持外键及引用的完整性，包括级联删除和更新\n\n\n\n\n\n## MEMORY存储引擎\n\n数据存储在内存中，且行的长度固定\n\n特点：查询速度快，不安全\n\nMEMORY管理的表的特征：\n\n​\t\t在数据库目录内，每个表均以  .frm  格式的文件表示。\n\n​\t\t表数据及索引被存储在内存中\n\n​\t\t表级锁机制\n\n​\t\t不能包含TEXT 或 BLOB字段\n\n# 事务(DML语句)\n\n定义：一个事务是一个完整的业务逻辑。\n\n事务特性：\n\n​\t\tA(原子性)：事务是最小的工作单元，不可再分。\n\n​\t\tC(一致性)：一系列操作必须同时成功或同时失败。\n\n​\t\tI(隔离性)：不同事务之间不影响\n\n​\t\tD(持久性)：保存内容，提供保障。\n\n完整的业务逻辑例：\n\n​\t\t业务：A转账10000元给B\n\n​\t\t步骤：A的账户-10000，B的账户+10000。\n\n这一系列操作必须同时成功或同时失败。\n\n即，一个事务就是一系列的DML语句。\n\n注：InnoDB会提供一组用来记录事务性活动的日志文件\n\n如：\n\n事务开启，写入日志\n\n```sql\ninsert...\n\ninsert...\n\n.\n\n.\n\n.\n\n事务结束，写入日志          //提交事务\n\n\n\n提交事务：commit ；语句\n\n回滚事务：rollback ；语句     //回到上一次提交的位置\n\n关闭自动提交操作：start    transaction；\n```\n\n## 事务隔离\n\n级别：\n\n​\t\t读未提交：read  uncommitted(不提交也读到)\t\t\t最低级\n\n​\t\t\t\t事务A读到事务B未提交的数据。易产生脏数据(Dirty  Read)。\n\n​\t\t读已提交：read  committed  (提交了才能读到)\n\n​\t\t\t\t事务A只能读到事务B提交之后的数据。\n\n​\t\t\t\t不可重复读数据。如：事务开启后，第一次读到的数据是3条，当前事务还没有结束，可能第二次在读取的时候，读到的数据是4条，3不等于4。\n\n​\t\t可重复读：repeatable   read\t(提交了也读不到)   //mysql默认级别\n\n​\t\t\t\t读取的是数据的幻象，读到的都是事务刚开始时的数据。\n\n​\t\t序列化：serializable\t\t\t最高级\n\n​\t\t\t\t效率低，但是解决了所有的问题\n\n​\t\t\t\t这种级别表示事务排队，不能并发。\n\n# 索引\n\n类似于书的目录，提高搜索效率。\n\nmysql查询的方式：1.全表扫描。2.根据索引检索\n\n索引必须排序。索引和TreeSet(底层是AVL)数据结构相同。\n\n在mysql中，索引是一个B树。\n\n复合索引：两个及以上字段联合起来添加一个索引。\n\n## 语法\n\n创建索引\n\n​\t\t\n\n```sql\ncreate  index  emp_ename_index  on  emp(ename) ;\n\n​\t\t给emp表的ename字段添加索引，命名：emp_ename_index\n```\n\n删除索引\n\n​\t\t\n\n```sql\ndrop  index  emp_ename_index  on  emp;\n\n​\t\t将emp表上的emp_ename_index索引对象删除\n```\n\n检查是否有索引\n\n​\t\n\n```sql\nexplain  *  from   emp   where   ename  =‘XXX’;\n```\n\n## 索引失效\n\n1.尽量避免模糊查询时以“%”开始。\n\n2.使用 or 关键字时两边的字段都要有索引，否则不会调用索引。\n\n3.使用复合索引的时候，没有使用左侧的列查找，索引会失效\n\n4.在where中索引列若参与的运算，索引会失效。\n\n5.在where中索引列使用了函数，索引会失效。\n\n......\n\n## 索引分类\n\n索引是各种数据库进行优化的重要手段，优化的时候优先考虑的就是索引。\n\n分类一：单一索引、复合索引。\n\n分类二：主键索引、唯一性索引(在有unique约束的字段上添加索引)\n\n# 视图(view)\n\n创建视图对象：create  view  dept2_view  as  select  *  from  dept2;\n\n注：上面as关键字后的语句必须是DQL语句。\n\n删除视图：drop  view  dept2_view;\n\n对视图对象的增删改查，会导致原表被操作。\n\n视图本质就是将一块SQL语句进行封装，以便复用时节省空间。\n\n如：\n\n```sql\ncreate  view\temp_dept_view\n\nas\n\n​\t\tselect\n\n​\t\t\te.ename ,  e.sal , d.dname\n\n​\t\tfrom\n\n​\t\t\temp e\n\n​\t\tjoin\n\n​\t\t\tdept d\n\n​\t\ton\n\n​\t\t\te.deptno = d.deptno ;\n```\n\nas  后面的整块SQL语句被封装进了emp_dept_view中\n\n\n\n# 数据库设计范式\n\n目的：设计合理的数据库表，避免数据冗余、空间浪费。\n\n分类：\n\n​\t\t第一范式：要求任何一张表必须有主键，每一个字段的原子性不可再分。\n\n​\t\t第二范式：建立在第一范式之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。\n\n​\t\t第三范式：建立在第二范式之上，要求所有非主关键字直接依赖主键，不要产生传递依赖。\n\n## 第一范式\n\n最核心最重要的范式，所有表的设计都要满足。\n\n有主键，且字段内容不可再分的表满足第一范式。\n\n## 第二范式\n\n| 学生编号(复合主键) | 教师编号(复合主键) | 学生姓名 | 教师姓名 |\n| ------------------ | ------------------ | -------- | -------- |\n| 1001               | 001                | 张三     | 王老师   |\n| 1002               | 002                | 李四     | 赵老师   |\n| 1003               | 001                | 王五     | 王老师   |\n| 1001               | 002                | 张三     | 赵老师   |\n\n这种表不符合第二范式，因为学生只依赖学生编号，老师只依赖教师编号，数据易冗余。\n\n为了满足第二范式，要将上面的表分解成多个子表(如下)。\n\n学生表\n\n| 学生编号(pk) | 学生名字 |\n| ------------ | -------- |\n| 1001         | 张三     |\n| 1002         | 李四     |\n| 1003         | 王五     |\n\n教师表\n\n| 教师编号(pk) | 教师姓名 |\n| ------------ | -------- |\n| 001          | 王老师   |\n| 002          | 赵老师   |\n\n学生教师关系表\n\n| id(pk) | 学生编号(fk) | 教师编号(fk) |\n| ------ | ------------ | ------------ |\n| 1      | 1001         | 001          |\n| 2      | 1002         | 002          |\n| 3      | 1003         | 001          |\n| 4      | 1001         | 002          |\n\n<u>多对多设计技巧：多对多，三张表，关系表两个外键。</u>\n\n## 第三范式\n\n| 学生编号(pk) | 学生姓名 | 班级编号 | 班级名称 |\n| ------------ | -------- | -------- | -------- |\n| 1001         | 张三     | 01       | 一班     |\n| 1002         | 李四     | 02       | 二班     |\n| 1003         | 王五     | 03       | 三班     |\n| 1004         | 赵六     | 04       | 四班     |\n\n上标满足第一、二范式。\n\n不满足第三范式，因为班级名称依赖班级编号，而班级编号又依赖学生编号，这就产生了传递依赖，会有数据冗余。\n\n为满足第三范式，可以将上标拆成两张表(如下)。\n\n班级表\n\n| 班级编号(pk) | 班级名称 |\n| ------------ | -------- |\n| 01           | 一班     |\n| 02           | 二班     |\n| 03           | 三班     |\n| 04           | 四班     |\n\n学生表\n\n| 学生编号(pk) | 学生姓名 | 班级编号(fk) |\n| ------------ | -------- | ------------ |\n| 1001         | 张三     | 01           |\n| 1002         | 李四     | 02           |\n| 1003         | 王五     | 03           |\n| 1004         | 赵六     | 04           |\n\n<u>第三范式设计技巧：一对多，两张表，多的表，加外键。</u>\n\n##  总结表的设计\n\n一对多：\n\n​\t\t一对多，两张表，多的表加外键。\n\n多对多：\n\n​\t\t多对多，三张表，关系表两个外键。\n\n一对一：\n\n​\t\t若字段过多，则要考虑拆成多个更小的表，并用外键加以联系。\n\n​\t\t一对一，外键唯一。\n\n不过实践和理论之间存在偏差。\n\n**从实践上来说**，设计表的最终目的都是为了满足客户的要求，有时会拿冗余换执行速度。因为在sql中，表和表之间连接次数越多，效率越低。(笛卡尔积)\n\n# 可参考资料：\n数据库范式：[https://www.zhihu.com/question/24696366/answer/29189700](https://www.zhihu.com/question/24696366/answer/29189700)\n\n","categories":[],"tags":["数据库"]}]