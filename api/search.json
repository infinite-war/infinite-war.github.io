[{"title":"《C 和指针阅读笔记》","url":"/posts/46293/","content":"《C和指针》 Kenneth著\n\nCSDN:https://blog.csdn.net/INFINITE_WAR/article/details/121294114\n\n@[toc]\n# 1、快速上手\n\n预处理指令：\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define MAX_COLS 20\n#define MAX_INPUT 1000\n```\n\n这些指令由预处理器解释，预处理器读入源代码，根据预处理指令对其进行<u>修改</u>，然后把修改过的源代码递交给编译器。\n\n用#define定义的常量一般用大写加以区分，且该变量不能被赋值。\n\n当预处理语句过多时，可以把它们打包到一个自定义头文件中，然后直接引用该头文件即可，这样还能避免由于同一个声明的多份拷贝而导致的维护性问题。\n\n```c\n/*\n*  读取、处理和打印剩余的输入行\n*/\nwhile (gets(input)!=NULL){\n    printf(\"Original input : $s\\n\",input);\n    rearrange(output, input, n_columns,columns);\n    printf(\"Rearranged line: %s\\n\", output);\n}\n```\n\n要多在代码中写进必要的注释，以此来解释清楚什么地方的代码是什么功能，这样过一段时间后别人(或自己)重看一遍这部分代码会很容易理解，更有利于维护。同时，更新代码时也要注意相关注释的更新。\n\n\n\n\n```c\n/*\n* 读取列标号，如果超出规定范围则不予理会\n*/\nint read_column_numbers(int columns[],int max);\n```\n\n\n声明的数组不用附带长度，这种特性允许函数操纵任意长度的一维数组， 缺点就是不能获取数组的长度。\n\n```c\nch=getchar();\nwhile(ch!=EOF && ch!='\\n')   //EOF 本质上是个整数值\n    ch=getchar();\n```\n\n这块代码用于一个个读取字符直至到达文件末尾（或者读到换行符）。\n\n\n\n```c\n/*\n*  处理输入行，将指定列的字符连接在一起，输出行以NULL结尾\n*/\nvoid rearrange(char *output,char const *input,\n              int n_columns,int const columns[])\n```\n\n数组本质上就是指针，因此传入的参数不是数组的备份而是指针，也就是说，在函数内对数组参数的修改会影响函数外部的实际数组。为了避免修改数组，可以将参数声明为 const 。\n\n\n\n## 警告与总结\n\n1.在scanf函数的标量参数前未添加&字符。\n\n2.机械的把printf函数的格式代码照搬于scanf函数。\n\n3.在应该使用&&操作符的地方误用了&操作符。\n\n4.误用=操作符而不是==操作符来测试相等性。\n\n## 编程提示的总结\n\n1.使用#include指令避免重复声明\n\n2.使用#define指令给常量值取名。\n\n3.在#include文件中放置函数原型。\n\n4.在使用下标前先检查它们的值。\n\n5.在while或if表达式中蕴含赋值操作。\n\n6.如何编写一个空循环体。\n\n7.始终要进行检查，去日报数组不越界。\n\n\n\n\n\n\n\n# 2、基本概念\n\n## 2.1 环境\n\n### 2.1.1 翻译环境\n\n翻译阶段，一个(或多个)源文件(Source code)通过编译(Complier)过程分别转换为目标代码(Object code)。然后，这些目标代码由链接器(linker)捆绑在一起，形成一个可执行(executable)程序。\n\n编译过程：\n\n​\t1.预处理器处理。预处理在源代码上执行一些文本操作。如：用实际值代替#define等命令，读入#include包含的文件。\n\n​\t2.解析，判断语句的意思。随后产生目标代码(机器指令的初步形式，用于实现程序的语句)。   如果我们在编译程序的命令行中假如了要求进行优化的选项，优化器(optimizer)可以进一步处理目标代码，使其效率更高(优化过程更耗时间)。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fa5282ca3d5a4ee08e03a2b4a024ded8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n下面以UNIX为例进行编译和链接\n\n```c\n//1、编译并连接一个完全包含于一个源文件的C程序\ncc program.c\n//会产生一个a.cout可执行程序。中间会产生program.o目标文件,不\n//过它在连接过程完成后会被删除。\n\n//2、编译并链接几个C源文件\ncc main.c sort.c lookup.c\n//当编译的源文件超过一个时，目标文件不会被删除\n\n//3、编译一个C源文件，并把它和现存的目标文件链接在一起\ncc main.o lookup.o sort.c\n\n//4、编译单个C源文件，并产生一个目标文件，以后再进行链接\ncc -c program.c\n\n//5、编译几个C源文件，并为每个文件产生一个目标文件\ncc -c main.c sort.c lookup.c\n\n//6、链接几个目标文件\ncc main.o sort.o lookup.o\n```\n\n### 2.1.2 执行环境\n\n执行过程：\n\n​\t1.程序被载入到内存中（由操作系统完成）。哪些不存储在堆栈中的尚未初始化的变量将会初始化。\n\n​\t2.通过一个小型启动程序和目标程序链接在一起。然后调用main函数。\n\n​\t3.程序会使用一个运行时**堆栈**，它用于存储函数的局部变量和返回地址。   同时程序也会使用**静态**内存，其中的变量在整个过程中会一直保留原本的值。\n\n​\t4.程序结束。可以是末尾return 0；正常结束，也可以是中途报错直接结束。\n\n## 2.2 词法规则\n\n### 三字母词\n\n通过??x的形式可以转义出其他符号，部分样例如下表\n\n| ??(  | [    |      | ??<  | {    |      | ??=  | #    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| ??)  | ]    |      | ??>  | }    |      | ??/  | \\    |\n| ??!  | \\|   |      | ??'  | ^    |      | ??-  | ~    |\n\n现在转义一般用 ‘ \\ ’。三字母词平时其实非常少见。\n\n# 3、数据\n\n## 3.1 基本数据类型\n\n### 3.1.1 整型\n\n#### 整型字面值\n\n字面值如 1，2，FF这些数值，它们本身不能再改变。\n\n变量的最小范围\n\n| 类型               | 最小范围               |\n| ------------------ | ---------------------- |\n| char               | 0-127                  |\n| signed char        | -127-127               |\n| unsigned char      | 0-255                  |\n| short int          | -32767-32767           |\n| unsigned short int | 0-65535                |\n| int                | -32767-32767           |\n| unsigned int       | 0-65535                |\n| long int           | -2147483647-2147483647 |\n| unsigned long int  | 0-4294967295           |\n\n\n\n头文件limits.h说明了各种不同的整数类型的特点。\n\n如：CHAR_BIT 是字符型的位数，CHAR_MIN、CHAR_MAX定义了缺省字符类型的范围。 MB_LEN_MAX规定了一个多字节字符最多允许的字符数量。\n\n|        | signed    | signed    | unsigned  |\n| ------ | --------- | --------- | --------- |\n| 类型   | 最小值    | 最大值    | 最大值    |\n| 字符   | SCHAR_MIN | SCHAR_MAX | UCHAR_MAX |\n| 短整型 | SHRT_MIN  | SHRT_MAX  | USHRT_MAX |\n| 整型   | INT_MIN   | INT_MAX   | UNIT_MAX  |\n| 长整型 | LONG_MIN  | LONG_MAX  | ULONG_MAX |\n\n事实上，不同的机器中char可能有不同范围的值。\n\n#### 枚举类型(enumerated)\n\n```c\nenum Jar_Type{CUP=8,PINT=16,QUART=32,\n\t\t\tHALF_GALLON=64,GALLON=128};\n```\n\n上例中，Jar_Type被声明为一个枚举类型，CUP、PINT等为符号常量，后续可以直接引用。\n\n假如没有设置CUP、PINT等符号等于什么值，那么默认CUP=0、PINT=1 以此类推。\n\n假如有的符号有设置值，而有的没有，那未设置值的符号，默认比前一个符号大1。\n\n### 3.1.2 浮点类型\n\n头文件float.h 定义了名字FLT_MAX、DBL_MAX和LDBL_MIN，分别表示float、double和long double所能存储的最大值。对应的xxx_MIN存最小值。\n\n### 3.1.3 指针\n\n#### 指针常量\n\n每次调用一个函数时，它的局部变量可能每次分配的内存位置都不一样。\n\n#### 字符串常量\n\n定义：一串以NULL字节结尾的零个或多个字符。存入字符数组中。\n\n## 3.2声明\n\n### 3.2.2数组声明\n\nC编译器不会检查数组下标是否越界。\n\n如果下标值是从那些已知是正确的值 (比如直接声明a[100]) 计算得来的，就不用检查它的值。如果是其他方法或者用户输入得到的 (比如a[n]，这里的n可以计算得出，也可以用户输入) , 就需要检查它的值防止越界。\n\n### 3.2.3 指针声明\n\n```c\n//声明一个指针\nint *a;\n//声明多个指针\nint *b,*c,*d;\n//字符串\nchar *message=\"Hello world!\";\n//上一句的具体过程\nchar *message;\nmessage=\"Hello world!\";\n```\n\n### 3.2.4隐式声明\n\n```c\nf(x){\n\treturn x+1;\n}\n//编译器会默认f返回整型\n```\n\n隐式声明建议不用，很容易降低代码可读性。\n\n## 3.3 typedef\n\ntypedef的目的：为各种数据类型定义新名字。\n\n```c\ntypedef char *ptr_tp_char;\nptr_to_char a;   //等价于char *a;\n```\n\n定义类型名最好用typedef而不是用#define，后者无法正确地处理指针类型。\n\n## 3.4 常量\n\n```c\nint const *p;   //等价于int *const p;\n//该指针所指向的内容可以修改，但是不能修改地址。\nconst int *p;\n//该指针可以修改地址，但不能修改所指向的值\nconst int *const p;\n//该指针一初始化就不能修改。\n\n//一般常量声明\n#define MAX_ELEMENTS 50\nint const max_elements=50;\n```\n\n定义一个名字常量的好处在于，后续维护程序时，只用修改声明部分就能修改所有相关的地方。\n\n## 3.6 链接属性\n\n连接属性分类：external(外部)、internal(内部)、none(无)\n\n```c\nextern int k;\n//声明为extern的k将是外部文件的一个同名变量\n\nstatic int b;\n//声明为static的b将为当前的源文件私有\n//在其他源文件中，若链接到一个叫做b的变量，那么它引用的将\n//是另一个不同的变量\n\n//对函数也可以如此声明，这样可以防止外部文件的调用。\nstatic int f(int x);\n```\n\n## 3.7 存储类型\n\n分类：普通内存、运行时堆栈、硬件寄存器\n\n使用频率高的变量可以声明为寄存器变量(register关键字)。\n\n寄存器变量的创建和销毁时间和局部变量相同，但它需要一些额外工作。在一个使用寄存器变量的函数返回之前，这些寄存器先前存储的值必须恢复，确保调用者的寄存器变量未被破坏。 \n\n当函数开始执行时，它把需要使用的所有寄存器的内容都保存到堆栈中，当函数返回时，这些值再复制回到寄存器中。\n\n某个特定的寄存器在不同的时刻所保持的值不一定相同。因此，机器不会提供寄存器变量的地址。\n\n#### 初始化\n\n静态变量若不显式地初始化，将默认赋值为0。\n\n局部变量若不显式地初始化，将会有更多开销，因为当程序链接时还无法判断局部变量的存储位置。<u>局部变量最好显式初始化</u>。\n\n## 3.8 static 关键字\n\nstatic有两种用法：\n\n1.用于函数定义、或用于代码块之外的变量声明时，static用于修改标识符的链接属性，从external改为internal，但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明它们的源文件中访问。\n\n2.用于代码块内部的变量声明时，static用于修改变量的存储类型，将局部变量转为静态变量，但是变量的链接属性和作用域不受影响。\n\n\n\n## 3.10 小结\n\n| 变量类型 | 声明位置       | 是否存于堆栈 | 作用域           | 如果声明为static                                     |\n| -------- | -------------- | ------------ | ---------------- | ---------------------------------------------------- |\n| 全局     | 所有代码块之外 | F            | 从声明出到文件尾 | 不允许从其他源文件访问                               |\n| 局部     | 代码块起始处   | T            | 整个代码块       | 变量不存储与堆栈中，它们的值在程序整个执行期一直保持 |\n| 形式参数 | 函数头部       | T            | 整个函数         | 不允许                                               |\n\n## 警告的总结\n\n1.在声明指针变量时采用容易误导的写法。\n\n2.误解指针声明中初始化的含义。\n\n\n\n## 编程提示总结\n\n1.为了保持最佳的可移植性，把字符的值限制在有符号和无符号字符范围的交集之内，或者不要在字符上执行算术运算。\n\n2.用它们在使用时最自然的形式来表示字面值。\n\n3.不要把整型值和枚举值混为一谈。\n\n4.不要依赖隐式声明。\n\n5.在定义类型的新名字时，使用typedef而不是#define\n\n6.用const声明其值不会修改的变量。\n\n7.使用名字常量而不是字面值常量。\n\n8.不要再嵌套的代码块之间使用相同的变量名。\n\n9.除了实体的具体定义位置之外，在它的其他声明位置都使用extern关键字。\n\n\n\n# 4、语句\n\n## 警告的总结\n\n1.编写不会产生任何结果的表达式。\n\n2.确信在if语句中的语句列表前后加上花括号。\n\n3.在switch语句中，执行流意外地从一个case顺延到下一个case。\n\n## 编程提示总结\n\n1.在一个没有循环体的循环中，用一个分号表示空语句，并让它独占一行。\n\n2.for循环的可读性比whlie循环强，因为它把用于控制循环的表达式收集起来放在同一处。\n\n3.switch语句中必要时使用default子句。\n\n# 5、操作符和表达式\n\n# 5.1操作符\n\n### 5.1.1算术操作符\n\n+、-、*、/、%\n\n### 5.1.2移位操作符\n\n操作对象：整数类型\n\n左移：>>\n\n右移：<<\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1fa72c6ed15f44e19b422c6f3fb51bae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n对于有符号值，到底是采用逻辑移位还是算数移位(会保持当前符号)取决于编译器。\n\n```c\n/*\n* 该函数返回参数值二进制中值为1的位的个数 （初级版本）\n*/\nint count_one_bits(unsigned value){\n    int ones;\n    //当这个值还有一些值为1的位时。\n    for(ones=0;value!=0;value=value>>1)\n    \tif(value%2!=0)  \n            ones+=1;\n    \n    return ones\n}\n```\n\n### 5.1.3 位操作符\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/803a3f7cef044dc18166e9a9973009b8.png#pic_center)\n\n\n例：\n\n| a    | 00101110 |\n| ---- | -------- |\n| b    | 01011011 |\n| a&b  | 00001010 |\n| a\\|b | 01111111 |\n| a^b  | 01110101 |\n\n### 5.1.4赋值\n\n```c\na=x=y+3\n```\n\n该语句a和x被赋的值可能不同。\n\n假如x是一个字符型变量，那么y+3会被截去一段，以便容纳于字符类型的变量中。那么a的值将会是这个被截取后的值。\n\n```c\nchar ch;\n...\nwhile((ch=getchar())!=EOF)...\n```\n\nEOF需要的位数比字符型值所能提供的位数要多，这也是getchar返回一个整型值而不是字符值的原因。然而，getchar的返回值首先存入ch中会导致它被截短，然后这个截短的值又会和EOF比较。\n\n在使用<u>有符号字符集</u>的机器上运行时，若读取了一个值为\\377的字节时，循环会终止，因为这个值截短再提升之后会和EOF相等。  在使用<u>无符号字符集</u>的机器上运行时，这会成为死循环。\n\n### 5.1.8 条件操作符\n\nexpression1 ? expression2 : expression3\n\n### 5.1.9 逗号操作符\n\nexpression1 , expression2 ,....,expressionN\n\n### 5.1.10 下标引用、函数调用和结构成员\n\n```c\n//下面两种下标引用方式等价\narray[下标]\n*(array+(下标))\n    \n//结构变量访问成员\ns.a\n//结构指针访问成员\np->a\n```\n\n## 5.3左值和右值\n\n一般来说，佐治就是那些能够出现在赋值符号左边的东西，右值就是那些可以出现在赋值符号右边的东西。\n\n```c\na=b+10;\n//a是左值，b+10这个整体是右值。\n//a在后续使用可以出现 xxx=a的形式，因此，a还可以当作右值\n//b+10不能出现b+10=xxx的形式，因此，b+10不能当作左值\n```\n\n## 5.4 表达式求值\n\n### 5.4.1隐式类型转换\n\n```c\nchar a,b,c;\n...\na=b+c;\n//b、c的值被提升为普通整型再做加法运算，结果将被截短再存入a中\n```\n\n### 5.4.2 算术转换\n\n```c\nint a=5000;\nint b=25;\nlong c=a*b;\n//第三行在32位整数的机器上运行无问题，但是在16位整数的机器\n//上会出现乘法运算溢出。  可以改为以下形式\nlong c=(long)a*b\n```\n\n### 5.4.3操作符的属性\n\n复杂表达式的求值顺序由3个因素决定：操作符的优先级、操作符的结合性、操作符是否控制执行的顺序。\n\n## 警告的总结\n\n1.有符号值得右移位操作是不可移植的。\n\n2.移位操作的位数是个负值。\n\n3.连续赋值中各个变量的长度不一。\n\n4.误用=而不是==进行比较。\n\n5.误用|替代||，或误用&替代&&。\n\n6.在不同的用于表示布尔值的非零值之间进行比较。\n\n7.表达式赋值的位置并不决定表达式计算的精度。\n\n8.编写结果依赖于求值顺序的表达式。\n\n## 编程提示总结\n\n1.使用复合赋值符可以使程序更易于维护。\n\n2.使用条件操作符替代if语句以简化表达式。\n\n3.使用逗号操作符来消除多余的代码。\n\n4.不要混用整型和布尔型值。\n\n\n\n\n\n\n\n# 6、指针\n\n## 6.1 内存和地址\n\n变量名字和内存位置之间的关联并不是由硬件所提供的，它是由编译器为我们实现的。所有这些变量给我们一种更方便的方法记住地址--**硬件仍然通过地址访问内存位置**。\n\n\n\n## 6.4 间接访问操作符\n\n间接访问：通过一个指针访问它所指向的地址的过程。又称引用指针。\n\n```c\nint a=100;\nint *p=a;\n//p本身存储的是a的地址。通过*p可以访问到a的地址获取值100.\n```\n\n## 6.5 未初始化和非法指针\n\n```c\nint *a;\n*a=12;\n//a指针未初始化，我们不知道a所存储的地址到底是何处。\n//因此，每次构建指针的时候一定要初始化指针所存储的地址。\n\n//比如\nint p=12;\na=p;    //这一步给了a一个地址\n*a=1；\n//同样的还可以  int *a=p;\n```\n\n## 6.6NULL指针\n\nNULL指针表示不指向任何东西。要使一个指针变量未NULL，你可以给它赋一个零值。   它可以用来判断某个特定指针目前是否有指向什么东西。\n\n在使用一个指针前，可以优先判断它是不是NULL指针。\n\n\n\n## 6.7指针、间接访问和左值\n\n指针变量可以作为左值，是因为它们是变量，而不是因为它们是指针。\n\n\n\n## 6.8指针、间接访问和变量\n\n```c\n*&a=25；\n//&操作符产生a的地址，*操作访问这个地址，最后将25存入该地址。\n```\n\n上句结果和a=25相同。但是上句设计更多的操作，容易降低代码的可读性。\n\n\n\n## 6.9指针常量\n\n```c\nint a=100;\n*(int *)100=25;  \n//强制类型转换把100从“整型”变为“指向整型的指针”\n```\n\n这个技巧的主要用途是访问某个具体的地址。例如，操作系统需要与输入输出设备控制器通信，启动I/O操作并从前面的操作中获得结果。\n\n## 6.10指针表达式\n\n```c\nchar ch='a';\nchar *cp=ch;\n*cp+1  //取出cp指向地址的内容'a'并+1\n*(cp+1) //获取cp所指向地址的后一个地址。数组的下标操作基于此式\ncp++  //将cp所指向的地址移向下一块地址\n    \n*cp++  //1.++操作符产生cp的一份拷贝。2.++操作符增加cp的值。\n       //3.在cp的拷贝上执行间接访问操作\n```\n\n```c\nstrlen(char *string){\n\tint length=0;\n    //依次访问字符串的内容，计算字符数，直到遇见NULL终止符\n    while(*string++ != '\\0')\n        length+=1;\n    return length;\n}\n//这个函数统计的确实是字符串的长度，但是没有统计首个字符，\n//而是用'\\0'代替首字符进行统计\n```\n\n\n\n## 6.13指针运算\n\n如果p是指向x类型的指针，那么p+1就是指向下一个x类型的指针。\n\n1.p+i得到p之后第i个x类型的指针。\n\n2.指针-指针，结果是两个指针在内存中的距离\n\n\n\n```c\nfor(vp=&values[N_VALUES];vp>&values[0]; )\n\t*--vp=0;\n\nfor(vp=&values[N_VALUES-1];vp>=&values[0];vp--)\n    *vp=0;\n//第二个循环结束之后vp会发生越界\n```\n\n\n\n## 警告的总结\n\n1.错误地对一个未初始化的指针变量进行解引用。\n\n2.错误地对一个NULL指针进行解引用。\n\n3.像函数错误地传递NULL指针。\n\n4.未检测到指针表达式的错误，从而导致不可预测的结果。\n\n5。对一个指针进行减法运算，是它非法地指向了数组第1个元素的前面的内存位置。\n\n\n\n## 编程提示的总结\n\n1.一个值应该只具有一种意思。\n\n2.如果指针并不只想任何有意义的东西，就把它设置为NULL。\n\n# 7、函数\n\n\n\n## 7.5递归和迭代\n\n对于计算阶乘和斐波那契数列来说，递归并没有提供任何优越之处，而且效率非常低。\n\n递归通过栈实现。\n\n迭代即递推。计算阶乘和斐波那契数列用迭代效率会高非常多。\n\n## 7.6可变参数列表\n\n目的：让一个函数在不同时候接受不同数目的参数。\n\n### 7.6.1 stdarg宏\n\n头文件:stdarg.h\n\n这个头文件声明了 一个类型va_list 和三个宏——va_start、va_arg、va_end。\n\n函数声明一个名叫var_arg的变量，用于访问参数列表的未确定部分。该变量通过va_start初始化。它的第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数。初始化过程把var_arg变量设置为指向可变参数部分的第1个参数。\n\n为了访问参数，需要使用va_arg，这个宏接受两个参数：va_list变量和参数列表中下一个参数的类型。    在有些函数中，你可能要通过前面获得的数据来判断下一个参数的类型。va_arg返回这个参数的值，并使var_arg指向下一个可变参数。\n\n最后，当访问完毕最后一个可变参数之后，我们需要调用va_end。\n\n```c\n//计算指定数量的值的平均值\n#include<stdarg.h>\nfloat average(int n_values,...)\n{\n    va_list var_arg;\n    int count;\n    float sum=0;\n    //准备访问可变参数\n    va_start(var_arg,n_values);\n    //添加取自可变参数列表的值\n    for(count=0;count<n_values;count++){\n        sum+=va_arg(var_arg,int );//第二个参数表示下一个参\t\t\t\t\t\t\t\t\t//数的类型\n    }\n    //完成处理可变参数\n    va_end(var_arg);\n    return sum/n_values;\n}\n```\n\n不过，va_arg无法正确识别作用于可变参数之上的缺省参数类型提升。char、short、float类型的值实际上将作为int或double类型的值传递给函数。\n\n\n\n## 警告的总结\n\n1.错误地在其他函数的作用域内编写函数原型。\n\n2.没有为那些返回值不是整型的函数编写原型。\n\n3.把函数原型和旧式风格的函数定义混合使用。\n\n4.在va_arg中使用错误的参数类型，导致未定义的结果。\n\n\n\n## 编程提示的总结\n\n1.在函数原型中使用参数名，可以给使用该函数的用户提供更多的信息。\n\n2.抽象数据类型可以减少程序对模块实现细节的依赖，从而提高程序的可靠性。\n\n3.当递归定义清晰的有点可以补偿它的效率开销时，就可以使用这个工具。\n\n# 8、数组\n\n数组本质是指针。\n\n## 8.1一维数组\n\n### 8.1.2 下标引用\n\n```c\n//这两句话等价\narray[subscript];\n*(array+(subscript));\n```\n\n```c\nint *ap=array+2;\n\n*ap+6   //相当于array[2]+6\n*(ap+6) //相当于array[2+6]\nap[-1]  //array[1]\n\n2[array] //等价于array[2],不过不推荐写\n```\n\n指针有时比下标更有效率。\n\n### 8.1.5 数组和指针\n\n```c\nint a[5];\nint *b;\n//*a合法，*b不合法。因为*b会访问内存中的未知位置\n//b++合法，a++非法。因为a的值是个常量\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f046617758484a1c82c01cddb19053fe.png#pic_center)\n\n\n### 8.1.8初始化\n\n```c\n//完整初始化\nint vector[5]={10,20,30,40,50};\n//不完整初始化\nint vector[5]={1,2,3}; //未初始化的部分默认为0。不能出现超出数\t\t\t\t\t//组范围的初始化\n//自动计算长度\nint vector[]={1,2,3};\n\n//字符数组初始化\nchar message[]={'H','e','l','l','o',0};\nchar message[]=\"Hello\";\n```\n\n\n\n```c\nchar message1[]=\"Hello\";\nchar *message2=\"Hello\";\n//这两种声明方式的结果有区别，见下图\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d2d87e0a8cb04607a8d21cfffa3ebc9f.png#pic_center)\n\n\n\n\n## 8.2多维数组\n\n```c\nint array[3][6];\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4997fed084a44f968a91a7b7ce3a6603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 8.2.3 下标\n\n```c\nint matrix[3][10];\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/902d4976d75043479557dc15bcb0d04f.png#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/9e36d195a27b405882161ac1868c841e.png#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/301a2eb948cc4186a1c3306115b04d9c.png#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/754c2e734dfd478fbb5393393c8c63ef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/18027cd177c34864ab75d92b7c9c755e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n### 8.2.4指向数组的指针\n\n```c\nint vector[10], *vp=vector;  //合法\nint matrix[3][10], *mp=matrix;  //非法\n//matrix是一个指向整型数组的指针\n\n//声明一个指向整型数组的指针\nint (*p)[10];\n//初始化\nint (*p)[10]=matrix;  //p指向matrix的第一行\n\n\n//两种方式创建一个简单的整型指针\nint *pi=&matrix[0][0];\nint *pi=matrix[0];\n```\n\n\n\n### 8.2.5作为函数参数的多维数组\n\n```c\nint matrix[3][10];\n//两种等价引用\nvoid func(int (*matrix)[10]);\nvoid func(int mat[][10]);\n```\n\n\n\n### 8.2.6初始化\n\n```c\nint matrix[2][3]={100,101,102,110,111,112};\n\nint matrix[3][5]={\n    {00,01,02,03,04},\n    {10,11,12,13,14},\n    {20,21,22,23,24}\n};\n\n//初始化一个三维数组\nint three_dim[2][3][5]={\n    {\n        {000,001,002,003,004},\n        {010,011,012,013,014},\n        {020,021,022,023,024}\n    },\n    {\n        {100,101,102,103,104},\n        {110,111,112,113,114},\n        {120,121,122,123,124}\n    }\n};\n\n\n//初始化一个四维数组\nint four_dim[2][2][3][5]={\n    {\n        {\n            {0000,0001,0002,0003,0004},\n            {0010,0011,0012,0013,0014},\n            {0020,0021,0022,0023,0024}\n        },\n        {\n            {0100,0101,0102,0103,0104},\n            {0110,0111,0112,0113,0114},\n            {0120,0121,0122,0123,0124}\n        }\n    },\n    {\n        {\n            {1000,1001,1002,1003,1004},\n            {1010,1011,1012,1013,1014},\n            {1020,1021,1022,1023,1024}\n        },\n        {\n            {1100,1101,1102,1103,1104},\n            {1110,1111,1112,1113,1114},\n            {1120,1121,1122,1123,1124}\n        }\n    }\n};\n\n\n\n\n//长度自动计算\nint matrix[][5]={\n    {00,01,02},\n    {10,11},\n    {20,21,22,23}\n};\n```\n\n## 8.3指针数组\n\n```c\nint *api[10];  //api数组存的是整数型指针\n\nchar const keyword[]={\n    \"do\",\n    \"for\",\n    \"if\",\n    \"register\",\n    \"return\",\n    \"switch\",\n    \"while\"\n};\n```\n\n\n\n## 警告的总结\n\n1.当访问多维数组的元素时，误用逗号分隔下标。\n\n2.在一个指向未指定长度的数组的指针上执行指针运算。\n\n## 编程提示的总结\n\n1.一开始就编写良好的代码显然比依赖编译器来修正劣质代码更好。\n\n2.源代码的可读性几乎总是比程序的运行时效率更为重要。\n\n3.只要有可能，函数的指针形参都应该声明为const。\n\n4.在有些环境中，使用register关键字提高程序的运行时效率。\n\n5.在多维数组的初始值列表中使用完整的多层花括号能提高可读性。\n\n# 9、字符串、字符和字节\n\n## 9.2字符串长度\n\n```c\nif(strlen(x)>=strlen(y)) ...\nif(strlen(x)-strlen(y)>=0)...\n//第二个判断将永远为真，因为strlen返回一个无符号数，无符号数\n//不可能减出一个负值\n```\n\n## 9.5字符串查找基础\n\n### 9.5.1查找一个字符\n\n```c\nchar *strchr(char const *str, int ch);//查找ch第一次出现的位置\nchar *strrchr(char const *str, int ch);//查找ch最后出现的位置\n\nchar string[20]=\"Hello there, honey.\";\nchar *ans;\nans=strchr(string,'h');\n//ans所致的位置将是string+7\n```\n\n\n\n### 9.5.2查找任何几个字符\n\n```c\nchar *strpbrk(char const *str, char const *group);\n//该函数返回一个指向str中第1个匹配group中任何一个字符的字符位置，未找到则返回NULL指针\n\nchar string[20]=\"Hello there, honey.\";\nchar *ans;\nans=strchr(string,'aeiou');\n//ans将指向string+1\n```\n\n\n\n### 9.5.3查找一个字串\n\n```c\nchar *strstr(char const *s1, char const *s2);\n//该函数在s1中查找整个s2第一次出现的 起始位置\n//不过标准库中没有 strrstr 函数，需要自己实现。\n\n#include<string.h>\nchar *my_strrstr(char const *s1, char const *s2){\n    //在s1中查找字符串s2最右出现的位置，并返回一个该位置的指针\n    register char *last;\n    register char *current;\n    //把指针初始化为我们已经找到的前一次匹配位置\n    last=NULL;\n    //旨在第2个字符串不为空时才进行查找，若s2为空，返回NULL。\n    if(*s2!='\\0'){\n        //查找s2在s1中第1次出现的位置\n        current=strstr(s1,s2);\n        //我们每次找到字符串时，让指针指向它的起始位置，然后查找该字符串的下一个匹配位置\n        while(current!=NULL){\n            last=current;\n            current=strstr(last+1,s2);\n        }\n    }\n    //返回指向我们找到的最后一次匹配的起始位置的指针\n    return last;\n}\n```\n\n\n\n## 9.6高级字符串查找\n\n### 9.6.1查找一个字符串前缀\n\n```c\nsize_t strspn(char const *str, char const *group);\n//返回str起始部分匹配group中仍以字符的字符数\nint len1,len2;\nchar buffer[]=\"25,142,330,Smith,J,239-4123\";\n\nlen1=strspn(buffer,\"0123456789\");  //len1=2\nlen2-strspn(buffer,\",0123456789\");  //len2=11\n\n\nsize_t strcspn(char const *str, char const *group);\n//返回str字符串起始部分中不与group中任何字符匹配的字符数。\n```\n\n\n\n### 9.6.2查找标记\n\n```c \nchar *strtok(char *str, char const *sep);\n//sep定义了用作分隔符的 字符集合 。strtok找到str的下一个标记，并将其用NULL结尾，然后返回一个指向这个标记的指针。\n//str会被修改\n//如果第1个参数是NULL，函数就在同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记\n\n\n#include<stdio.h>\n#include<string.h>\nvoid print_tolens(char *line){\n//从一个字符数组中提取空白字符分割的标记并把它们打印出来(每行一个)。\n    static char whitespace[]=\" \\t\\f\\r\\v\\n\";\n    char *token;\n    \n    for(token=strtok(line,whitespace);\n       token!=NULL;\n       token=strtok(NULL,whitespace)) //第一个参数为NULL，因此直接从token的位置开始寻找下一处分隔标记\n          printf(\"Next token is %s\\n\",token);\n}\n```\n\n## 9.7错误信息\n\n```c\nchar *strerror(int error_number);\n//该函数把其中一个错误代码作为参数并返回一个指向用于描述错误的字符串指针\n```\n\n\n\n## 9.8字符操作\n\n头文件：ctype.h\n\n### 9.8.1字符分类\n\n| 函数     | 如果它的参数复合下列条件就返回真                             |\n| -------- | ------------------------------------------------------------ |\n| iscntrl  | 任何控制字符                                                 |\n| isspace  | 空白字符：空格' '、换页'\\f'、换行'\\n'、回车'\\r'、制表符'\\t \\v' |\n| isdigit  | 十进制数字0~9                                                |\n| isxdigit | 十六进制数字，包括所有十进制数字。a(A)~f(F)                  |\n| islower  | 小写字母a~z                                                  |\n| isupper  | 大写字母A~Z                                                  |\n| isalpha  | 大小写字母                                                   |\n| isalnum  | 字母或数字                                                   |\n| ispunct  | 标点符号，任何不属于数字或字母的图形字符                     |\n| isgraph  | 任何图形字符                                                 |\n| isprint  | 任何可打印字符，包括图形字符和空白字符                       |\n\n### 9.8.2字符转换\n\n```c\nint tolower(int ch); //字母转小写\nint toupper(int ch);\n```\n\n\n\n## 9.9内存操作\n\n目的：避免非字符串数据内部包含零值的情况，这类情况无法使用字符串函数来处理，因为当它们遇到第一个NULL字节时将停止工作。\n\n注：任何类型的指针都可以转换为void* 指针\n\n```c \nvoid *memcpy(void *dst, void const *src, size_t length);\n//从src的起始位置赋值length个字节到dst的内存起始位置\nvoid *memmove(void *dst, void const *src, size_t length);\nvoid *memcmp(void const *a, void const *b, size_t length);\nvoid *memchr(void const *a, int ch, size_t length);\nvoid *memset(void *a, int ch, size_t length);\n\n//这些函数整体功能和str系列函数差不多，但它们可以处理包括NULL字节在内的任意字节\n```\n\n\n\n## 警告的总结\n\n1.应该使用有符号数的表达式中使用strlen函数。\n\n2.在表达式中混用有符号数和无符号数。\n\n3.使用strcpy函数把一个长字符串复制到一个较短的数组中，导致溢出。\n\n4.使用strcat函数把一个字符串添加到一个数组中，导致数组溢出。\n\n5.使用strcmp函数返回值当作布尔值进行测试。\n\n6.把strcmp函数的返回值与1和-1比较。\n\n7.使用并非以NULL字节结尾的字符序列。\n\n8.使用strncpy函数产生不以NULL字节结尾的字符串。\n\n9.把strncpy函数和strxxx族函数混用。\n\n10.忘了strtok函数将会修改它所处理的字符串。\n\n11.strtok函数是不可再入的。\n\n\n\n## 编程提示总结\n\n1.不要试图自己编写技能相同的函数来取代库函数。\n\n2.使用字符分类和转换函数可以提高函数的移植性。\n\n\n\n\n\n# 10、结构体和联合\n\n与数组不同，每个结构体成员都有自己的名字，它们都是通过名字访问的。\n\n## 10.1结构体基础\n\n### 10.1.1结构体声明\n\n```c\nstruct {\n    int a;\n    char b;\n    float c;\n}x;\n\nstruct {\n    int a;\n    char b;\n    float c;\n}y[20],*z;   //这种声明和上一个声明再编译器中是两种不同的类型，即\t\t\t使它们的成员列表完全相同。\n//因此，z=&x;  非法\n```\n\n```c\n//利用标签创建变量\nstruct SIMPLE{\n    int a;\n    char b;\n    float c;\n};\nstruct SIMPLE x;\nstruct SIMPLE y[20],*z;\n\n//利用typedef\ntypedef struct{\n    int a;\n    char b;\n    float c;\n}Simple;\n\nSimple x;\nSimple y[20],*z;\n```\n\n### 10.1.3成员访问\n\n```c\ntypedef struct{\n    int a;\n    char b;\n    float c;\n}Simple;\n\n//一般访问\nSimple x;\nx.a;\n//指针访问\nSimple *p=&x;\n(*p).a;     p->a;\n```\n\n\n\n### 10.1.5结构体自引用\n\n```c\nstruct SELF_REF{\n\tint a;\n\tint c;\n\tstruct SELF_REF *b;   \n};//自引用必须是指针而不是一般结构体，因为编译器再结构体的长度确定之前就已经知道指针的长度。\n```\n\n### 10.1.6不完整声明\n\n```c\n//构建两个互相引用的结构体\nstruct B;  //不完整声明\nstruct A{\n\tstruct B *partner;\n};\nstruct B{\n\tstruct A *partner;\n};\n```\n\n\n\n### 10.1.7结构体初始化\n\n```c\ntypedef struct{\n    int a;\n    char b;\n    float c;\n}Simple;\n\nstruct INIT_EX{\n    int a;\n    short b[10];\n    Simple c;\n}x={\n    10,\n    {1,2,3,4,5},\n    {25,'x',1.9};\n}\n```\n\n\n\n## 10.3结构的存储分配\n\n```c\nstruct ALIGN{\n    char a;\n    int b;\n    char c;\n};  //成员在编译时会按声明顺序进行存储\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/141678bd480d48ccb3648f5b301e9291.png#pic_center)\n显然，a后面会先浪费3个空间再存b，为了节省空间，可以如下声明\n\n```c\nstruct ALIGN{\n    int b\n    char a；\n    char c;\n}; \n\n//sizeof操作可以得出一个结构体的整体长度，包括上述浪费的空间。\n\n//如果必须确定结构某个成员的实际位置，可以使用offsetof宏(stddef.h)\noffsetof(type , memeber);\n//如 offsetof(struct ALIGN, b); 会返回b的首地址\n```\n\n## 10.4作为函数参数\n\n若不使用指针传递，一个大体量的结构体的值传递将会花费较大资源拷贝一个备份传入堆栈，函数调用完之后又要删除，这样效率很低。\n\n推荐使用指针传递，为了防止结构体被修改，可以将指针引用声明为const。\n\n另外，还可以把参数声明为寄存器变量，从而进一步提高指针传递方案的效率。\n\n```c\nvoid f(register SIMPLE const *trans);\n```\n\n\n\n## 10.5位段\n\n```c\n//声明\nstruct CHAR{\n    unsigned ch\t\t:7;\n    unsigned font\t:6;\n    unsigned size\t:19;\n};\nstruct CHAR ch1;\n//该结构体可以处理128(2^7)个不同的字符值、64(2^6)种不同的字体、0~524287个单位的长度。\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/dfc12bddf6db4a2e9a62a500cb192fd2.png#pic_center)\n另一个使用位段的理由就是它们可以很方便地访问一个整型值得部分内容。\n\n例：操作系统中，用于操作软盘的代码必须与磁盘控制器通信。这些设备控制器常常包含了几个寄存器，每个寄存器又包含了许多包装在一个整型值内的不同的值。位段就是一种方便访问这些单一值得方法。假定磁盘控制器其中一个寄存器是如下定义的：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/05a40d45b9504366845c805038ae5167.png#pic_center)\n\n\n前5个位段每个都占1位，其余几个位段更长一些。在一个从右向左分配位段的机器上，下面这个声明允许程序方便对这个寄存器的不同位段进行访问。\n\n```c\nstruct DISK_REGISTER_FORMAT{\n    unsigned command\t\t:5;\n    unsigned sector\t\t\t:5;\n    unsigned track\t\t\t:9;\n    unsigned error_code\t\t:8;\n    unsigned head_loaded\t:1;\n    unsigned write_protect\t:1;\n    unsigned disk_spinning\t:1;\n    unsigned error_occurred\t:1;\n    unsigned ready\t\t\t:1;\n};\n\n\n//假如磁盘寄存器是在内存地址0xc0200142进行访问的，我们可以声明下面的指针常量\n#define DISK_REGISTER \\\n\t((struct DISK_REGISTER_FORMAT *)0xc0200142)\n\n//告诉控制器从哪个扇区哪个磁道开始读取\nDISK_REGISTER->sector=new_sector;\nDISK_REGISTER->track=new_track;\nDISK_REGISTER->command=new_READ;\n\n//等待，知道操作完成(ready变量变成真)\nwhile(!DISK_REGISTER->ready)  ;\n\n//检查错误\nif(DISK_REGISTER->error_occurred){\n    switch(DISK_REGISTER->error_code){\n            ...\n    }\n}\n\n\n//赋值\n#define DISK_REGISTER (unsigned int*)0xc0200142  //与前一个define作用相同\n*DICK_REGISTER &=0XFFFFFC1F; //使用与操作把sector字段清零，但不影响其他字段\n*DISK_REGISTER |= (new_sector & 0x1f) <<5; //接受new_sector的值，&确保这个值不会超过这个位段的宽度。接着，把它左移到合适的位置，然后再用 | 把这个字段设置为重要的值\n```\n\n\n\n## 10.6联合\n\n目的：在<u>不同的时刻</u>把不同的东西存储在同一个位置。\n\n```c\nunion{\n\tfloat f;\n\tint i;\n}fi;\n//分配给联合的内存数量取决于它的最长成员的长度\n```\n\n事实上，假如union的存储长度很长，但是某一时刻它实际存入的内容很短，这就会造成资源浪费。为了节省空间，可以让union存储不同类型的指针，所有指针的存储长度是相同的。\n\n### 10.6.2初始化\n\n```c\nunion{\n\tint a;\n\tfloat b;\n\tchar c[4];\n}x={5}; //初始值必须是联合第1个成员的类型\n```\n\n## 警告的总结\n\n1.具有相同成员列表的结构声明产生不同类型的变量。\n\n2.使用typedef位一个自引用的结构体定义名字时应该小心。\n\n3.向函数传递结构参数是低效的。\n\n## 编程提示总结\n\n1.把结构标签声明和结构的typedef声明放在头文件中，当源文件需要这些声明时可以通过#include进行引用。\n\n2.结构成员的最佳排列方式并不一定就是考虑边界对齐而浪费内存空间最少的那种排列形式(要在可读性和省空间之间有所权衡)。\n\n3.把位段成员显式地声明为signed int 或unsigned int 类型。\n\n4.位段是不可移植的。\n\n5.位段使源代码中位的操作表达得更为清楚。\n\n# 11、动态内存分配\n\n基本函数：malloc(分配内存)、free(释放内存)\n\n头文件：stdlib.h\n\n```c\nvoid *malloc(size_t size); //分配一个指定大小的连续内存，若操作系统无法向malloc提供更多内存，malloc会返回NULL指针\ncoid free(void *pointer); //参数要么是NULL，要么是先前从malloc、calloc、realloc返回的值\n```\n\n## 11.3calloc和realloc\n\n```c\nvoid *calloc(size_t num_elements, size_t element_size);//返回的指针会顺便初始化\nvoid *realloc(void *ptr, size_t new_size);//修改一个原先已经分配的内存块的大小\n```\n\n## 11.4使用例\n\n```c\nint *pi;\npi=malloc(100);\nif(pi==NULL){ //错误检查\n    printf(\"Out of memory.\\n\");\n    exit(0);\n}\n\n//分配一个足够存储25个整数的内存\npi=malloc(25*sizeof(int)); //可移植\n//对pi既可以进行*pi++操作，还可以进行pi[i]操作\n```\n\n## 11.5常见的动态内存错误\n\n错误分类：\n\n1.对NULL指针进行解引用。\n\n2.对分配的内存进行操作时越界。\n\n3.释放并非动态分配的内存。\n\n4.试图释放一块动态分配的内存的一部分。\n\n5.一块动态内存被释放之后被继续使用。\n\n```c\nalloc.h\n//定义一个不易发生错误的内存分配器\n#include<stdlib.h>\n#define malloc     //不要直接调用malloc\n#define MALLOC(num , type)  (type*)alloc((num)*sizeof(type))\nextern void *alloc(size_t size);\n//alloc可以调用malloc并进行检查，确保返回的指针不是NULL\n```\n\n```c\n//接口\n#include<stdio.h>\n#include \"alloc.h\"\n#undef malloc\nvoid *alloc(size_t size){\n    void *new_mem;\n    //请求所需的内存，并检查确实分配成功\n    new_mem=malloc(size);\n    if(new_mem==NULL){\n        printf(\"Out of memory.\\n\");\n        exit(1);\n    }\n    return new_mem;\n}\n```\n\n```c \n//实现\n#include \"alloc.h\"\nvoid function(){\n    int *new_memory;\n    //获得一串整型数的空间\n    new_memory=MALLOC(25,int);\n}\n```\n\n#### 不要访问被free释放的内存\n\n```c\nint *p=malloc(100);\nint *q=p;\nfree(p);\n//p释放后，q也不能再使用，除非改变了q的内容\n```\n\n#### 内存泄漏\n\n分配内存但在使用完毕后不释放将引起内存泄露(memory leak)。这会一点点榨干可用内存，除非重启系统。\n\n## 警告的总结\n\n1.不检查从malloc函数返回的指针是否为NULL。\n\n2.访问动态分配内存之外的区域。\n\n3.向free函数传递一个并非由malloc番薯返回的指针。\n\n4.在动态内存被释放之后再访问它。\n\n## 编程提示总结\n\n1.动态内存分配有助于消除程序内部存在的限制。\n\n2.使用sizeof计算出具类型的长度，提高程序的可移植性。\n\n\n\n\n\n# 12、使用结构和指针\n\n\n\n## 12.3双链表\n\n注：读代码时可以在草稿纸上模拟链表操作\n\n```c\n//双链表结点定义   doubly_linked_list_node.h\ntypedef struct NODE{ \n    struct NODE *fwd;\n    struct NODE *bwd;\n    int value;\n}Node;\n```\n\n### 12.3.1双链表插入操作的优化\n\n```c\n//一般的双链表插入函数\n#include<stdlib.h>\n#include<stdio.h>\n#include \"doubly_linked_list_node.h\"\nint dll_insert(Node *rootp, int value)\n{\n    Node *this;\n    Node *next;\n    Node *newnode;\n    /*\n    \t查看value是否已经存在于链表中，如果是就返回。\n    \t否则，为心的值创建一个新节点(newnode指向它)\n    \t\"this\"指向新节点之前的那个结点\n    \t\"next\"指向新节点之后的那个结点\n    */\n    for(this=rootp ; (next=this->fwd)!=NULL;this=next){\n        if(next->value==value) return 0;\n        if(next->value>value) break;\n    }\n    \n    newnode=(Node *)malloc(sizeof(Node));\n    if(newnode==NULL) return -1;\n    newnode->value=value;\n    \n    //把新值添加到链表中\n    if(next!=NULL){\n        //情况1、2：并非位于链表尾部\n        \n        if(this!=rootp){//情况1：并非位于链表起始位置\n            newnode->fwd=next;\n            this->fwd=newnode;\n            newnode->bwd=this;\n            next->bwd=newnode;\n        }\n        else{\t\t\t//情况2：位于链表起始位置\n            newnode->fwd=next;\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n            next->bwd=newnode;\n        }\n    }\n    else{\n        //情况3、4：位于链表尾部\n        \n        if(this!=rootp){//情况3：并非位于链表起始位置\n            newnode->fwd=NULL;\n            this->fwd=newnode;\n            newnode->bwd=this;\n            rootp->bwd=newnode;\n        }\n        else{\t\t\t//情况4：位于链表起始位置\n            newnode->fwd=NULL;\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n            rootp->bwd=newnode;\n        }\n    }\n    return 1;\n}\n```\n\n仔细分析可以发现，不同情况中存在相同的操作，可以进行提炼化简代码\n\n```c\n//第一次逻辑提炼\nif(next!=NULL){\n        //情况1、2：并非位于链表尾部\n        \n        newnode->fwd=next;\n        if(this!=rootp){//情况1：并非位于链表起始位置\n            this->fwd=newnode;\n            newnode->bwd=this;\n        }\n        else{\t\t\t//情况2：位于链表起始位置\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n        }\n    \tnext->bwd=newnode;\n    }\n    else{\n        //情况3、4：位于链表尾部\n        \n        newnode->fwd=NULL;\n        if(this!=rootp){//情况3：并非位于链表起始位置\n            this->fwd=newnode;\n            newnode->bwd=this;\n        }\n        else{\t\t\t//情况4：位于链表起始位置\n            rootp->fwd=newnode;\n            newnode->bwd=NULL;\n        }\n        rootp->bwd=newnode;\n    }\n```\n\n这个过程其实还可以简化。先看一个例子\n\n```c\nif(pointer !=NULL) field=pointer;\nelse field=NULL;\n\n//上面的判断本质上等价于下句\nfield=pointer\n\n//因此，之前代码的if(next != NULL)判断可以用这种方法化简\nnewnode->fwd=next;\nif(this!=rootp){\n    this->fwd=newnode;\n    newnode->bwd=this;\n}\nelse{\n    rootp->fwd=newnode;\n    newnode->bwd=NULL;\n}\n\nif(next!=NULL) next->bwd=newnode;\nelse rootp->bwd=newnode;\n```\n\n```c\n//最终版本\n\n#include<stdlib.h>\n#include<stdio.h>\n#include \"doubly_linked_list_node.h\"\nint dll_insert(Node *rootp, int value)\n{\n    register Node *this;\n    register Node *next;\n    register Node *newnode;\n    /*\n    \t查看value是否已经存在于链表中，如果是就返回。\n    \t否则，为心的值创建一个新节点(newnode指向它)\n    \t\"this\"指向新节点之前的那个结点\n    \t\"next\"指向新节点之后的那个结点\n    */\n    for(this=rootp ; (next=this->fwd)!=NULL;this=next){\n        if(next->value==value) return 0;\n        if(next->value>value) break;\n    }\n    \n    newnode=(Node *)malloc(sizeof(Node));\n    if(newnode==NULL) return -1;\n    newnode->value=value;\n    \n    //把新值添加到链表中\n    newnode->fwd=next;\n    this->fwd=newnode;\n    \n    if(this!=rootp) newnode->bwd=this;\n    else newnode->bwd=NULL;\n    \n    if(next!=NULL) next->bwd=newnode;\n    else rootp->bwd=newnode;\n    \n    return 1;\n}\n```\n\n\n\n## 警告的总结\n\n1.落到链表尾部的后面。\n\n2.使用指针时应格外小心，因为C并没有对它们的使用提供安全网。\n\n3.从if语句中提炼语句可能会改变测试结果。\n\n\n\n## 编程提示的总结\n\n1.消除特殊情况使代码更易于维护。\n\n2.通过提炼语句消除if语句中的重复语句。\n\n3.不要仅仅根据代码的大小评估它的质量。\n\n# 13、高级指针话题\n\n## 13.2高级声明\n\n```c\nint *f();   //声明一个函数，它返回一个指向整型的指针\nint (*f)(); //声明一个函数的指针，它指向的函数返回一个整型值\n\nint *(*f)(); //和上一句相同，但必须对其进行间接访问操作才能得到整型值\n\nint *f[]; //f是一个数组，它的元素类型是指向整型的指针。\nint f()[];  //f是一个函数，它的返回值是一个整型数组。不过这个声明是非法的，因为这里的函数只能返回标量值。\nint f[]();   //f是个数组，它的元素类型是返回值为整型的函数。这个声明也是非法的，因为数组元素必须有相同的长度。\n\nint (*f[])(); //这个声明是合法的。先求*f[]，f是一个元素为某种类型的指针的数组。然后看()号，说明f的数组元素是函数指针，这些指针所指向的函数的返回值是一个整型值\n\nint *(*f[])(); //与上一句同理，只是多了个间接访问符\n\n\n/*==============================================================*/\n\n\nint (*f)(int ,float);\nint *(*g[])(int ,float);\n//前者把f声明为一个函数指针，这个函数接受int和float两个类型的参数。\n//后者则是一个存函数指针的数组\n```\n\n\n\n## 13.3函数指针\n\n```c\nint f(int);\nint (*pf)(int)=&f;\n\n//调用\nint ans;\nans=f(25);\nans=(*pf)(25);\nans=pf(25);\n```\n\n### 13.3.1回调函数\n\n向函数传递一个指向值的指针而不是值本身。函数有一个void* 形参，用于接收这个参数。  这样字符串和数组对象也可以被调用。字符串和数组无法作为参数传递给函数，但是指向它们的指针可以。\n\n```c\n/*\n\t在一个单链表中查找一个指定值的函数，它的参数是一个指向链表第1个结点的指针，一个指向我们需要查找的值的指针和一个函数指针，它所指向的函数用于比较存储与链表中的类型的值。\n*/\n#include<stdio.h>\n#include \"node.h\"\n\nNode* search_list(Node *node, void const *value.\n          int(*compare)(void const *, void const *))\n{\n    while(node!=NULL){\n        if(compare(&node->value,value)==0) break;\n        node=node->link;\n    }\n    return node;\n}//类型无关的链表查找\n```\n\n### 13.1.2转换表\n\n```c\n//简易计算器\nswitch(oper){\n    case ADD:\n        result=add(op1,op2);\n        break;\n    case SUB:\n    \tresult=sub(op1,op2);\n    \tbreak;\n    case MUL:\n        result=mul(op1,op2);\n        break;\n    case DIV:\n        result=div(op1,op2);\n        break;\n}\n\n//函数声明\ndouble add(double,double);\ndouble sub(double,double);\ndouble mul(double,double);\ndouble div(double,double);\n...\ndouble (*oper_func[])(double,double)={\n    add,sub,mul,div...\n};\n\n//这一句可以取代一开始的switch语句\nresult=oper_func[oper](op1,op2);\n//oper从数组中选择正确的函数指针，而函数调用操作符将执行这个函数\n```\n\n\n\n## 13.4命令行参数\n\nC的main函数有两个形参。第1个通常称为argc，它表示命令行参数的数目。第2个通常称为argv，它指向一组参数值的首元素。这些元素的每个都是指向一个参数文本的指针。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/88e9265027894b09b20bbc12a94ff49a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n\n\n\n```c\n//处理命令行参数\n#include<stdio.h>\n#define TRUE 1\n\n//执行实际任务的函数的原型\nvoid process_standard_input(void);\nvoid process_file(char *file_name);\n\n//选项标志，缺省初始化为FALSE\nint option_a, option_b;\n\nvoid main(int argc, char **argv){\n    //处理选项参数:跳到下一个参数，并检查它是否以一个横杠开头\n    while(*++argv!=NULL && **argv=='-'){\n        //检查横杠后面的字母\n        switch(*++*argv){\n            case 'a':\n                option_a=TRUE;\n                break;\n            case 'b':\n                option_b=TRUE;\n                break;\n        }\n    }\n    \n    //处理文件名参数\n    if(*argv==NULL) process_standard_input();\n    else {\n        do{\n            process_file(*argv);\n        }while(*++argv!=NULL);\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/4834227285ee42b0be740071fbfaf504.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e7184cea80084c7b836aa5ccec45e4be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## 13.5字符串常量\n\n```c\n\"xyz\"     //这就是一个字符串常量，可以通过\"xyz\"[2]得到第3个字符\n\"xyz\"+1;\n*\"xyz\";   //返回'y'\n\nputchar(\"0123456789ABCDEF\"[value%16]);\n//使用余数作为下标打印指定位置的字符串\n```\n\n```c\n//打印星号\n#include<stdio.h>\nvoid f(int n){\n    n+=5;\n    n/=10;\n    printf(\"%s\\n\",\"**********\"+10-n);\n}\n```\n\n\n\n## 警告的总结\n\n1.对一个未初始化的指针执行间接访问操作。\n\n2.在转移表中使用越界下标。\n\n\n\n## 编程提示总结\n\n1.如果并非必要，避免使用多层间接访问。\n\n2.cdecl程序可以帮助你分析复杂的声明。\n\n3.把void* 强制转换为其他类型的指针式必须小心。\n\n4.使用转移表时，应始终验证下标的有效性。\n\n5.破坏性的命令行参数处理方式会使你以后无法再次进行处理。\n\n6.不寻常的diamagnetic始终应该加上一条注释，描述它的目的和原理。\n\n\n\n# 14、预处理器\n\n## 14.1预定义符号\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b4996750fa554fc3bb2cbdc3197506af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## #define\n\n```c\n#define name stuff\n//每当有符号name出现在这条指令后面使，预处理器就会把它替换成stuff\n#define reg register\n#define do_forever for(;;)\n#define CASE break;case\n\n#define DEBUG_PRINT printf(\"File %s line %d:\"\\\n\t\t\t\t\t\t\"x=%d,y=%d,z=%d\",\\\n\t\t\t\t\t\t__FILE__,__LINE__,\\\n\t\t\t\t\t\tx,y,z)\n//内容过长可以用\\代表分行\n#define PROCESS_LOOP  \\\n\tfor(i=0;i<10;i+=1){  \\\n\t\tsum+=i;\t\t\t\\\n\t\tif(i>0) prod*=i;  \\\n\t}\n```\n\n### 14.2.1宏\n\n把参数替换到文本中，这种实现叫做宏（macro）。\n\n```c\n#define SQUARE(x) (x)*(x)    //宏不用分号结尾\nSQUARE(5)  //会被替换成5*5\n    \n//第一句若不写为(x)*(x)，则会出现问题，见下例\nSQUARE(a+1)   //会替换成   a+1*a+1而不是(a+1)*(a+1)\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cdefcd2dc8f047b49dbe42908a52bce3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n\n## 14.2.6#undef\n\n```c\n#undef name\n//如果一个现存的名字需要重新定义，那么它的旧定义首先必须用#undef移除\n```\n\n\n\n## 14.3条件编译\n\n```c\n#if constant-expression\n\tstatements\n#elif constant-expression\n        other statements\n#else\n        other statements\n#endif\n//如果常量表达式的值非零，那么statements部分会被正常编译，否则预处理器会删除它们\n```\n\n## 14.3.1是否被定义\n\n```c\n#if defined(symbol)\n#ifdef symbol\n\n#if !defined(symbol)\n#ifndef symbol\n\n//例\n#if x>0 || defined(A) && defined(B)\n```\n\n## 14.4文件包含\n\n一个头文件如果被包含到10个源文件中，它实际上被编译了10次。\n\n```c\n#include<filename>   //标准库文件\n#include\"filename\"   //自定义头文件\n```\n\n#### 避免多重包含\n\n```c\n#ifdef _HEADERNAME_H\n#define _HEADERNAME_H 1  //如果头文件再次被包含，通过条件编译，它的所有内容被忽略\n\t...//included filenames\n#endif\n```\n\n## 14.5其他指令\n\n```c\n//#error\n#error text of error message    //生成错误信息\n\n//例\n#if defined(OPTION_A)\n\tstuff needed for option A\n#elif defined(OPTION_B)\n\tstuff needed for option B\n#elif defined(OPTION_C)\n\tstuff needed for option C\n#else\n     #error No option selected!\n#endif\n        \n        \n//#line\n#line number \"string\"\n//通知预处理器number是下一行输入的行号。如果给出了可选部分\"string\"，预处理器就把它作为当前文件的名字。\n        \n        \n//#progma   语法因编译器而异\n```\n\n## 警告的总结\n\n1.不要在一个宏定义的末尾加上分号，使其称为一条完整的语句。\n\n2.在宏定义中使用参数，但忘了在它们周围加上括号。\n\n3.忘了在整个宏定义的两边加上括号。\n\n\n\n## 编程提示的总结\n\n1.避免用#define指令定义可以用函数实现的很长序列的代码。\n\n2.在那些对表达式求值的宏中，每个宏参数出现的地方都应该加上括号，并且在整个宏定义的两边也加上括号。\n\n3.避免使用#define宏创建一种新语言。\n\n4.采用命名约定，使程序员很容易看出某个标识符是否为#define宏。\n\n5.只要合适就应该使用文件包含，不必担心它的额外开销。\n\n6.头文件只应该包含一组函数和(或)数据的声明。\n\n7.把不同集合的声明分离到不同的头文件中可以改善信息隐藏。\n\n8.嵌套的#include文件使我们很难判断源文件之间的依赖关系。\n\n\n\n\n\n# 15、输入/输出函数\n\n## 15.1错误报告\n\n```c\n//stdio.h\nvoid perror(char const *message);\n//如果message不是NULL并且指向一个非空的字符串，perror函数就打印出这个字符串，后面跟一个分号和一个空格，然后打印出一条用于解释errno当前错误代码的信息\n//只有当一个库函数失败时，errno才会被设置。因此，只有当被调用的函数提示有错误发生时检查errno的值才有意义\n```\n\n## 15.2终止执行\n\n```c\n//stdlib.h\nvoid exit(int status);   //直接结束程序，status参数返回给操作系统，用于提示程序是否正常完成\n```\n\n## 15.4 ANSI I/O概念\n\n### 15.4.1流\n\nANSI C 中。所有的I/O操作只是简单地从程序移进或移出字节的事情。这种字节流被称为流。\n\n绝大多数流时完全缓冲的，这说明\"读取\"和\"写入\"实际上是从一块被称为缓冲区的内存区域来回复制数据。\n\n用于输出流的缓冲区只有当它写满是才会被刷新(flush, 物理写入)到设备或文件中。 一次性把写满的缓冲区写入和逐片把程序产生的输出分别写入相比效率更高。类似，输入缓冲区当它为空时通过从设备或文件读取下一块较大的输入，重新填充缓冲区。\n\n\n\n### 15.4.2文件\n\nstdio.h中定义了FILE结构，用于访问一个流。\n\n对于每个ANSI C程序，运行时必须提供至少三个流：标准输入(standard input)、标准输出(standard output)和标准错误(standard error)。这些流的名字分别为stdin、stdout、stderr，它们都是一个指向FILE结构的指针。\n\n### 15.4.3标准I/O常量\n\nFOPRN_MAX定义了至少能同时打开多少文件。\n\nFILENAME_MAX用于提示一个字符数组应该多大以便容纳编译器所支持的最长合法文件名\n\n\n\n## 15.5流I/O总览\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c2d2ae90eef6470295b8204d9d414ccc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/84428521ae904aadb5f267d295b0ef61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n\n## 15.6打开流\n\n```c\nFILE *fopen(char const *name, char const *mode);\n//第一个参数是相关的文件名，第二个参数是提示流是用于只读、只写还是读写\n//每次调用这个函数时最好都检查一下它的返回值\nFILE *input;\ninput=fopen(\"data3\",\"r\");\nif(input==NULL){\n    perror(\"data3\");\n    exit(EXIT_FAILURE);\n}\n```\n\n|        | 读取 | 写入 | 添加 |\n| ------ | ---- | ---- | ---- |\n| 文本   | \"r\"  | \"w\"  | \"a\"  |\n| 二进制 | \"rb\" | \"wb\" | \"ab\" |\n\n```c\nFILE *freopen(char const *filename, char const *mode, FILE *stream);\n//这个函数首先试图关闭这个流，然后用指定的文件和模式重新打开这个流。如果打开失败，函数返回一个NULL值。反之，返回它的第3个参数值。\n```\n\n\n\n## 15.7关闭流\n\n```c\nint fclose(FILE *f);\n//对于输出流，该函数在文件关闭之前刷新缓冲区。成功则返回零值，反之返回EOF\n```\n\n## 15.8字符I/O\n\n\n\n```c\n//获取字符\nint fgetc(FILE *stream);\nint getc(FILE *stream);\nint getchar(void);\n\n//输出字符\nint fputc(int character, FILE *stream);\nint putc(int character, FILE *stream);\nint putchar(int cahracter);\n\n//撤销字符\nint ungetc(int character, FILE *stream);\n```\n\n\n\n```c\n//把一串从标准输入读取的数字转换为整数\n#include<stdio.h>\n#include<ctype.h>\nint read_int(){\n    int value=0;\n    int ch;\n    \n    //转换从标准输入读取的数字，当我们得到一个非数字字符时就停止\n    while((ch=getchar())!=EOF && isdigit(ch)){\n        value*=10;\n        value+=ch-'0';\n    }\n    //把非数字字符退回到流中，这样它就不会丢失\n    ugetc(ch,stdin);\n    return value;\n}\n\n//如果用fseek、fsetpos或rewind函数改变了流的位置，所有退回的字符都将被丢弃\n```\n\n## 15.9未格式化的行I/O\n\n未格式化的I/O简单读取或写入字符。而格式化的I/O则执行数字和其他变量的内部和外部表示形式之间的转换。\n\n```c\n//把标准输入读取的文本行逐行复制到标准输出\n#include<stdio.h>\n#define MAX_LINE_LENGTH 1024\n\nvoid copylines(FILE *input. FILE *output){\n    char buffer[MAX_LINE_LENGTH];\n    \n    while(fgets(buffer,MAX_LINE_LENGTH,input)!=NULL)\n        fputs(buffer,output);\n}\n```\n\n\n\n## 15.10格式化的行I/O\n\n## 15.10.1 scanf族\n\n```c\nint fscanf(FILE *stream, char const *format,...);\nint scanf(char const *format,...);\nint sscanf(char const *string, char const *format,...);\n//这些函数都从输入源读取字符并根据format字符串给出的格式化代码对它们进行转换\n\n\n//使用例\nnfields=fscanf(input,\"%4d %4d %4d\",&a,&b,&c);\n//这个宽度参数把整数值的宽度限制为4个数字或更少。\n//输入 1  2 。  此时a=1,b=2,c不变,nfields=2.\n//输入 12345 67890。 此时a=1234,b=5,c=6789,nfields=3\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a8611cd67cf44746a28ef2c17b832cb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n\n```c\n//用sscanf处理行定向(line-oriented)的输入\n#include<stdio.h>\n#define BUFFER_SIZE 100\n\nvoid function(FILE *input){\n    int a,b,c,d,e;\n    char buffer[BUFFER_SIZE];\n    \n    while(fgets(buffer,BUFFER_SIZE,input)!=NULL){\n        if(sscanf(buffer,\"%d %d %d %d %d\",\n                 &a,&b,&c,&d,&e)!=4){\n            \t\tfprintf(stderr,\"Bad input skipped: %s\",\n                            buffer);\n            \t\tcontinue;\n        }\n        //处理输入\n    }\n}\n```\n\n```c\n//使用sscanf处理可变格式的输入\n#include<stdio.h>\n#include<stdlib.h>\n\n#define DEFAULT_A 1\n#define DEFAULT_B 2\n\nvoid function(char *buffer){\n    int a,b,c;\n    //查看3个值是否都已经给出\n    if(sscanf(buffer,\"%d %d %d\",&a,&b,&c)!=3){\n        //否，对a使用缺省值，看看其他两个值是否已经给出\n        a=DEFAULT_A;\n        if(sscanf(buffer,\"%d %d\",&b,&c)!=2){\n            //为b使用缺省值，寻找剩余的值\n            b=DEFAULT_B;\n            if(sscanf(buffer,\"$d\",&c)!=1){\n                fprintf(stderr,\"Bad input: %s\",buffer);\n                exit(EXIT_FAILURE);\n            }\n        }\n    }\n    //处理a,b,c\n}\n```\n\n\n\n### 15.10.3 printf族\n\n```c\nint fprintf(FILE *stream, char const *format, ...);\nint printf(char const *format,...);\nint sprintf(char *buffer, char const *format,...);\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ce890255007c49239b452f6495e403ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3970b1b5dd344867b55c9cafa3a215ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3e100005d3dd47909168b415fc412e1f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n\n\n## 15.11二进制I/O\n\n```c\nsize_t fread(void *buffer, size_t size, size_t count, FILE *stream);\nsize_t fwrite(void *buffer, size_t size, size_t count, FILE *stream);\n//buffer时一个指向用于保存数据的内存位置的指针，size时缓冲区中每个元素的字节数，count时读取或写入的元素数\n```\n\n## 15.12刷新和定位函数\n\n```c\nint fflush(FILE *stream);\n//该函数迫使输出流的缓冲区内的数据进行物理写入，不管它是否已满\n\n//随机访问I/O\nlong ftell(FILE *stream);//返回流当前的位置\nint fseek(FILE *stream, long offset, int from);//改变读写位置\n```\n\n\n\n| 如果from是... | 你将定位到                                                   |\n| ------------- | ------------------------------------------------------------ |\n| SEEK_SET      | 从流的起始位置起offset个字节，offset必须是一个非负值。       |\n| SEEK_CUR      | 从流的当前位置起offset个字节，offset可正可负。               |\n| SEEK_END      | 从流的尾部位置起offset个字节，offset可正可负。如果为正，它将定位到文件尾的后面 |\n\n```c\nvoid rewind(FILE *stream);\n//rewind将读/写指针设置回指定流的起始位置。同时清除流的错误提示信息\nint fgetpos(FILE *stream, fpos_t *position);\nint fsetpos(FILE *stream, fpos_t const *position);\n//后两个函数是rewind的替代方案\n```\n\n## 15.13改变缓冲方式\n\n```c\nvoid setbuf(FILE* stream, char *buf);\n//setbuf设置了另一个数组，用于对流进行缓冲\nint setvbuf(FILE *stream,char *buf, int mode,size_t size);\n//mode参数用于指定缓冲的类型。_IOFBF指定一个完全缓冲的流，_IONBF指定一个不缓存的流，_IOLBF指定一个行缓冲流。\n```\n\n### 15.14流错误函数\n\n```c\n//判断流的状态\nint feof(FILE *stream);\n//如果流当前处于文件尾，feof返回真。这个状态可以通过对流执行feseek、rewind或fsetpos函数来清除\n\nint ferror(FILE *stream);\n//ferror报告流的错误状态，如果出现任何读写错误就返回真\nvoid clearerr(FILE *stream);\n//clearerr对指定流的错误标志进行重置\n```\n\n## 15.15临时文件\n\n```c\nFILE *tmpfile(void);\n//创建一个文件，当文件被关闭或程序终止时这个文件会自动删除\nchar *tmpnam(char *name);\n//给临时文件起名\n```\n\n## 15.16 文件操纵函数\n\n```c\nint remove(char const *filename);\n//删除一个指定文件\nint rename(char const *oldname, char const *newname);\n//重命名指定文件\n```\n\n\n\n## 警告的总结\n\n1.忘了在一条调试用的printf语句后跟一个fflush调用。\n\n2.不检查fopen函数的返回值。\n\n3.改变文件的位置将丢弃任何被退回到流的字符。\n\n4.在使用fgets时指定太小的缓冲区。\n\n5.使用gets的输入溢出缓冲区且违背检测到。\n\n6.使用任何scanf/printf系列函数时，格式代码和参数指针类型不匹配。\n\n7.在任何scanf系列函数的每个非数组、非指针参数前忘了加上&符号。\n\n8.注意在使用scanf系列函数转换double、long double、short和long整型时，在格式化代码中加上合适的限定符。\n\n9.sprintf函数的输出溢出了，且缓冲区未检测到。\n\n10.混淆printf和scanf格式代码。\n\n11.在有些长整数长于普通整数的机器上打印长整数值时，忘了在格式代码中指定l修改符。\n\n12.使用自动数组作为流的缓冲区时多加小心。\n\n\n\n## 编程提示总结\n\n1.在可能出现错误的场合，检查并报告错误。\n\n2.操纵文本行而无需顾及它们的外部表示形式，这有助于提高程序的可移植性。\n\n3.使用scanf限定符提高可移植性。\n\n4.当你打印长整数时，即使你所使用的机器并不重要，坚实使用l修改符可以提高可移植性。\n\n# 16、标准函数库\n\n按需学习，可以直接参考官方文档\n\n## 警告的总结\n\n1.忘了包含math.h头文件导致数学函数产生错误结果。\n\n2.clock函数可能只产生处理器时间的近似值。\n\n3.time函数的返回值并不一定是以秒为单位的。\n\n4.longjmp不能返回到一个已经不在处于活动状态的函数。\n\n5.避免exit函数的多重调用。\n\n\n\n## 编程提示总结\n\n1.滥用setjmp和longjmp可能导致晦涩难懂的代码。\n\n2.对信号进行处理将导致程序的可移植性变差。\n\n3.使用断言可以简化程序的调试。\n\n# 17、经典抽象数据类型\n\n## 17.1堆栈\n\n### 接口\n\n```c\n//stack.h\n#define STACK_TYPE int  //堆栈存储的值的类型\n\n/*\npush\n把一个新值压入栈中\n*/\nvoid push(STACK_TYPE value);\n\n/*\npop\n弹出栈顶的值\n*/\nvoid pop(void);\n\n/*\ntop\n返回栈顶值\n*/\nSTACK_TYPE top(void);\n\n/*\nis_empty\n判断栈是否为空\n*/\nint is_empty(void);\n\n/*\nis_full\n判断栈是否已满\n*/\nint is_full(void);\n```\n\n\n\n### 17.1.1静态数组实现\n\n```c\n/*\n\t用一个静态数组实现堆栈，数组的长度只能通过修改#define定义\n\t并对模块重新进行编译实现\n*/\n\n#include\"stack.h\"\n#include<assert.h>\n\n#define STACK_SIZE 100   //栈的规模\n\n//存储栈中值得数组和一个指向栈顶元素得指针\nstatic STACK_TYPE stack[STACK_SIZE];\nstatic int    top_element=-1;\n\n//push\nvoid push(STACK_TYPE value){\n    assert(!is_full());\n    top_element+=1;\n    stack[top_element]=value;\n}\n\n//pop\nvoid pop(void){\n    assert(!is_empty());\n    top_element-=1;\n}\n\n//top\nSTACK_TYPE top(void){\n    assert(!is_empty());\n    return stack[top_element];\n}\n\n//is_empty\nint is_empty(void){\n    return top_element==-1;\n}\n\n//is_full\nint is_full(void){\n    return top_element==STACK_SIZE-1;\n}\n```\n\n### 17.1.2动态数组实现\n\n先在stack.h文件中加入以下接口\n\n```c\n/*\ncreate_stack\n创建堆栈，参数指定堆栈可以保存多少元素\n*/\nvoid create_stack(size_t size);\n\n/*\ndestory_stack\n销毁堆栈，释放内存\n*/\nvoid destory_stack(void);\n```\n\n\n\n```c\n/*\n一个用动态分配数组实现得堆栈\n堆栈的长度在创建时给出\n*/\n#include\"stack.h\"\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#include<assert.h>\n\n//用于存储栈元素的数组和指向堆栈顶部元素的指针\nstatic STACK_TYPE *stack;\nstatic size_t stack_size;\nstatic int top_element=-1;\n\n//create_stack\nvoid create_stack(size_t size){\n    assert(stack_size==0);\n    stack_size=size;\n    stack=malloc(stack_size*sizeof(STACK_TYPE));\n    assert(stack!=NULL);\n}\n\n//destory_stack\nvoid destory_stack(void){\n    assert(stack_size>0);\n    stack_size=0;\n    free(stack);\n    stack=NULL;\n}\n\n//push\nvoid push(STACK_TYPE value){\n    assert(!is_full());\n    top_element+=1;\n    stack[top_element]=value;\n}\n\n//pop\nvoid pop(void){\n    assert(!is_empty());\n    top_element-=1;\n}\n\n//top\nSTACK_TYPE top(void){\n    assert(!is_empty());\n    return stack[top_element];\n}\n\n//is_empty\nint is_empty(void){\n    return top_element==-1;\n}\n\n//is_full\nint is_full(void){\n    return top_element==stack_size-1;\n}\n```\n\n\n\n\n\n### 17.1.3链式堆栈\n\n```c\n//链表实现栈，这个栈没有长度限制\n#include\"stack.h\"\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#include<assert.h>\n\n#define FALSE 0\n\n//定义一个结构体来存储栈元素，next字段指向下一个元素\ntypedef struct STACK_NODE{\n    STACK_TYPE value;\n    struct STACK_NODE *next;\n}\n\nstatic StackNode *stack;\n\n\n//create_stack\nvoid create_stack(size_t size){\n}\n\n//destory_stack\nvoid destory_stack(void){\n    while(!is_empty()) pop();\n}\n\n//push\nvoid push(STACK_TYPE value){\n    StackNode *new_node;\n    \n    new_node=malloc(sizeof(StackNode));\n    assert(new_node!=NULL);\n    new_node->value=value;\n    new_node->next=stack;\n    stack=new_node;\n}\n\n//pop\nvoid pop(void){\n    StackNode *first_node;\n    \n    assert(!is_empty());\n    first_node=stack;\n    stack=first_node->next;\n    free(first_node);\n}\n\n//top\nSTACK_TYPE top(void){\n    assert(!is_empty());\n    return stack->value;\n}\n\n//is_empty\nint is_empty(void){\n    return stack==NULL;\n}\n\n//is_full\nint is_full(void){\n    return FALSE;\n}\n```\n\n\n\n## 17.2队列\n\n### 接口\n\n```c\n//queue.h\n#include<stdlib.h>\n#define QUEUE_TYPE int //队列元素类型\n\n/*\ncreate_queue\n创建一个队列，参数指定队列最大容量\n*/\nvoid create_queue(size_t size);\n\n/*\ndestory_queue\n销毁一个队列\n*/\nvoid destory_queue(void);\n\n/*\ninsert\n向队列添加一个新元素\n*/\nvoid insert(QUEUE_TYPE value);\n\n/*\ndelete\n从队列中删除一个元素\n*/\nvoid delete(void);\n\n/*\nfirst\n返回队头\n*/\nQUEUE_TYPE first(void);\n\n/*\nis_empty\n判断队列是否为空\n*/\nint is_empty(void);\n\n/*\nis_full\n判断队列是否已满\n*/\nint is_full(void);\n```\n\n\n\n### 17.2.1静态数组实现\n\n```c\n//用静态数组实现队列\n\n#include \"queue.h\"\n#include<stdio.h>\n#include<assert.h>\n\n#define QUEUE_SIZE 100 //队列中元素的最大数量\n#define ARRAY_SIZE (QUEUE_SIZE + 1) //数组长度\n\n//存储队里了元素的数组和指向队列头和尾的指针\nstatic QUEUE_TYPE queue{ARRAY_SIZE};\nstatic size_t front=1;\nstatic size_t rear=0;\n\n//insert\nvoid insert(QUEUE_TYPE value){\n    assert(!is_full());\n    rear=(rear+1)%ARRAY_SIZE;\n    queue[rear]=value;\n}\n\n//delete\nvoid delete(void){\n    assert(!is_empty());\n    front=(front+1)%ARRAY_SIZE;\n}\n\n//first\nQUEUE_TYPE first(void){\n    assert(!is_empty());\n    return queue[front];\n}\n\n//is_empty\nint is_empty(void){\n    return (rear+1)%ARRAY_SIZE==front;\n}\n\n//is_full\nint is_full(void){\n    return (rear+2)%ARRAY_SIZE==front;\n}\n```\n\n\n\n## 17.3树\n\n### 接口\n\n```c\n//tree.h\n#define TREE_TYPE int  //树的值类型\n\n/*\ninsert\n向树添加一个值，这个值原先不存在树中\n*/\nvoid insert(TREE_TYPE value);\n\n/*\nfind\n查找一个特定的值\n*/\nTREE_TYPE *find(TREE_TYPE value);\n\n/*\npre_order_traverse\n先序遍历\n*/\nvoid pre_order_traverse(void (*callback)(TREE_TYPE value));\n```\n\n\n\n## 17.3.1静态数组实现\n\n```c\n//静态数组实现二叉搜索树\n#include \"tree.h\"\n#include<assert.h>\n#include<stdio.h>\n\n#define TREE_SIZE 100  //树的规模\n#define ARRAY_SIZE  (TREE_SIZE+1)\n\n//用于存储树所有节点的数组\nstatic TREE_TYPE tree[ARRAY_SIZE];\n\n/*\nleft_child\n计算一个节点左孩子的下标\n*/\nstatic int left_child(int current){\n    return current*2;\n}\n\n/*\nright_child\n计算一个节点右孩子的下标\n*/\nstatic int right_child(int current){\n    return current*2+1;\n}\n\n//insert\nvoid insert(TREE_TYPE value){\n    int current;\n    //从根节点开始，直到找到那个值，进入合适的子树\n    current=1;\n    \n    while(tree[current]!=0){\n        //根据情况，进入左子树或右子树(确信未出现重复的值)\n        if(value<tree[current])\n            current=left_child(current);\n        else{\n            assert(value!=tree[current]);\n            current=right_child(current);\n        }\n        assert(current<ARRAY_SIZE);\n    }\n    tree[current]=value;\n}\n\n//find\nTREE_TYPE *find(TREE_TYPE value){\n    int current;\n    //确保值非零，因为零用于提示一个未使用的节点\n    assert(value!=0);\n    \n    //从根节点开始\n    current=1;\n    \n    //从合适的子树开始，直到到达一个叶节点\n    while(current<ARRAY_SIZE && tree[current]!=value){\n        //根据情况，进入左子树或右子树\n        if(value<tree[current])\n            current=left_child(current);\n        else\n            current=right_child(current);\n    }\n    if(current<ARRAY_SIZE) return tree+current;\n    else return 0;\n}\n\n\n/*\ndo_pre_order_traverse\n执行一层先序遍历，这个辅助函数用于保存我们当前正在处理的节点信息\n*/\nstatic void do_pre_order_traverse(int current,\n                   void (*callback)(TREE_TYPE value))\n{\n    if(current<ARRAY_SIZE && tree[current]!=0){\n        callback(tree[current]);\n        do_pre_order_traverse(left_child(current),callback);\n        do_pre_order_traverse(right_child(current),callback);\n    }\n}\n\n//pre_order_traverse\nvoid pre_order_traverse(void (*callback)(TREE_TYPE value)){\n     do_pre_order_traverse(1,callback);\n}\n```\n\n\n\n### 17.3.2链表实现\n\n```c\n//链表实现树\n#include \"tree.h\"\n#include<assert.h>\n#include<stdio.h>\n#include<malloc.h>\n\n//TreeNode结构包含了值和两个指向某个树节点的指针\ntypedef struct TREE_NODE{\n    TREE_TYPE value;\n    struct TREE_NODE *left;\n    struct TREE_NODE *right;\n}TreeNode;\n\n//指向树根节点的指针\nstatic TreeNode *tree;\n\n//insert\nvoid insert(TREE_TYPE value){\n    TreeNode *current;\n    TreeNode **link;\n    \n    //从根节点开始\n    link=&tree;\n    //持续查找值，进入合适的子树\n    while((current=*link)!=NULL){\n        //根据情况，进入左子树或右子树(确认无重复值)\n        if(value<current->value) link=&current->left;\n        else{\n            assert(value!=current->value);\n            link=&current->right;\n        }\n    }\n    \n    //分配一个新节点，使适当节点的link字段指向它\n    current=malloc(sizeof(TreeNode));\n    assert(current!=NULL);\n    current->value=value;\n    current->left=NULL;\n    current->right=NULL;\n    *link=current;\n}\n\n//find\nTREE_TYPE *find(TREE_TYPE value){\n    TreeNode *current;\n    \n    //从根节点开始\n    current=tree;\n    \n    //从合适的子树开始，直到到达一个叶节点\n    while(current!=NULL && current->value!=value){\n        //根据情况，进入左子树或右子树\n        if(value<current->value)\n            current=current->left;\n        else\n            current=current->right;\n    }\n    if(current!=NULL) return &current->value;\n    else return NULL;\n}\n\n/*\ndo_pre_order_traverse\n执行一层先序遍历，这个辅助函数用于保存我们当前正在处理的节点信息\n*/\nstatic void do_pre_order_traverse(TreeNode *current,\n                   void (*callback)(TREE_TYPE value))\n{\n    if(current!=NULL){\n        callback(tree[current]);\n        do_pre_order_traverse(current->left,callback);\n        do_pre_order_traverse(current->right,callback);\n    }\n}\n\n//pre_order_traverse\nvoid pre_order_traverse(void (*callback)(TREE_TYPE value)){\n     do_pre_order_traverse(tree,callback);\n}\n```\n\n\n\n## 17.4 实现的改进\n\n1.有时可能会拥有超过一个的堆栈。\n\n可以从堆栈的实现模块中取出数组和top_element的声明，并把它们放入用户代码。\n\n然后，它们通过参数被堆栈函数访问，这些函数便不再固定于某个数组。缺点是这样会丢失封装性，造成非法访问。\n\n2.拥有超过一个类型\n\n有时可能同时需要一个整型栈和一个浮点型栈。\n\n可以把整个堆栈模块实现为一个#define宏，把目标类型作为参数。\n\n还可以让它存储void* 类型的值，绕过类型检查。但是很容易出错。如：一个整数被压入一个元素类型为指针的栈中。\n\n可以设计一个泛型ADT。\n\n3.名字冲突\n\n\n\n## 警告的总结\n\n1.不要使用断言检查内存是否分配成功。\n\n2.数组形式的二叉树节点位置计算公式假定数组的下标从1开始。\n\n3.把数据封装于对它进行操纵的模块可以防止用户不正确地访问数据。\n\n4.与类型无关地函数没有类型检查，所以要确保传递正确类型地数据。\n\n\n\n## 编程提示的总结\n\n1.避免使用具有副作用的函数。\n\n2.一个模块的接口应该避免暴露它的实现细节。\n\n3.将数据类型参数化，使它容易修改。\n\n4.只有模块对外公布的接口才应该使公用的。\n\n5.使用断言来防止非法操作。\n\n6.几个不同的实现使用同一个接口使模块具有更强的可互换性。\n\n7.服用现有的代码而不是对它进行改写。\n\n8.迭代比尾部递归效率更高。\n\n\n\n\n\n# 18、运行时环境\n\n不同机器生成的汇编代码可能会有所不同\n\n## 18.1 判断运行时环境\n\n### 18.1.2静态变量和初始化\n\n```c\n//静态初始化\nint static_variable=5;\n.data\n.enen\n.global _static_variable\n_static_variable:\n.long   5\n```\n\n汇编代码的一开始是两个指令，分别表示进入程序的数据区以及确保变量开始于内存的偶数地址。变量被声明为全局类型，变量名以一个下划线开始。许多C编译器会在C代码所声明的外部名字前加一个下划线，以免与各个库函数所使用的名字冲突。\n\n最后，编译器为变量创建控件，并用适当的值对它进行初始化。\n\n\n\n### 18.1.3堆栈帧\n\n函数分为三部分：函数序(prologue)、函数体(body)、函数跋(epilogue)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/db2f96e630c148169779ddc511216786.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n第一条指令( .text )表示进入程序的代码段。为函数创建堆栈帧，堆栈帧是堆栈中的一个区域，里面存入函数的变量和其他值。\n\n.globl是函数的全局声明\n\n0x3cfc表示寄存器d2到d7、a2到a5中的值需要被存储。（存入堆栈帧）\n\n### 18.1.4寄存器变量\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d2a82b2a7f504abc88437639c2cb81eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1-6存在了一个寄存器中，7-10存到了其他地方。说明最多只能有6个整型值可以被存放在数据寄存器。\n\n\n\n机器使用的地址模型执行间接寻址和索引操作。这种组合工作颇似数组的下标引用。\n\n寄存器a6称为帧指针(frame pointer)，它指向堆栈帧内部的一个\"引用\"位置。a6@(-28)指定了一个偏移地址-28。这个偏移位置从-4开始，每次增长4。（整型值和指针都占4个字节）\n\n\n\n### 18.1.5外部标识符的长度\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6ab22148f9ee4e28a7fa35b920343256.png#pic_center)\n\n\n变量名的长度一般没有限制\n\n### 18.1.6判断堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fb7d25fa4e5e4615862230aca047673e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n前三条指令把函数的参数压入堆栈。被压入的第1个参数存储于a6@(-16)，包含变量i10。然后被压入的是d7，包含变量i1。\n\npea指令简单地把它的操作数压入堆栈。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/730bfba5a8dc42a38bf815edab84884a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\njbsr是跳转子程序(jump subroutine)。它把返回地址压入堆栈，并跳转到_func_ret_int 的起始位置。当被调用函数结束仍无后需要返回到它的调用位置，就要用到这个压入到堆栈中的返回地址。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/99b65c51a0ef4130a84448c6c75d781f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n#### 函数序\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5ac4b52f193c4188b3db5824c5353e2e.png#pic_center)\n\n\n首先，a6的内容被压入栈中。其次，堆栈指针的当前值被复制到a6\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/043db02c1e054d2ea966ba6d159c7580.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n最后，link指令从堆栈指针中-8。这将会创建空间用于保存局部变量和被保存的寄存器值。\n\n下一条指令把一个单一的寄存器保存到堆栈帧。 0x80指定寄存器d7。寄存器存储在堆栈的顶部，它提示堆栈帧的顶部就是寄存器值保存的位置。堆栈帧剩余的部分必然是局部变量存储的地方。\n\n最后(mov指令) 从堆栈复制一个值到d7。\n\n#### 堆栈中的参数顺序\n\n被调用函数使用帧指针加一个偏移量来访问参数。当参数以反序压入到堆栈时，参数列表的第1个参数便位于堆栈中这些参数的顶部，它距离帧指针的偏移量是个常数。\n\n#### 最终的堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/52bb66a4548f40978f535a6a1317dae3.png#pic_center)\n\n\n第1条movl指令是把第2个参数复制到d0。下一条指令将这个值-6，第3条指令把结果存入局部变量d。d0的作用是计算过程中的\"中间结果暂存器\"。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/12fec6e95363444a881c7027a10e6cb3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n接下来的3条指令对return语句进行求值。结果存入d0。\n\n#### 函数跋\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/919b5628fb194e1ba03ae5ff4b123b53.png#pic_center)\n\n\n当返回到调用程序之后执行的第1条指令就是把12加到堆栈指针。这个假发能把参数值从堆栈中取出。\n\n#### 返回值\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9654fe42346a4a63acca44981026d35a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n这个函数没有参数，所以没有东西压入堆栈。这个函数返回后，d0和d1的值都被保存。double的长度为8，返回需要同时用到d0和d1。\n\n## 18.2C和汇编语言的接口\n\n#### 汇编语言程序调用C\n\n1.如果寄存器d0、d1、a0、a1保存了重要的值，它们必须在调用C之前进行保存，因为C不会保存它们的值。\n\n2.任何函数的参数必须以参数列表相反的顺序压入到堆栈中。\n\n3.函数必须由一条\"跳转子程序\"类型的指令调用，它会把返回地址压入堆栈。\n\n4.当C函数返回时，汇编程序必须清楚堆栈中的任何参数。\n\n5.如果汇编程序期望接受一个返回值，它将保存在d0。\n\n6.任何在调用之前进行过保存的寄存器此时可以恢复。\n\n#### C调用汇编程序\n\n1.保存任何你希望修改的寄存器(除了d0、d1、a0、a1)。\n\n2.参数值从堆栈中获得，因为调用它的C函数把参数压入堆栈。\n\n3.如果函数应该返回一个值，它的值应保存在d0中。\n\n4.返回之前，函数必须清楚任何它压入堆栈中的内容。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1ff9747cc8be4bbe8b8291962bce0a20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## 18.3运行时效率\n\n虚拟内存：由操作系统实现，它在需要时把程序的活动部分放入内存并把不活动的部分复制到磁盘中，这样就允许运行大型的程序。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e37be83bd52343fb98135df9cfd84cbe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1.在耗费时间最多的函数中，有些是库函数。\n\n2.有些函数之所以耗费了大量的实践是因为它们被调用的次数多。\n\n3.有些函数调用的次数并不多，但是每次调用所花费的时间很长。\n\n## 警告的总结\n\n1.决定 外部标识符最大长度 的是链接器而不是编译器。\n\n2.你无法链接由不同编译器产生的程序。\n\n\n\n## 编程提示总结\n\n1.使用stdarg实现可变参数列表。\n\n2.改进算法比优化代码更有效率。\n\n3.使用某种环境特有的技巧会导致程序不可移植。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n否分配成功。\n\n2.数组形式的二叉树节点位置计算公式假定数组的下标从1开始。\n\n3.把数据封装于对它进行操纵的模块可以防止用户不正确地访问数据。\n\n4.与类型无关地函数没有类型检查，所以要确保传递正确类型地数据。\n\n\n\n## 编程提示的总结\n\n1.避免使用具有副作用的函数。\n\n2.一个模块的接口应该避免暴露它的实现细节。\n\n3.将数据类型参数化，使它容易修改。\n\n4.只有模块对外公布的接口才应该使公用的。\n\n5.使用断言来防止非法操作。\n\n6.几个不同的实现使用同一个接口使模块具有更强的可互换性。\n\n7.服用现有的代码而不是对它进行改写。\n\n8.迭代比尾部递归效率更高。\n\n\n\n\n\n# 18、运行时环境\n\n不同机器生成的汇编代码可能会有所不同\n\n## 18.1 判断运行时环境\n\n### 18.1.2静态变量和初始化\n\n```c\n//静态初始化\nint static_variable=5;\n.data\n.enen\n.global _static_variable\n_static_variable:\n.long   5\n```\n\n汇编代码的一开始是两个指令，分别表示进入程序的数据区以及确保变量开始于内存的偶数地址。变量被声明为全局类型，变量名以一个下划线开始。许多C编译器会在C代码所声明的外部名字前加一个下划线，以免与各个库函数所使用的名字冲突。\n\n最后，编译器为变量创建控件，并用适当的值对它进行初始化。\n\n\n\n### 18.1.3堆栈帧\n\n函数分为三部分：函数序(prologue)、函数体(body)、函数跋(epilogue)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2821c6aa3864495791b72057f087b08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n第一条指令( .text )表示进入程序的代码段。为函数创建堆栈帧，堆栈帧是堆栈中的一个区域，里面存入函数的变量和其他值。\n\n.globl是函数的全局声明\n\n0x3cfc表示寄存器d2到d7、a2到a5中的值需要被存储。（存入堆栈帧）\n\n### 18.1.4寄存器变量\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/91d4c46bcdf04c4382c6cd44d28c9ead.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1-6存在了一个寄存器中，7-10存到了其他地方。说明最多只能有6个整型值可以被存放在数据寄存器。\n\n\n\n机器使用的地址模型执行间接寻址和索引操作。这种组合工作颇似数组的下标引用。\n\n寄存器a6称为帧指针(frame pointer)，它指向堆栈帧内部的一个\"引用\"位置。a6@(-28)指定了一个偏移地址-28。这个偏移位置从-4开始，每次增长4。（整型值和指针都占4个字节）\n\n\n\n### 18.1.5外部标识符的长度\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c093e565c3484953ad4965fdb9222588.png#pic_center)\n\n\n变量名的长度一般没有限制\n\n### 18.1.6判断堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1e80fada00484e358a581858795fb5a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n前三条指令把函数的参数压入堆栈。被压入的第1个参数存储于a6@(-16)，包含变量i10。然后被压入的是d7，包含变量i1。\n\npea指令简单地把它的操作数压入堆栈。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e00c8110b6694d6dba6cd16a19166a59.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\njbsr是跳转子程序(jump subroutine)。它把返回地址压入堆栈，并跳转到_func_ret_int 的起始位置。当被调用函数结束仍无后需要返回到它的调用位置，就要用到这个压入到堆栈中的返回地址。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0693fbee23b54c8997d538cd88024f3d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n#### 函数序\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2e09d26d1a3a4db288e5003b709e2472.png#pic_center)\n\n\n首先，a6的内容被压入栈中。其次，堆栈指针的当前值被复制到a6\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/94e767c9ad394c60bac01cd603ed4fef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n最后，link指令从堆栈指针中-8。这将会创建空间用于保存局部变量和被保存的寄存器值。\n\n下一条指令把一个单一的寄存器保存到堆栈帧。 0x80指定寄存器d7。寄存器存储在堆栈的顶部，它提示堆栈帧的顶部就是寄存器值保存的位置。堆栈帧剩余的部分必然是局部变量存储的地方。\n\n最后(mov指令) 从堆栈复制一个值到d7。\n\n#### 堆栈中的参数顺序\n\n被调用函数使用帧指针加一个偏移量来访问参数。当参数以反序压入到堆栈时，参数列表的第1个参数便位于堆栈中这些参数的顶部，它距离帧指针的偏移量是个常数。\n\n#### 最终的堆栈帧布局\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6de3b4d9b2ab40f6a9421be75d865ecb.png#pic_center)\n\n\n第1条movl指令是把第2个参数复制到d0。下一条指令将这个值-6，第3条指令把结果存入局部变量d。d0的作用是计算过程中的\"中间结果暂存器\"。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e3f218f778f544eca67a8bf5d75ab033.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n接下来的3条指令对return语句进行求值。结果存入d0。\n\n#### 函数跋\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/736bffced19a4aaa944fe163ed7dd513.png#pic_center)\n\n\n当返回到调用程序之后执行的第1条指令就是把12加到堆栈指针。这个假发能把参数值从堆栈中取出。\n\n#### 返回值\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/cb1b6504bd204711aea8f2a7823ee5c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n这个函数没有参数，所以没有东西压入堆栈。这个函数返回后，d0和d1的值都被保存。double的长度为8，返回需要同时用到d0和d1。\n\n## 18.2C和汇编语言的接口\n\n#### 汇编语言程序调用C\n\n1.如果寄存器d0、d1、a0、a1保存了重要的值，它们必须在调用C之前进行保存，因为C不会保存它们的值。\n\n2.任何函数的参数必须以参数列表相反的顺序压入到堆栈中。\n\n3.函数必须由一条\"跳转子程序\"类型的指令调用，它会把返回地址压入堆栈。\n\n4.当C函数返回时，汇编程序必须清楚堆栈中的任何参数。\n\n5.如果汇编程序期望接受一个返回值，它将保存在d0。\n\n6.任何在调用之前进行过保存的寄存器此时可以恢复。\n\n#### C调用汇编程序\n\n1.保存任何你希望修改的寄存器(除了d0、d1、a0、a1)。\n\n2.参数值从堆栈中获得，因为调用它的C函数把参数压入堆栈。\n\n3.如果函数应该返回一个值，它的值应保存在d0中。\n\n4.返回之前，函数必须清楚任何它压入堆栈中的内容。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0358630ffc9b4ce391b0488aaecab8d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## 18.3运行时效率\n\n虚拟内存：由操作系统实现，它在需要时把程序的活动部分放入内存并把不活动的部分复制到磁盘中，这样就允许运行大型的程序。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/8b46ef0f59044d3992c2410bb6ca2170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n1.在耗费时间最多的函数中，有些是库函数。\n\n2.有些函数之所以耗费了大量的实践是因为它们被调用的次数多。\n\n3.有些函数调用的次数并不多，但是每次调用所花费的时间很长。\n\n## 警告的总结\n\n1.决定 外部标识符最大长度 的是链接器而不是编译器。\n\n2.你无法链接由不同编译器产生的程序。\n\n\n\n## 编程提示总结\n\n1.使用stdarg实现可变参数列表。\n\n2.改进算法比优化代码更有效率。\n\n3.使用某种环境特有的技巧会导致程序不可移植。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":[],"tags":["读书笔记（技术书籍）"]},{"title":"What's_米家？","url":"/posts/51802/","content":"\n\n# 💩  What's 米家❓ 💩\n\n# 米家发展简史\n\n- 2019年x月y日，<u>dyc</u>于xxx市塘下中学开始传播米家思想，自封零少，并~~擅自~~指名<u>林米</u>为大少、<u>lwy</u>为二少、<u>smd</u>为三少，为未来米家的建立提供了思想基础建设与基础人才储备。\n- 2019年12月z日，陈九日加入米家，按照加入时间成为四少。由于此时的大少掌握大部分资源却无心建设米家，于是四少开始暗中拉帮结派，决心击败林米并成为大少，亲自完成创建米家的重要历史任务。\n- 2020年1月b日，陈九日暗中用大米贿赂lwy，并顺手拉拢新成员<u>谢荣扣</u>（五少）后，以迅雷不及掩耳之势快速击败了林米，自封大少，林米则降级为四少。随后，陈九日全心全意投入到创建米家的任务中。\n- 2020年7月8日，陈九日于<u>xxx市塘下中学351A寝室</u>聚集所有米家成员，宣布了米家的成立，米家势力从此登上历史舞台。\n\n![](/gallery/What's_米家_images/米家交接仪式.jpg)\n\n<p align=\"center\">7月8日米家成立，米家成员留下珍贵合照\n</p>\n\n\n\n![](/gallery/What's_米家_images/米家合照.jpg)\n\n<p align=\"center\">米家大少交接仪式</p>\n\n\n\n- 2020年9月初  在陈九日的计划下，米家成员开始分布至大陆各地，西部有新疆根据地（三少），中部有山西根据地（林少），东部有杭州主根据地（其他成员）。大少力求在大陆多个地区同步实现米家势力的快速发展，米家成员现已渗透医学（三少）、小学教育（零少）、经济（大少、二少、五少）、外语教育（四少）多个行业。随着米家成员的增加，米家的发展将会更加多元化。\n- <strong>至今，米家的发展仍在继续❗❗❗❗❗❗❗❗❗❗❗</strong>\n","categories":[],"tags":["娱乐  高中回忆"]},{"title":"Hello World","url":"/posts/16107/","content":"\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","categories":[],"tags":[]}]