{"title":"《C 和指针阅读笔记》","slug":"《C和指针》阅读笔记","date":"2022-01-31","updated":"2022-01-31","comments":true,"path":"api/posts/46293.json","excerpt":null,"cover":"https://img-blog.csdnimg.cn/fa5282ca3d5a4ee08e03a2b4a024ded8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center","covers":["https://img-blog.csdnimg.cn/fa5282ca3d5a4ee08e03a2b4a024ded8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/1fa72c6ed15f44e19b422c6f3fb51bae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/803a3f7cef044dc18166e9a9973009b8.png#pic_center","https://img-blog.csdnimg.cn/f046617758484a1c82c01cddb19053fe.png#pic_center","https://img-blog.csdnimg.cn/d2d87e0a8cb04607a8d21cfffa3ebc9f.png#pic_center","https://img-blog.csdnimg.cn/4997fed084a44f968a91a7b7ce3a6603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/902d4976d75043479557dc15bcb0d04f.png#pic_center","https://img-blog.csdnimg.cn/141678bd480d48ccb3648f5b301e9291.png#pic_center","https://img-blog.csdnimg.cn/dfc12bddf6db4a2e9a62a500cb192fd2.png#pic_center","https://img-blog.csdnimg.cn/05a40d45b9504366845c805038ae5167.png#pic_center","https://img-blog.csdnimg.cn/88e9265027894b09b20bbc12a94ff49a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/4834227285ee42b0be740071fbfaf504.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/e7184cea80084c7b836aa5ccec45e4be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/b4996750fa554fc3bb2cbdc3197506af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/cdefcd2dc8f047b49dbe42908a52bce3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/c2d2ae90eef6470295b8204d9d414ccc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/84428521ae904aadb5f267d295b0ef61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/a8611cd67cf44746a28ef2c17b832cb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/ce890255007c49239b452f6495e403ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/3970b1b5dd344867b55c9cafa3a215ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/3e100005d3dd47909168b415fc412e1f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/db2f96e630c148169779ddc511216786.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/d2a82b2a7f504abc88437639c2cb81eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/6ab22148f9ee4e28a7fa35b920343256.png#pic_center","https://img-blog.csdnimg.cn/fb7d25fa4e5e4615862230aca047673e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/730bfba5a8dc42a38bf815edab84884a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/99b65c51a0ef4130a84448c6c75d781f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/5ac4b52f193c4188b3db5824c5353e2e.png#pic_center","https://img-blog.csdnimg.cn/043db02c1e054d2ea966ba6d159c7580.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/52bb66a4548f40978f535a6a1317dae3.png#pic_center","https://img-blog.csdnimg.cn/12fec6e95363444a881c7027a10e6cb3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/919b5628fb194e1ba03ae5ff4b123b53.png#pic_center","https://img-blog.csdnimg.cn/9654fe42346a4a63acca44981026d35a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/1ff9747cc8be4bbe8b8291962bce0a20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/e37be83bd52343fb98135df9cfd84cbe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/2821c6aa3864495791b72057f087b08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/91d4c46bcdf04c4382c6cd44d28c9ead.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/c093e565c3484953ad4965fdb9222588.png#pic_center","https://img-blog.csdnimg.cn/1e80fada00484e358a581858795fb5a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/e00c8110b6694d6dba6cd16a19166a59.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/0693fbee23b54c8997d538cd88024f3d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/2e09d26d1a3a4db288e5003b709e2472.png#pic_center","https://img-blog.csdnimg.cn/94e767c9ad394c60bac01cd603ed4fef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/6de3b4d9b2ab40f6a9421be75d865ecb.png#pic_center","https://img-blog.csdnimg.cn/e3f218f778f544eca67a8bf5d75ab033.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/736bffced19a4aaa944fe163ed7dd513.png#pic_center","https://img-blog.csdnimg.cn/cb1b6504bd204711aea8f2a7823ee5c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/0358630ffc9b4ce391b0488aaecab8d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center","https://img-blog.csdnimg.cn/8b46ef0f59044d3992c2410bb6ca2170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"],"content":"<p>《C 和指针》 Kenneth 著</p>\n<p>CSDN:<a href=\"https://blog.csdn.net/INFINITE_WAR/article/details/121294114\">https://blog.csdn.net/INFINITE_WAR/article/details/121294114</a></p>\n<p>@[toc]</p>\n<h1 id=\"1、快速上手\"><a href=\"#1、快速上手\" class=\"headerlink\" title=\"1、快速上手\"></a>1、快速上手 </h1><p> 预处理指令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_COLS 20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_INPUT 1000</span></span><br></pre></td></tr></table></figure>\n\n<p>这些指令由预处理器解释，预处理器读入源代码，根据预处理指令对其进行 <u> 修改</u>，然后把修改过的源代码递交给编译器。</p>\n<p>用 #define 定义的常量一般用大写加以区分，且该变量不能被赋值。</p>\n<p>当预处理语句过多时，可以把它们打包到一个自定义头文件中，然后直接引用该头文件即可，这样还能避免由于同一个声明的多份拷贝而导致的维护性问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">*  读取、处理和打印剩余的输入行</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (gets(input)!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Original input : $s\\n&quot;</span>,input);</span><br><span class=\"line\">    rearrange(output, input, n_columns,columns);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Rearranged line: %s\\n&quot;</span>, output);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要多在代码中写进必要的注释，以此来解释清楚什么地方的代码是什么功能，这样过一段时间后别人 (或自己) 重看一遍这部分代码会很容易理解，更有利于维护。同时，更新代码时也要注意相关注释的更新。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 读取列标号，如果超出规定范围则不予理会</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">read_column_numbers</span><span class=\"params\">(<span class=\"keyword\">int</span> columns[],<span class=\"keyword\">int</span> max)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>声明的数组不用附带长度，这种特性允许函数操纵任意长度的一维数组， 缺点就是不能获取数组的长度。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch=getchar();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(ch!=EOF &amp;&amp; ch!=<span class=\"string\">&#x27;\\n&#x27;</span>)   <span class=\"comment\">//EOF 本质上是个整数值</span></span><br><span class=\"line\">    ch=getchar();</span><br></pre></td></tr></table></figure>\n\n<p>这块代码用于一个个读取字符直至到达文件末尾（或者读到换行符）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">*  处理输入行，将指定列的字符连接在一起，输出行以 NULL 结尾</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rearrange</span><span class=\"params\">(<span class=\"keyword\">char</span> *output,<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *input,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">              <span class=\"keyword\">int</span> n_columns,<span class=\"keyword\">int</span> <span class=\"keyword\">const</span> columns[])</span></span></span><br></pre></td></tr></table></figure>\n\n<p>数组本质上就是指针，因此传入的参数不是数组的备份而是指针，也就是说，在函数内对数组参数的修改会影响函数外部的实际数组。为了避免修改数组，可以将参数声明为 const 。</p>\n<h2 id=\"警告与总结\"><a href=\"# 警告与总结\" class=\"headerlink\" title=\"警告与总结\"></a>警告与总结</h2><p>1. 在 scanf 函数的标量参数前未添加 &amp; 字符。</p>\n<p>2. 机械的把 printf 函数的格式代码照搬于 scanf 函数。</p>\n<p>3. 在应该使用 &amp;&amp; 操作符的地方误用了 &amp; 操作符。</p>\n<p>4. 误用 = 操作符而不是 == 操作符来测试相等性。</p>\n<h2 id=\"编程提示的总结\"><a href=\"# 编程提示的总结\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 使用 #include 指令避免重复声明</p>\n<p>2. 使用 #define 指令给常量值取名。</p>\n<p>3. 在 #include 文件中放置函数原型。</p>\n<p>4. 在使用下标前先检查它们的值。</p>\n<p>5. 在 while 或 if 表达式中蕴含赋值操作。</p>\n<p>6. 如何编写一个空循环体。</p>\n<p>7. 始终要进行检查，去日报数组不越界。</p>\n<h1 id=\"2、基本概念\"><a href=\"#2、基本概念\" class=\"headerlink\" title=\"2、基本概念\"></a>2、基本概念 </h1><h2 id=\"2-1- 环境\"><a href=\"#2-1- 环境\" class=\"headerlink\" title=\"2.1 环境\"></a>2.1 环境</h2><h3 id=\"2-1-1- 翻译环境\"><a href=\"#2-1-1- 翻译环境\" class=\"headerlink\" title=\"2.1.1 翻译环境\"></a>2.1.1 翻译环境</h3><p> 翻译阶段，一个 (或多个) 源文件 (Source code) 通过编译 (Complier) 过程分别转换为目标代码 (Object code)。然后，这些目标代码由链接器(linker) 捆绑在一起，形成一个可执行 (executable) 程序。</p>\n<p>编译过程：</p>\n<p>​    1. 预处理器处理。预处理在源代码上执行一些文本操作。如：用实际值代替 #define 等命令，读入#include 包含的文件。</p>\n<p>​    2. 解析，判断语句的意思。随后产生目标代码 (机器指令的初步形式，用于实现程序的语句)。   如果我们在编译程序的命令行中假如了要求进行优化的选项，优化器(optimizer) 可以进一步处理目标代码，使其效率更高(优化过程更耗时间)。<br><img src=\"https://img-blog.csdnimg.cn/fa5282ca3d5a4ee08e03a2b4a024ded8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>下面以 UNIX 为例进行编译和链接</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1、编译并连接一个完全包含于一个源文件的 C 程序</span></span><br><span class=\"line\">cc program.c</span><br><span class=\"line\"><span class=\"comment\">// 会产生一个 a.cout 可执行程序。中间会产生 program.o 目标文件, 不</span></span><br><span class=\"line\"><span class=\"comment\">// 过它在连接过程完成后会被删除。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2、编译并链接几个 C 源文件</span></span><br><span class=\"line\">cc main.c sort.c lookup.c</span><br><span class=\"line\"><span class=\"comment\">// 当编译的源文件超过一个时，目标文件不会被删除</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3、编译一个 C 源文件，并把它和现存的目标文件链接在一起</span></span><br><span class=\"line\">cc main.o lookup.o sort.c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4、编译单个 C 源文件，并产生一个目标文件，以后再进行链接</span></span><br><span class=\"line\">cc -c program.c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5、编译几个 C 源文件，并为每个文件产生一个目标文件</span></span><br><span class=\"line\">cc -c main.c sort.c lookup.c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//6、链接几个目标文件</span></span><br><span class=\"line\">cc main.o sort.o lookup.o</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2- 执行环境\"><a href=\"#2-1-2- 执行环境\" class=\"headerlink\" title=\"2.1.2 执行环境\"></a>2.1.2 执行环境 </h3><p> 执行过程：</p>\n<p>​    1. 程序被载入到内存中（由操作系统完成）。哪些不存储在堆栈中的尚未初始化的变量将会初始化。</p>\n<p>​    2. 通过一个小型启动程序和目标程序链接在一起。然后调用 main 函数。</p>\n<p>​    3. 程序会使用一个运行时 <strong> 堆栈 </strong>，它用于存储函数的局部变量和返回地址。   同时程序也会使用<strong> 静态 </strong> 内存，其中的变量在整个过程中会一直保留原本的值。</p>\n<p>​    4. 程序结束。可以是末尾 return 0；正常结束，也可以是中途报错直接结束。</p>\n<h2 id=\"2-2- 词法规则\"><a href=\"#2-2- 词法规则\" class=\"headerlink\" title=\"2.2 词法规则\"></a>2.2 词法规则 </h2><h3 id=\"三字母词\"><a href=\"# 三字母词\" class=\"headerlink\" title=\"三字母词\"></a> 三字母词 </h3><p> 通过??x 的形式可以转义出其他符号，部分样例如下表</p>\n<table>\n<thead>\n<tr>\n<th>??(</th>\n<th>[</th>\n<th></th>\n<th>??&lt;</th>\n<th>{</th>\n<th></th>\n<th>??=</th>\n<th>#</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>??)</td>\n<td>]</td>\n<td></td>\n<td>??&gt;</td>\n<td>}</td>\n<td></td>\n<td>??/</td>\n<td>\\</td>\n</tr>\n<tr>\n<td>??!</td>\n<td>|</td>\n<td></td>\n<td>??’</td>\n<td>^</td>\n<td></td>\n<td>??-</td>\n<td>~</td>\n</tr>\n</tbody></table>\n<p>现在转义一般用 ‘ \\ ’。三字母词平时其实非常少见。</p>\n<h1 id=\"3、数据\"><a href=\"#3、数据\" class=\"headerlink\" title=\"3、数据\"></a>3、数据 </h1><h2 id=\"3-1- 基本数据类型\"><a href=\"#3-1- 基本数据类型\" class=\"headerlink\" title=\"3.1 基本数据类型\"></a>3.1 基本数据类型</h2><h3 id=\"3-1-1- 整型\"><a href=\"#3-1-1- 整型\" class=\"headerlink\" title=\"3.1.1 整型\"></a>3.1.1 整型</h3><h4 id=\"整型字面值\"><a href=\"# 整型字面值\" class=\"headerlink\" title=\"整型字面值\"></a> 整型字面值 </h4><p> 字面值如 1，2，FF 这些数值，它们本身不能再改变。</p>\n<p>变量的最小范围</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>最小范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char</td>\n<td>0-127</td>\n</tr>\n<tr>\n<td>signed char</td>\n<td>-127-127</td>\n</tr>\n<tr>\n<td>unsigned char</td>\n<td>0-255</td>\n</tr>\n<tr>\n<td>short int</td>\n<td>-32767-32767</td>\n</tr>\n<tr>\n<td>unsigned short int</td>\n<td>0-65535</td>\n</tr>\n<tr>\n<td>int</td>\n<td>-32767-32767</td>\n</tr>\n<tr>\n<td>unsigned int</td>\n<td>0-65535</td>\n</tr>\n<tr>\n<td>long int</td>\n<td>-2147483647-2147483647</td>\n</tr>\n<tr>\n<td>unsigned long int</td>\n<td>0-4294967295</td>\n</tr>\n</tbody></table>\n<p>头文件 limits.h 说明了各种不同的整数类型的特点。</p>\n<p>如：CHAR_BIT 是字符型的位数，CHAR_MIN、CHAR_MAX 定义了缺省字符类型的范围。 MB_LEN_MAX 规定了一个多字节字符最多允许的字符数量。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>signed</th>\n<th>signed</th>\n<th>unsigned</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类型</td>\n<td>最小值</td>\n<td>最大值</td>\n<td>最大值</td>\n</tr>\n<tr>\n<td>字符</td>\n<td>SCHAR_MIN</td>\n<td>SCHAR_MAX</td>\n<td>UCHAR_MAX</td>\n</tr>\n<tr>\n<td>短整型</td>\n<td>SHRT_MIN</td>\n<td>SHRT_MAX</td>\n<td>USHRT_MAX</td>\n</tr>\n<tr>\n<td>整型</td>\n<td>INT_MIN</td>\n<td>INT_MAX</td>\n<td>UNIT_MAX</td>\n</tr>\n<tr>\n<td>长整型</td>\n<td>LONG_MIN</td>\n<td>LONG_MAX</td>\n<td>ULONG_MAX</td>\n</tr>\n</tbody></table>\n<p>事实上，不同的机器中 char 可能有不同范围的值。</p>\n<h4 id=\"枚举类型 -enumerated\"><a href=\"# 枚举类型 -enumerated\" class=\"headerlink\" title=\"枚举类型 (enumerated)\"></a> 枚举类型(enumerated)</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Jar_Type</span>&#123;</span>CUP=<span class=\"number\">8</span>,PINT=<span class=\"number\">16</span>,QUART=<span class=\"number\">32</span>,</span><br><span class=\"line\">\t\t\tHALF_GALLON=<span class=\"number\">64</span>,GALLON=<span class=\"number\">128</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上例中，Jar_Type 被声明为一个枚举类型，CUP、PINT 等为符号常量，后续可以直接引用。</p>\n<p>假如没有设置 CUP、PINT 等符号等于什么值，那么默认 CUP=0、PINT=1 以此类推。</p>\n<p>假如有的符号有设置值，而有的没有，那未设置值的符号，默认比前一个符号大 1。</p>\n<h3 id=\"3-1-2- 浮点类型\"><a href=\"#3-1-2- 浮点类型\" class=\"headerlink\" title=\"3.1.2 浮点类型\"></a>3.1.2 浮点类型 </h3><p> 头文件 float.h 定义了名字 FLT_MAX、DBL_MAX 和 LDBL_MIN，分别表示 float、double 和 long double 所能存储的最大值。对应的 xxx_MIN 存最小值。</p>\n<h3 id=\"3-1-3- 指针\"><a href=\"#3-1-3- 指针\" class=\"headerlink\" title=\"3.1.3 指针\"></a>3.1.3 指针 </h3><h4 id=\"指针常量\"><a href=\"# 指针常量\" class=\"headerlink\" title=\"指针常量\"></a> 指针常量 </h4><p> 每次调用一个函数时，它的局部变量可能每次分配的内存位置都不一样。</p>\n<h4 id=\"字符串常量\"><a href=\"# 字符串常量\" class=\"headerlink\" title=\"字符串常量\"></a>字符串常量 </h4><p> 定义：一串以 NULL 字节结尾的零个或多个字符。存入字符数组中。</p>\n<h2 id=\"3-2 声明\"><a href=\"#3-2 声明\" class=\"headerlink\" title=\"3.2 声明\"></a>3.2 声明</h2><h3 id=\"3-2-2 数组声明\"><a href=\"#3-2-2 数组声明\" class=\"headerlink\" title=\"3.2.2 数组声明\"></a>3.2.2 数组声明</h3><p>C 编译器不会检查数组下标是否越界。</p>\n<p>如果下标值是从那些已知是正确的值 (比如直接声明 a[100]) 计算得来的，就不用检查它的值。如果是其他方法或者用户输入得到的 (比如 a[n]，这里的 n 可以计算得出，也可以用户输入) , 就需要检查它的值防止越界。</p>\n<h3 id=\"3-2-3- 指针声明\"><a href=\"#3-2-3- 指针声明\" class=\"headerlink\" title=\"3.2.3 指针声明\"></a>3.2.3 指针声明</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明一个指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *a;</span><br><span class=\"line\"><span class=\"comment\">// 声明多个指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *b,*c,*d;</span><br><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *message=<span class=\"string\">&quot;Hello world!&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 上一句的具体过程</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *message;</span><br><span class=\"line\">message=<span class=\"string\">&quot;Hello world!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-4 隐式声明\"><a href=\"#3-2-4 隐式声明\" class=\"headerlink\" title=\"3.2.4 隐式声明\"></a>3.2.4 隐式声明</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(x)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 编译器会默认 f 返回整型</span></span><br></pre></td></tr></table></figure>\n\n<p>隐式声明建议不用，很容易降低代码可读性。</p>\n<h2 id=\"3-3-typedef\"><a href=\"#3-3-typedef\" class=\"headerlink\" title=\"3.3 typedef\"></a>3.3 typedef</h2><p>typedef 的目的：为各种数据类型定义新名字。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *ptr_tp_char;</span><br><span class=\"line\">ptr_to_char a;   <span class=\"comment\">// 等价于 char *a;</span></span><br></pre></td></tr></table></figure>\n\n<p>定义类型名最好用 typedef 而不是用 #define，后者无法正确地处理指针类型。</p>\n<h2 id=\"3-4- 常量\"><a href=\"#3-4- 常量\" class=\"headerlink\" title=\"3.4 常量\"></a>3.4 常量</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> *p;   <span class=\"comment\">// 等价于 int *const p;</span></span><br><span class=\"line\"><span class=\"comment\">// 该指针所指向的内容可以修改，但是不能修改地址。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p;</span><br><span class=\"line\"><span class=\"comment\">// 该指针可以修改地址，但不能修改所指向的值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p;</span><br><span class=\"line\"><span class=\"comment\">// 该指针一初始化就不能修改。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一般常量声明</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_ELEMENTS 50</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">const</span> max_elements=<span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure>\n\n<p>定义一个名字常量的好处在于，后续维护程序时，只用修改声明部分就能修改所有相关的地方。</p>\n<h2 id=\"3-6- 链接属性\"><a href=\"#3-6- 链接属性\" class=\"headerlink\" title=\"3.6 链接属性\"></a>3.6 链接属性 </h2><p> 连接属性分类：external(外部)、internal(内部)、none(无)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> k;</span><br><span class=\"line\"><span class=\"comment\">// 声明为 extern 的 k 将是外部文件的一个同名变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"><span class=\"comment\">// 声明为 static 的 b 将为当前的源文件私有</span></span><br><span class=\"line\"><span class=\"comment\">// 在其他源文件中，若链接到一个叫做 b 的变量，那么它引用的将</span></span><br><span class=\"line\"><span class=\"comment\">// 是另一个不同的变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对函数也可以如此声明，这样可以防止外部文件的调用。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7- 存储类型\"><a href=\"#3-7- 存储类型\" class=\"headerlink\" title=\"3.7 存储类型\"></a>3.7 存储类型 </h2><p> 分类：普通内存、运行时堆栈、硬件寄存器</p>\n<p>使用频率高的变量可以声明为寄存器变量(register 关键字)。</p>\n<p>寄存器变量的创建和销毁时间和局部变量相同，但它需要一些额外工作。在一个使用寄存器变量的函数返回之前，这些寄存器先前存储的值必须恢复，确保调用者的寄存器变量未被破坏。 </p>\n<p>当函数开始执行时，它把需要使用的所有寄存器的内容都保存到堆栈中，当函数返回时，这些值再复制回到寄存器中。</p>\n<p>某个特定的寄存器在不同的时刻所保持的值不一定相同。因此，机器不会提供寄存器变量的地址。</p>\n<h4 id=\"初始化\"><a href=\"# 初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化 </h4><p> 静态变量若不显式地初始化，将默认赋值为 0。</p>\n<p>局部变量若不显式地初始化，将会有更多开销，因为当程序链接时还无法判断局部变量的存储位置。<u>局部变量最好显式初始化</u>。</p>\n<h2 id=\"3-8-static- 关键字\"><a href=\"#3-8-static- 关键字\" class=\"headerlink\" title=\"3.8 static 关键字\"></a>3.8 static 关键字</h2><p>static 有两种用法：</p>\n<p>1. 用于函数定义、或用于代码块之外的变量声明时，static 用于修改标识符的链接属性，从 external 改为 internal，但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明它们的源文件中访问。</p>\n<p>2. 用于代码块内部的变量声明时，static 用于修改变量的存储类型，将局部变量转为静态变量，但是变量的链接属性和作用域不受影响。</p>\n<h2 id=\"3-10- 小结\"><a href=\"#3-10- 小结\" class=\"headerlink\" title=\"3.10 小结\"></a>3.10 小结</h2><table>\n<thead>\n<tr>\n<th>变量类型</th>\n<th>声明位置</th>\n<th>是否存于堆栈</th>\n<th>作用域</th>\n<th>如果声明为 static</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>全局</td>\n<td>所有代码块之外</td>\n<td>F</td>\n<td>从声明出到文件尾</td>\n<td>不允许从其他源文件访问</td>\n</tr>\n<tr>\n<td>局部</td>\n<td>代码块起始处</td>\n<td>T</td>\n<td>整个代码块</td>\n<td>变量不存储与堆栈中，它们的值在程序整个执行期一直保持</td>\n</tr>\n<tr>\n<td>形式参数</td>\n<td>函数头部</td>\n<td>T</td>\n<td>整个函数</td>\n<td>不允许</td>\n</tr>\n</tbody></table>\n<h2 id=\"警告的总结\"><a href=\"# 警告的总结\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 在声明指针变量时采用容易误导的写法。</p>\n<p>2. 误解指针声明中初始化的含义。</p>\n<h2 id=\"编程提示总结\"><a href=\"# 编程提示总结\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 为了保持最佳的可移植性，把字符的值限制在有符号和无符号字符范围的交集之内，或者不要在字符上执行算术运算。</p>\n<p>2. 用它们在使用时最自然的形式来表示字面值。</p>\n<p>3. 不要把整型值和枚举值混为一谈。</p>\n<p>4. 不要依赖隐式声明。</p>\n<p>5. 在定义类型的新名字时，使用 typedef 而不是 #define</p>\n<p>6. 用 const 声明其值不会修改的变量。</p>\n<p>7. 使用名字常量而不是字面值常量。</p>\n<p>8. 不要再嵌套的代码块之间使用相同的变量名。</p>\n<p>9. 除了实体的具体定义位置之外，在它的其他声明位置都使用 extern 关键字。</p>\n<h1 id=\"4、语句\"><a href=\"#4、语句\" class=\"headerlink\" title=\"4、语句\"></a>4、语句 </h1><h2 id=\"警告的总结 -1\"><a href=\"# 警告的总结 -1\" class=\"headerlink\" title=\"警告的总结\"></a> 警告的总结</h2><p>1. 编写不会产生任何结果的表达式。</p>\n<p>2. 确信在 if 语句中的语句列表前后加上花括号。</p>\n<p>3. 在 switch 语句中，执行流意外地从一个 case 顺延到下一个 case。</p>\n<h2 id=\"编程提示总结 -1\"><a href=\"# 编程提示总结 -1\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 在一个没有循环体的循环中，用一个分号表示空语句，并让它独占一行。</p>\n<p>2.for 循环的可读性比 whlie 循环强，因为它把用于控制循环的表达式收集起来放在同一处。</p>\n<p>3.switch 语句中必要时使用 default 子句。</p>\n<h1 id=\"5、操作符和表达式\"><a href=\"#5、操作符和表达式\" class=\"headerlink\" title=\"5、操作符和表达式\"></a>5、操作符和表达式</h1><h1 id=\"5-1 操作符\"><a href=\"#5-1 操作符\" class=\"headerlink\" title=\"5.1 操作符\"></a>5.1 操作符</h1><h3 id=\"5-1-1 算术操作符\"><a href=\"#5-1-1 算术操作符\" class=\"headerlink\" title=\"5.1.1 算术操作符\"></a>5.1.1 算术操作符</h3><p>+、-、*、/、%</p>\n<h3 id=\"5-1-2 移位操作符\"><a href=\"#5-1-2 移位操作符\" class=\"headerlink\" title=\"5.1.2 移位操作符\"></a>5.1.2 移位操作符 </h3><p> 操作对象：整数类型</p>\n<p>左移：&gt;&gt;</p>\n<p>右移：&lt;&lt;<br><img src=\"https://img-blog.csdnimg.cn/1fa72c6ed15f44e19b422c6f3fb51bae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>对于有符号值，到底是采用逻辑移位还是算数移位 (会保持当前符号) 取决于编译器。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 该函数返回参数值二进制中值为 1 的位的个数 （初级版本）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count_one_bits</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> value)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ones;</span><br><span class=\"line\">    <span class=\"comment\">// 当这个值还有一些值为 1 的位时。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ones=<span class=\"number\">0</span>;value!=<span class=\"number\">0</span>;value=value&gt;&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(value%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)  </span><br><span class=\"line\">            ones+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ones</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-1-3- 位操作符\"><a href=\"#5-1-3- 位操作符\" class=\"headerlink\" title=\"5.1.3 位操作符\"></a>5.1.3 位操作符</h3><p><img src=\"https://img-blog.csdnimg.cn/803a3f7cef044dc18166e9a9973009b8.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>例：</p>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>00101110</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>b</td>\n<td>01011011</td>\n</tr>\n<tr>\n<td>a&amp;b</td>\n<td>00001010</td>\n</tr>\n<tr>\n<td>a|b</td>\n<td>01111111</td>\n</tr>\n<tr>\n<td>a^b</td>\n<td>01110101</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-4 赋值\"><a href=\"#5-1-4 赋值\" class=\"headerlink\" title=\"5.1.4 赋值\"></a>5.1.4 赋值</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=x=y+<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>该语句 a 和 x 被赋的值可能不同。</p>\n<p>假如 x 是一个字符型变量，那么 y+3 会被截去一段，以便容纳于字符类型的变量中。那么 a 的值将会是这个被截取后的值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">while</span>((ch=getchar())!=EOF)...</span><br></pre></td></tr></table></figure>\n\n<p>EOF 需要的位数比字符型值所能提供的位数要多，这也是 getchar 返回一个整型值而不是字符值的原因。然而，getchar 的返回值首先存入 ch 中会导致它被截短，然后这个截短的值又会和 EOF 比较。</p>\n<p>在使用 <u> 有符号字符集 </u> 的机器上运行时，若读取了一个值为 \\377 的字节时，循环会终止，因为这个值截短再提升之后会和 EOF 相等。  在使用 <u> 无符号字符集 </u> 的机器上运行时，这会成为死循环。</p>\n<h3 id=\"5-1-8- 条件操作符\"><a href=\"#5-1-8- 条件操作符\" class=\"headerlink\" title=\"5.1.8 条件操作符\"></a>5.1.8 条件操作符</h3><p>expression1 ? expression2 : expression3</p>\n<h3 id=\"5-1-9- 逗号操作符\"><a href=\"#5-1-9- 逗号操作符\" class=\"headerlink\" title=\"5.1.9 逗号操作符\"></a>5.1.9 逗号操作符</h3><p>expression1 , expression2 ,….,expressionN</p>\n<h3 id=\"5-1-10- 下标引用、函数调用和结构成员\"><a href=\"#5-1-10- 下标引用、函数调用和结构成员\" class=\"headerlink\" title=\"5.1.10 下标引用、函数调用和结构成员\"></a>5.1.10 下标引用、函数调用和结构成员</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面两种下标引用方式等价</span></span><br><span class=\"line\"><span class=\"built_in\">array</span>[下标]</span><br><span class=\"line\">*(<span class=\"built_in\">array</span>+(下标))</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 结构变量访问成员</span></span><br><span class=\"line\">s.a</span><br><span class=\"line\"><span class=\"comment\">// 结构指针访问成员</span></span><br><span class=\"line\">p-&gt;a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3 左值和右值\"><a href=\"#5-3 左值和右值\" class=\"headerlink\" title=\"5.3 左值和右值\"></a>5.3 左值和右值 </h2><p> 一般来说，佐治就是那些能够出现在赋值符号左边的东西，右值就是那些可以出现在赋值符号右边的东西。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=b+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//a 是左值，b+10 这个整体是右值。</span></span><br><span class=\"line\"><span class=\"comment\">//a 在后续使用可以出现 xxx=a 的形式，因此，a 还可以当作右值</span></span><br><span class=\"line\"><span class=\"comment\">//b+10 不能出现 b+10=xxx 的形式，因此，b+10 不能当作左值</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4- 表达式求值\"><a href=\"#5-4- 表达式求值\" class=\"headerlink\" title=\"5.4 表达式求值\"></a>5.4 表达式求值</h2><h3 id=\"5-4-1 隐式类型转换\"><a href=\"#5-4-1 隐式类型转换\" class=\"headerlink\" title=\"5.4.1 隐式类型转换\"></a>5.4.1 隐式类型转换</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a,b,c;</span><br><span class=\"line\">...</span><br><span class=\"line\">a=b+c;</span><br><span class=\"line\"><span class=\"comment\">//b、c 的值被提升为普通整型再做加法运算，结果将被截短再存入 a 中</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-2- 算术转换\"><a href=\"#5-4-2- 算术转换\" class=\"headerlink\" title=\"5.4.2 算术转换\"></a>5.4.2 算术转换</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">5000</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b=<span class=\"number\">25</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> c=a*b;</span><br><span class=\"line\"><span class=\"comment\">// 第三行在 32 位整数的机器上运行无问题，但是在 16 位整数的机器</span></span><br><span class=\"line\"><span class=\"comment\">// 上会出现乘法运算溢出。  可以改为以下形式</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> c=(<span class=\"keyword\">long</span>)a*b</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-3 操作符的属性\"><a href=\"#5-4-3 操作符的属性\" class=\"headerlink\" title=\"5.4.3 操作符的属性\"></a>5.4.3 操作符的属性 </h3><p> 复杂表达式的求值顺序由 3 个因素决定：操作符的优先级、操作符的结合性、操作符是否控制执行的顺序。</p>\n<h2 id=\"警告的总结 -2\"><a href=\"# 警告的总结 -2\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 有符号值得右移位操作是不可移植的。</p>\n<p>2. 移位操作的位数是个负值。</p>\n<p>3. 连续赋值中各个变量的长度不一。</p>\n<p>4. 误用 = 而不是 == 进行比较。</p>\n<p>5. 误用 | 替代 ||，或误用 &amp; 替代 &amp;&amp;。</p>\n<p>6. 在不同的用于表示布尔值的非零值之间进行比较。</p>\n<p>7. 表达式赋值的位置并不决定表达式计算的精度。</p>\n<p>8. 编写结果依赖于求值顺序的表达式。</p>\n<h2 id=\"编程提示总结 -2\"><a href=\"# 编程提示总结 -2\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 使用复合赋值符可以使程序更易于维护。</p>\n<p>2. 使用条件操作符替代 if 语句以简化表达式。</p>\n<p>3. 使用逗号操作符来消除多余的代码。</p>\n<p>4. 不要混用整型和布尔型值。</p>\n<h1 id=\"6、指针\"><a href=\"#6、指针\" class=\"headerlink\" title=\"6、指针\"></a>6、指针 </h1><h2 id=\"6-1- 内存和地址\"><a href=\"#6-1- 内存和地址\" class=\"headerlink\" title=\"6.1 内存和地址\"></a>6.1 内存和地址</h2><p> 变量名字和内存位置之间的关联并不是由硬件所提供的，它是由编译器为我们实现的。所有这些变量给我们一种更方便的方法记住地址–<strong>硬件仍然通过地址访问内存位置</strong>。</p>\n<h2 id=\"6-4- 间接访问操作符\"><a href=\"#6-4- 间接访问操作符\" class=\"headerlink\" title=\"6.4 间接访问操作符\"></a>6.4 间接访问操作符 </h2><p> 间接访问：通过一个指针访问它所指向的地址的过程。又称引用指针。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p=a;</span><br><span class=\"line\"><span class=\"comment\">//p 本身存储的是 a 的地址。通过 *p 可以访问到 a 的地址获取值 100.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-5- 未初始化和非法指针\"><a href=\"#6-5- 未初始化和非法指针\" class=\"headerlink\" title=\"6.5 未初始化和非法指针\"></a>6.5 未初始化和非法指针</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *a;</span><br><span class=\"line\">*a=<span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"comment\">//a 指针未初始化，我们不知道 a 所存储的地址到底是何处。</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，每次构建指针的时候一定要初始化指针所存储的地址。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比如</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> p=<span class=\"number\">12</span>;</span><br><span class=\"line\">a=p;    <span class=\"comment\">// 这一步给了 a 一个地址</span></span><br><span class=\"line\">*a=<span class=\"number\">1</span>；</span><br><span class=\"line\"><span class=\"comment\">// 同样的还可以  int *a=p;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-6NULL 指针\"><a href=\"#6-6NULL 指针\" class=\"headerlink\" title=\"6.6NULL 指针\"></a>6.6NULL 指针</h2><p>NULL 指针表示不指向任何东西。要使一个指针变量未 NULL，你可以给它赋一个零值。   它可以用来判断某个特定指针目前是否有指向什么东西。</p>\n<p>在使用一个指针前，可以优先判断它是不是 NULL 指针。</p>\n<h2 id=\"6-7 指针、间接访问和左值\"><a href=\"#6-7 指针、间接访问和左值\" class=\"headerlink\" title=\"6.7 指针、间接访问和左值\"></a>6.7 指针、间接访问和左值 </h2><p> 指针变量可以作为左值，是因为它们是变量，而不是因为它们是指针。</p>\n<h2 id=\"6-8 指针、间接访问和变量\"><a href=\"#6-8 指针、间接访问和变量\" class=\"headerlink\" title=\"6.8 指针、间接访问和变量\"></a>6.8 指针、间接访问和变量</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&amp;a=<span class=\"number\">25</span>；</span><br><span class=\"line\"><span class=\"comment\">//&amp; 操作符产生 a 的地址，* 操作访问这个地址，最后将 25 存入该地址。</span></span><br></pre></td></tr></table></figure>\n\n<p>上句结果和 a=25 相同。但是上句设计更多的操作，容易降低代码的可读性。</p>\n<h2 id=\"6-9 指针常量\"><a href=\"#6-9 指针常量\" class=\"headerlink\" title=\"6.9 指针常量\"></a>6.9 指针常量</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">100</span>;</span><br><span class=\"line\">*(<span class=\"keyword\">int</span> *)<span class=\"number\">100</span>=<span class=\"number\">25</span>;  </span><br><span class=\"line\"><span class=\"comment\">// 强制类型转换把 100 从“整型”变为“指向整型的指针”</span></span><br></pre></td></tr></table></figure>\n\n<p>这个技巧的主要用途是访问某个具体的地址。例如，操作系统需要与输入输出设备控制器通信，启动 I/O 操作并从前面的操作中获得结果。</p>\n<h2 id=\"6-10 指针表达式\"><a href=\"#6-10 指针表达式\" class=\"headerlink\" title=\"6.10 指针表达式\"></a>6.10 指针表达式</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> ch=<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *cp=ch;</span><br><span class=\"line\">*cp+<span class=\"number\">1</span>  <span class=\"comment\">// 取出 cp 指向地址的内容 &#x27;a&#x27; 并 +1</span></span><br><span class=\"line\">*(cp+<span class=\"number\">1</span>) <span class=\"comment\">// 获取 cp 所指向地址的后一个地址。数组的下标操作基于此式</span></span><br><span class=\"line\">cp++  <span class=\"comment\">// 将 cp 所指向的地址移向下一块地址</span></span><br><span class=\"line\">    </span><br><span class=\"line\">*cp++  <span class=\"comment\">//1.++ 操作符产生 cp 的一份拷贝。2.++ 操作符增加 cp 的值。</span></span><br><span class=\"line\">       <span class=\"comment\">//3. 在 cp 的拷贝上执行间接访问操作</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strlen</span>(<span class=\"keyword\">char</span> *<span class=\"built_in\">string</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> length=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 依次访问字符串的内容，计算字符数，直到遇见 NULL 终止符</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*<span class=\"built_in\">string</span>++ != <span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">        length+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这个函数统计的确实是字符串的长度，但是没有统计首个字符，</span></span><br><span class=\"line\"><span class=\"comment\">// 而是用 &#x27;\\0&#x27; 代替首字符进行统计</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-13 指针运算\"><a href=\"#6-13 指针运算\" class=\"headerlink\" title=\"6.13 指针运算\"></a>6.13 指针运算 </h2><p> 如果 p 是指向 x 类型的指针，那么 p+1 就是指向下一个 x 类型的指针。</p>\n<p>1.p+i 得到 p 之后第 i 个 x 类型的指针。</p>\n<p>2. 指针 - 指针，结果是两个指针在内存中的距离</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(vp=&amp;values[N_VALUES];vp&gt;&amp;values[<span class=\"number\">0</span>]; )</span><br><span class=\"line\">\t*--vp=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(vp=&amp;values[N_VALUES<span class=\"number\">-1</span>];vp&gt;=&amp;values[<span class=\"number\">0</span>];vp--)</span><br><span class=\"line\">    *vp=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二个循环结束之后 vp 会发生越界</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"警告的总结 -3\"><a href=\"# 警告的总结 -3\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 错误地对一个未初始化的指针变量进行解引用。</p>\n<p>2. 错误地对一个 NULL 指针进行解引用。</p>\n<p>3. 像函数错误地传递 NULL 指针。</p>\n<p>4. 未检测到指针表达式的错误，从而导致不可预测的结果。</p>\n<p>5。对一个指针进行减法运算，是它非法地指向了数组第 1 个元素的前面的内存位置。</p>\n<h2 id=\"编程提示的总结 -1\"><a href=\"# 编程提示的总结 -1\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 一个值应该只具有一种意思。</p>\n<p>2. 如果指针并不只想任何有意义的东西，就把它设置为 NULL。</p>\n<h1 id=\"7、函数\"><a href=\"#7、函数\" class=\"headerlink\" title=\"7、函数\"></a>7、函数 </h1><h2 id=\"7-5 递归和迭代\"><a href=\"#7-5 递归和迭代\" class=\"headerlink\" title=\"7.5 递归和迭代\"></a>7.5 递归和迭代</h2><p> 对于计算阶乘和斐波那契数列来说，递归并没有提供任何优越之处，而且效率非常低。</p>\n<p>递归通过栈实现。</p>\n<p>迭代即递推。计算阶乘和斐波那契数列用迭代效率会高非常多。</p>\n<h2 id=\"7-6 可变参数列表\"><a href=\"#7-6 可变参数列表\" class=\"headerlink\" title=\"7.6 可变参数列表\"></a>7.6 可变参数列表 </h2><p> 目的：让一个函数在不同时候接受不同数目的参数。</p>\n<h3 id=\"7-6-1-stdarg 宏\"><a href=\"#7-6-1-stdarg 宏\" class=\"headerlink\" title=\"7.6.1 stdarg 宏\"></a>7.6.1 stdarg 宏 </h3><p> 头文件:stdarg.h</p>\n<p>这个头文件声明了 一个类型 va_list 和三个宏——va_start、va_arg、va_end。</p>\n<p>函数声明一个名叫 var_arg 的变量，用于访问参数列表的未确定部分。该变量通过 va_start 初始化。它的第 1 个参数是 va_list 变量的名字，第 2 个参数是省略号前最后一个有名字的参数。初始化过程把 var_arg 变量设置为指向可变参数部分的第 1 个参数。</p>\n<p>为了访问参数，需要使用 va_arg，这个宏接受两个参数：va_list 变量和参数列表中下一个参数的类型。    在有些函数中，你可能要通过前面获得的数据来判断下一个参数的类型。va_arg 返回这个参数的值，并使 var_arg 指向下一个可变参数。</p>\n<p>最后，当访问完毕最后一个可变参数之后，我们需要调用 va_end。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算指定数量的值的平均值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdarg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">average</span><span class=\"params\">(<span class=\"keyword\">int</span> n_values,...)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    va_list var_arg;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 准备访问可变参数</span></span><br><span class=\"line\">    va_start(var_arg,n_values);</span><br><span class=\"line\">    <span class=\"comment\">// 添加取自可变参数列表的值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(count=<span class=\"number\">0</span>;count&lt;n_values;count++)&#123;</span><br><span class=\"line\">        sum+=va_arg(var_arg,<span class=\"keyword\">int</span> );<span class=\"comment\">// 第二个参数表示下一个参\t\t\t\t\t\t\t\t\t// 数的类型</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 完成处理可变参数</span></span><br><span class=\"line\">    va_end(var_arg);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum/n_values;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不过，va_arg 无法正确识别作用于可变参数之上的缺省参数类型提升。char、short、float 类型的值实际上将作为 int 或 double 类型的值传递给函数。</p>\n<h2 id=\"警告的总结 -4\"><a href=\"# 警告的总结 -4\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 错误地在其他函数的作用域内编写函数原型。</p>\n<p>2. 没有为那些返回值不是整型的函数编写原型。</p>\n<p>3. 把函数原型和旧式风格的函数定义混合使用。</p>\n<p>4. 在 va_arg 中使用错误的参数类型，导致未定义的结果。</p>\n<h2 id=\"编程提示的总结 -2\"><a href=\"# 编程提示的总结 -2\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 在函数原型中使用参数名，可以给使用该函数的用户提供更多的信息。</p>\n<p>2. 抽象数据类型可以减少程序对模块实现细节的依赖，从而提高程序的可靠性。</p>\n<p>3. 当递归定义清晰的有点可以补偿它的效率开销时，就可以使用这个工具。</p>\n<h1 id=\"8、数组\"><a href=\"#8、数组\" class=\"headerlink\" title=\"8、数组\"></a>8、数组 </h1><p> 数组本质是指针。</p>\n<h2 id=\"8-1 一维数组\"><a href=\"#8-1 一维数组\" class=\"headerlink\" title=\"8.1 一维数组\"></a>8.1 一维数组</h2><h3 id=\"8-1-2- 下标引用\"><a href=\"#8-1-2- 下标引用\" class=\"headerlink\" title=\"8.1.2 下标引用\"></a>8.1.2 下标引用</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两句话等价</span></span><br><span class=\"line\"><span class=\"built_in\">array</span>[subscript];</span><br><span class=\"line\">*(<span class=\"built_in\">array</span>+(subscript));</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *ap=<span class=\"built_in\">array</span>+<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">*ap+<span class=\"number\">6</span>   <span class=\"comment\">// 相当于 array[2]+6</span></span><br><span class=\"line\">*(ap+<span class=\"number\">6</span>) <span class=\"comment\">// 相当于 array[2+6]</span></span><br><span class=\"line\">ap[<span class=\"number\">-1</span>]  <span class=\"comment\">//array[1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>[<span class=\"built_in\">array</span>] <span class=\"comment\">// 等价于 array[2], 不过不推荐写</span></span><br></pre></td></tr></table></figure>\n\n<p>指针有时比下标更有效率。</p>\n<h3 id=\"8-1-5- 数组和指针\"><a href=\"#8-1-5- 数组和指针\" class=\"headerlink\" title=\"8.1.5 数组和指针\"></a>8.1.5 数组和指针</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> *b;</span><br><span class=\"line\"><span class=\"comment\">//*a 合法，*b 不合法。因为 *b 会访问内存中的未知位置</span></span><br><span class=\"line\"><span class=\"comment\">//b++ 合法，a++ 非法。因为 a 的值是个常量</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/f046617758484a1c82c01cddb19053fe.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"8-1-8 初始化\"><a href=\"#8-1-8 初始化\" class=\"headerlink\" title=\"8.1.8 初始化\"></a>8.1.8 初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 完整初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">vector</span>[<span class=\"number\">5</span>]=&#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>,<span class=\"number\">50</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 不完整初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">vector</span>[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;; <span class=\"comment\">// 未初始化的部分默认为 0。不能出现超出数\t\t\t\t\t// 组范围的初始化</span></span><br><span class=\"line\"><span class=\"comment\">// 自动计算长度</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">vector</span>[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符数组初始化</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> message[]=&#123;<span class=\"string\">&#x27;H&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;l&#x27;</span>,<span class=\"string\">&#x27;l&#x27;</span>,<span class=\"string\">&#x27;o&#x27;</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">char</span> message[]=<span class=\"string\">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> message1[]=<span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *message2=<span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这两种声明方式的结果有区别，见下图</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/d2d87e0a8cb04607a8d21cfffa3ebc9f.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"8-2 多维数组\"><a href=\"#8-2 多维数组\" class=\"headerlink\" title=\"8.2 多维数组\"></a>8.2 多维数组</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[<span class=\"number\">3</span>][<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/4997fed084a44f968a91a7b7ce3a6603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"8-2-3- 下标\"><a href=\"#8-2-3- 下标\" class=\"headerlink\" title=\"8.2.3 下标\"></a>8.2.3 下标</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> matrix[<span class=\"number\">3</span>][<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/902d4976d75043479557dc15bcb0d04f.png#pic_center\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/9e36d195a27b405882161ac1868c841e.png#pic_center\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/301a2eb948cc4186a1c3306115b04d9c.png#pic_center\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/754c2e734dfd478fbb5393393c8c63ef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/18027cd177c34864ab75d92b7c9c755e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"8-2-4 指向数组的指针\"><a href=\"#8-2-4 指向数组的指针\" class=\"headerlink\" title=\"8.2.4 指向数组的指针\"></a>8.2.4 指向数组的指针</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"built_in\">vector</span>[<span class=\"number\">10</span>], *vp=<span class=\"built_in\">vector</span>;  <span class=\"comment\">// 合法</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> matrix[<span class=\"number\">3</span>][<span class=\"number\">10</span>], *mp=matrix;  <span class=\"comment\">// 非法</span></span><br><span class=\"line\"><span class=\"comment\">//matrix 是一个指向整型数组的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明一个指向整型数组的指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*p)[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*p)[<span class=\"number\">10</span>]=matrix;  <span class=\"comment\">//p 指向 matrix 的第一行</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两种方式创建一个简单的整型指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *pi=&amp;matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> *pi=matrix[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"8-2-5 作为函数参数的多维数组\"><a href=\"#8-2-5 作为函数参数的多维数组\" class=\"headerlink\" title=\"8.2.5 作为函数参数的多维数组\"></a>8.2.5 作为函数参数的多维数组</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> matrix[<span class=\"number\">3</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">// 两种等价引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> (*matrix)[<span class=\"number\">10</span>])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> mat[][<span class=\"number\">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"8-2-6 初始化\"><a href=\"#8-2-6 初始化\" class=\"headerlink\" title=\"8.2.6 初始化\"></a>8.2.6 初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> matrix[<span class=\"number\">2</span>][<span class=\"number\">3</span>]=&#123;<span class=\"number\">100</span>,<span class=\"number\">101</span>,<span class=\"number\">102</span>,<span class=\"number\">110</span>,<span class=\"number\">111</span>,<span class=\"number\">112</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> matrix[<span class=\"number\">3</span>][<span class=\"number\">5</span>]=&#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">00</span>,<span class=\"number\">01</span>,<span class=\"number\">02</span>,<span class=\"number\">03</span>,<span class=\"number\">04</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>,<span class=\"number\">13</span>,<span class=\"number\">14</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">20</span>,<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>,<span class=\"number\">24</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个三维数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> three_dim[<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">5</span>]=&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">000</span>,<span class=\"number\">001</span>,<span class=\"number\">002</span>,<span class=\"number\">003</span>,<span class=\"number\">004</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">010</span>,<span class=\"number\">011</span>,<span class=\"number\">012</span>,<span class=\"number\">013</span>,<span class=\"number\">014</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">020</span>,<span class=\"number\">021</span>,<span class=\"number\">022</span>,<span class=\"number\">023</span>,<span class=\"number\">024</span>&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">100</span>,<span class=\"number\">101</span>,<span class=\"number\">102</span>,<span class=\"number\">103</span>,<span class=\"number\">104</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">110</span>,<span class=\"number\">111</span>,<span class=\"number\">112</span>,<span class=\"number\">113</span>,<span class=\"number\">114</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">120</span>,<span class=\"number\">121</span>,<span class=\"number\">122</span>,<span class=\"number\">123</span>,<span class=\"number\">124</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个四维数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> four_dim[<span class=\"number\">2</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">5</span>]=&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;<span class=\"number\">0000</span>,<span class=\"number\">0001</span>,<span class=\"number\">0002</span>,<span class=\"number\">0003</span>,<span class=\"number\">0004</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">0010</span>,<span class=\"number\">0011</span>,<span class=\"number\">0012</span>,<span class=\"number\">0013</span>,<span class=\"number\">0014</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">0020</span>,<span class=\"number\">0021</span>,<span class=\"number\">0022</span>,<span class=\"number\">0023</span>,<span class=\"number\">0024</span>&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;<span class=\"number\">0100</span>,<span class=\"number\">0101</span>,<span class=\"number\">0102</span>,<span class=\"number\">0103</span>,<span class=\"number\">0104</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">0110</span>,<span class=\"number\">0111</span>,<span class=\"number\">0112</span>,<span class=\"number\">0113</span>,<span class=\"number\">0114</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">0120</span>,<span class=\"number\">0121</span>,<span class=\"number\">0122</span>,<span class=\"number\">0123</span>,<span class=\"number\">0124</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;<span class=\"number\">1000</span>,<span class=\"number\">1001</span>,<span class=\"number\">1002</span>,<span class=\"number\">1003</span>,<span class=\"number\">1004</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">1010</span>,<span class=\"number\">1011</span>,<span class=\"number\">1012</span>,<span class=\"number\">1013</span>,<span class=\"number\">1014</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">1020</span>,<span class=\"number\">1021</span>,<span class=\"number\">1022</span>,<span class=\"number\">1023</span>,<span class=\"number\">1024</span>&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;<span class=\"number\">1100</span>,<span class=\"number\">1101</span>,<span class=\"number\">1102</span>,<span class=\"number\">1103</span>,<span class=\"number\">1104</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">1110</span>,<span class=\"number\">1111</span>,<span class=\"number\">1112</span>,<span class=\"number\">1113</span>,<span class=\"number\">1114</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">1120</span>,<span class=\"number\">1121</span>,<span class=\"number\">1122</span>,<span class=\"number\">1123</span>,<span class=\"number\">1124</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 长度自动计算</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> matrix[][<span class=\"number\">5</span>]=&#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">00</span>,<span class=\"number\">01</span>,<span class=\"number\">02</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">10</span>,<span class=\"number\">11</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">20</span>,<span class=\"number\">21</span>,<span class=\"number\">22</span>,<span class=\"number\">23</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-3 指针数组\"><a href=\"#8-3 指针数组\" class=\"headerlink\" title=\"8.3 指针数组\"></a>8.3 指针数组</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *api[<span class=\"number\">10</span>];  <span class=\"comment\">//api 数组存的是整数型指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> <span class=\"keyword\">const</span> keyword[]=&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;do&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;for&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;if&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;register&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;return&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;switch&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;while&quot;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"警告的总结 -5\"><a href=\"# 警告的总结 -5\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 当访问多维数组的元素时，误用逗号分隔下标。</p>\n<p>2. 在一个指向未指定长度的数组的指针上执行指针运算。</p>\n<h2 id=\"编程提示的总结 -3\"><a href=\"# 编程提示的总结 -3\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 一开始就编写良好的代码显然比依赖编译器来修正劣质代码更好。</p>\n<p>2. 源代码的可读性几乎总是比程序的运行时效率更为重要。</p>\n<p>3. 只要有可能，函数的指针形参都应该声明为 const。</p>\n<p>4. 在有些环境中，使用 register 关键字提高程序的运行时效率。</p>\n<p>5. 在多维数组的初始值列表中使用完整的多层花括号能提高可读性。</p>\n<h1 id=\"9、字符串、字符和字节\"><a href=\"#9、字符串、字符和字节\" class=\"headerlink\" title=\"9、字符串、字符和字节\"></a>9、字符串、字符和字节</h1><h2 id=\"9-2 字符串长度\"><a href=\"#9-2 字符串长度\" class=\"headerlink\" title=\"9.2 字符串长度\"></a>9.2 字符串长度</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">strlen</span>(x)&gt;=<span class=\"built_in\">strlen</span>(y)) ...</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">strlen</span>(x)-<span class=\"built_in\">strlen</span>(y)&gt;=<span class=\"number\">0</span>)...</span><br><span class=\"line\"><span class=\"comment\">// 第二个判断将永远为真，因为 strlen 返回一个无符号数，无符号数</span></span><br><span class=\"line\"><span class=\"comment\">// 不可能减出一个负值</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-5 字符串查找基础\"><a href=\"#9-5 字符串查找基础\" class=\"headerlink\" title=\"9.5 字符串查找基础\"></a>9.5 字符串查找基础</h2><h3 id=\"9-5-1 查找一个字符\"><a href=\"#9-5-1 查找一个字符\" class=\"headerlink\" title=\"9.5.1 查找一个字符\"></a>9.5.1 查找一个字符</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strchr</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *str, <span class=\"keyword\">int</span> ch)</span></span>;<span class=\"comment\">// 查找 ch 第一次出现的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strrchr</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *str, <span class=\"keyword\">int</span> ch)</span></span>;<span class=\"comment\">// 查找 ch 最后出现的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> <span class=\"built_in\">string</span>[<span class=\"number\">20</span>]=<span class=\"string\">&quot;Hello there, honey.&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *ans;</span><br><span class=\"line\">ans=<span class=\"built_in\">strchr</span>(<span class=\"built_in\">string</span>,<span class=\"string\">&#x27;h&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//ans 所致的位置将是 string+7</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"9-5-2 查找任何几个字符\"><a href=\"#9-5-2 查找任何几个字符\" class=\"headerlink\" title=\"9.5.2 查找任何几个字符\"></a>9.5.2 查找任何几个字符</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strpbrk</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *str, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *group)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 该函数返回一个指向 str 中第 1 个匹配 group 中任何一个字符的字符位置，未找到则返回 NULL 指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> <span class=\"built_in\">string</span>[<span class=\"number\">20</span>]=<span class=\"string\">&quot;Hello there, honey.&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *ans;</span><br><span class=\"line\">ans=<span class=\"built_in\">strchr</span>(<span class=\"built_in\">string</span>,<span class=\"string\">&#x27;aeiou&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">//ans 将指向 string+1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"9-5-3 查找一个字串\"><a href=\"#9-5-3 查找一个字串\" class=\"headerlink\" title=\"9.5.3 查找一个字串\"></a>9.5.3 查找一个字串</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strstr</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *s1, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *s2)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 该函数在 s1 中查找整个 s2 第一次出现的 起始位置</span></span><br><span class=\"line\"><span class=\"comment\">// 不过标准库中没有 strrstr 函数，需要自己实现。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">my_strrstr</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *s1, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *s2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在 s1 中查找字符串 s2 最右出现的位置，并返回一个该位置的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"keyword\">char</span> *last;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"keyword\">char</span> *current;</span><br><span class=\"line\">    <span class=\"comment\">// 把指针初始化为我们已经找到的前一次匹配位置</span></span><br><span class=\"line\">    last=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 旨在第 2 个字符串不为空时才进行查找，若 s2 为空，返回 NULL。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*s2!=<span class=\"string\">&#x27;\\0&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 查找 s2 在 s1 中第 1 次出现的位置</span></span><br><span class=\"line\">        current=<span class=\"built_in\">strstr</span>(s1,s2);</span><br><span class=\"line\">        <span class=\"comment\">// 我们每次找到字符串时，让指针指向它的起始位置，然后查找该字符串的下一个匹配位置</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(current!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            last=current;</span><br><span class=\"line\">            current=<span class=\"built_in\">strstr</span>(last+<span class=\"number\">1</span>,s2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回指向我们找到的最后一次匹配的起始位置的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"9-6 高级字符串查找\"><a href=\"#9-6 高级字符串查找\" class=\"headerlink\" title=\"9.6 高级字符串查找\"></a>9.6 高级字符串查找</h2><h3 id=\"9-6-1 查找一个字符串前缀\"><a href=\"#9-6-1 查找一个字符串前缀\" class=\"headerlink\" title=\"9.6.1 查找一个字符串前缀\"></a>9.6.1 查找一个字符串前缀</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">strspn</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *str, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *group)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回 str 起始部分匹配 group 中仍以字符的字符数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> len1,len2;</span><br><span class=\"line\"><span class=\"keyword\">char</span> buffer[]=<span class=\"string\">&quot;25,142,330,Smith,J,239-4123&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">len1=<span class=\"built_in\">strspn</span>(buffer,<span class=\"string\">&quot;0123456789&quot;</span>);  <span class=\"comment\">//len1=2</span></span><br><span class=\"line\">len2-<span class=\"built_in\">strspn</span>(buffer,<span class=\"string\">&quot;,0123456789&quot;</span>);  <span class=\"comment\">//len2=11</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">strcspn</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *str, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *group)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回 str 字符串起始部分中不与 group 中任何字符匹配的字符数。</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"9-6-2 查找标记\"><a href=\"#9-6-2 查找标记\" class=\"headerlink\" title=\"9.6.2 查找标记\"></a>9.6.2 查找标记</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strtok</span><span class=\"params\">(<span class=\"keyword\">char</span> *str, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *sep)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//sep 定义了用作分隔符的 字符集合 。strtok 找到 str 的下一个标记，并将其用 NULL 结尾，然后返回一个指向这个标记的指针。</span></span><br><span class=\"line\"><span class=\"comment\">//str 会被修改</span></span><br><span class=\"line\"><span class=\"comment\">// 如果第 1 个参数是 NULL，函数就在同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_tolens</span><span class=\"params\">(<span class=\"keyword\">char</span> *line)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 从一个字符数组中提取空白字符分割的标记并把它们打印出来(每行一个)。</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> whitespace[]=<span class=\"string\">&quot; \\t\\f\\r\\v\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *token;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(token=strtok(line,whitespace);</span><br><span class=\"line\">       token!=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">       token=strtok(<span class=\"literal\">NULL</span>,whitespace)) <span class=\"comment\">// 第一个参数为 NULL，因此直接从 token 的位置开始寻找下一处分隔标记</span></span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Next token is %s\\n&quot;</span>,token);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-7 错误信息\"><a href=\"#9-7 错误信息\" class=\"headerlink\" title=\"9.7 错误信息\"></a>9.7 错误信息</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strerror</span><span class=\"params\">(<span class=\"keyword\">int</span> error_number)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 该函数把其中一个错误代码作为参数并返回一个指向用于描述错误的字符串指针</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"9-8 字符操作\"><a href=\"#9-8 字符操作\" class=\"headerlink\" title=\"9.8 字符操作\"></a>9.8 字符操作 </h2><p> 头文件：ctype.h</p>\n<h3 id=\"9-8-1 字符分类\"><a href=\"#9-8-1 字符分类\" class=\"headerlink\" title=\"9.8.1 字符分类\"></a>9.8.1 字符分类</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>如果它的参数复合下列条件就返回真</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>iscntrl</td>\n<td>任何控制字符</td>\n</tr>\n<tr>\n<td>isspace</td>\n<td>空白字符：空格’ ‘、换页’\\f’、换行’\\n’、回车’\\r’、制表符’\\t \\v’</td>\n</tr>\n<tr>\n<td>isdigit</td>\n<td>十进制数字 0~9</td>\n</tr>\n<tr>\n<td>isxdigit</td>\n<td>十六进制数字，包括所有十进制数字。a(A)~f(F)</td>\n</tr>\n<tr>\n<td>islower</td>\n<td>小写字母 a~z</td>\n</tr>\n<tr>\n<td>isupper</td>\n<td>大写字母 A~Z</td>\n</tr>\n<tr>\n<td>isalpha</td>\n<td>大小写字母</td>\n</tr>\n<tr>\n<td>isalnum</td>\n<td>字母或数字</td>\n</tr>\n<tr>\n<td>ispunct</td>\n<td>标点符号，任何不属于数字或字母的图形字符</td>\n</tr>\n<tr>\n<td>isgraph</td>\n<td>任何图形字符</td>\n</tr>\n<tr>\n<td>isprint</td>\n<td>任何可打印字符，包括图形字符和空白字符</td>\n</tr>\n</tbody></table>\n<h3 id=\"9-8-2 字符转换\"><a href=\"#9-8-2 字符转换\" class=\"headerlink\" title=\"9.8.2 字符转换\"></a>9.8.2 字符转换</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tolower</span><span class=\"params\">(<span class=\"keyword\">int</span> ch)</span></span>; <span class=\"comment\">// 字母转小写</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">toupper</span><span class=\"params\">(<span class=\"keyword\">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"9-9 内存操作\"><a href=\"#9-9 内存操作\" class=\"headerlink\" title=\"9.9 内存操作\"></a>9.9 内存操作 </h2><p> 目的：避免非字符串数据内部包含零值的情况，这类情况无法使用字符串函数来处理，因为当它们遇到第一个 NULL 字节时将停止工作。</p>\n<p>注：任何类型的指针都可以转换为 void* 指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *src, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 从 src 的起始位置赋值 length 个字节到 dst 的内存起始位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memmove</span><span class=\"params\">(<span class=\"keyword\">void</span> *dst, <span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *src, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcmp</span><span class=\"params\">(<span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *a, <span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *b, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memchr</span><span class=\"params\">(<span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *a, <span class=\"keyword\">int</span> ch, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memset</span><span class=\"params\">(<span class=\"keyword\">void</span> *a, <span class=\"keyword\">int</span> ch, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这些函数整体功能和 str 系列函数差不多，但它们可以处理包括 NULL 字节在内的任意字节</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"警告的总结 -6\"><a href=\"# 警告的总结 -6\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 应该使用有符号数的表达式中使用 strlen 函数。</p>\n<p>2. 在表达式中混用有符号数和无符号数。</p>\n<p>3. 使用 strcpy 函数把一个长字符串复制到一个较短的数组中，导致溢出。</p>\n<p>4. 使用 strcat 函数把一个字符串添加到一个数组中，导致数组溢出。</p>\n<p>5. 使用 strcmp 函数返回值当作布尔值进行测试。</p>\n<p>6. 把 strcmp 函数的返回值与 1 和 -1 比较。</p>\n<p>7. 使用并非以 NULL 字节结尾的字符序列。</p>\n<p>8. 使用 strncpy 函数产生不以 NULL 字节结尾的字符串。</p>\n<p>9. 把 strncpy 函数和 strxxx 族函数混用。</p>\n<p>10. 忘了 strtok 函数将会修改它所处理的字符串。</p>\n<p>11.strtok 函数是不可再入的。</p>\n<h2 id=\"编程提示总结 -3\"><a href=\"# 编程提示总结 -3\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 不要试图自己编写技能相同的函数来取代库函数。</p>\n<p>2. 使用字符分类和转换函数可以提高函数的移植性。</p>\n<h1 id=\"10、结构体和联合\"><a href=\"#10、结构体和联合\" class=\"headerlink\" title=\"10、结构体和联合\"></a>10、结构体和联合 </h1><p> 与数组不同，每个结构体成员都有自己的名字，它们都是通过名字访问的。</p>\n<h2 id=\"10-1 结构体基础\"><a href=\"#10-1 结构体基础\" class=\"headerlink\" title=\"10.1 结构体基础\"></a>10.1 结构体基础</h2><h3 id=\"10-1-1 结构体声明\"><a href=\"#10-1-1 结构体声明\" class=\"headerlink\" title=\"10.1.1 结构体声明\"></a>10.1.1 结构体声明</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> c;</span><br><span class=\"line\">&#125;x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> c;</span><br><span class=\"line\">&#125;y[<span class=\"number\">20</span>],*z;   <span class=\"comment\">// 这种声明和上一个声明再编译器中是两种不同的类型，即\t\t\t使它们的成员列表完全相同。</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，z=&amp;x;  非法</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 利用标签创建变量</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SIMPLE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SIMPLE</span> <span class=\"title\">x</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SIMPLE</span> <span class=\"title\">y</span>[20],*<span class=\"title\">z</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用 typedef</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> c;</span><br><span class=\"line\">&#125;Simple;</span><br><span class=\"line\"></span><br><span class=\"line\">Simple x;</span><br><span class=\"line\">Simple y[<span class=\"number\">20</span>],*z;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-1-3 成员访问\"><a href=\"#10-1-3 成员访问\" class=\"headerlink\" title=\"10.1.3 成员访问\"></a>10.1.3 成员访问</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> c;</span><br><span class=\"line\">&#125;Simple;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一般访问</span></span><br><span class=\"line\">Simple x;</span><br><span class=\"line\">x.a;</span><br><span class=\"line\"><span class=\"comment\">// 指针访问</span></span><br><span class=\"line\">Simple *p=&amp;x;</span><br><span class=\"line\">(*p).a;     p-&gt;a;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"10-1-5 结构体自引用\"><a href=\"#10-1-5 结构体自引用\" class=\"headerlink\" title=\"10.1.5 结构体自引用\"></a>10.1.5 结构体自引用</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SELF_REF</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SELF_REF</span> *<span class=\"title\">b</span>;</span>   </span><br><span class=\"line\">&#125;;<span class=\"comment\">// 自引用必须是指针而不是一般结构体，因为编译器再结构体的长度确定之前就已经知道指针的长度。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-1-6 不完整声明\"><a href=\"#10-1-6 不完整声明\" class=\"headerlink\" title=\"10.1.6 不完整声明\"></a>10.1.6 不完整声明</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建两个互相引用的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span>;</span>  <span class=\"comment\">// 不完整声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span> *<span class=\"title\">partner</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> *<span class=\"title\">partner</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"10-1-7 结构体初始化\"><a href=\"#10-1-7 结构体初始化\" class=\"headerlink\" title=\"10.1.7 结构体初始化\"></a>10.1.7 结构体初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> c;</span><br><span class=\"line\">&#125;Simple;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">INIT_EX</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> b[<span class=\"number\">10</span>];</span><br><span class=\"line\">    Simple c;</span><br><span class=\"line\">&#125;x=&#123;</span><br><span class=\"line\">    <span class=\"number\">10</span>,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">25</span>,<span class=\"string\">&#x27;x&#x27;</span>,<span class=\"number\">1.9</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"10-3 结构的存储分配\"><a href=\"#10-3 结构的存储分配\" class=\"headerlink\" title=\"10.3 结构的存储分配\"></a>10.3 结构的存储分配</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ALIGN</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">&#125;;  <span class=\"comment\">// 成员在编译时会按声明顺序进行存储</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/141678bd480d48ccb3648f5b301e9291.png#pic_center\" alt=\"在这里插入图片描述\"><br>显然，a 后面会先浪费 3 个空间再存 b，为了节省空间，可以如下声明</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ALIGN</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> b</span><br><span class=\"line\">    <span class=\"keyword\">char</span> a；</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sizeof 操作可以得出一个结构体的整体长度，包括上述浪费的空间。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果必须确定结构某个成员的实际位置，可以使用 offsetof 宏(stddef.h)</span></span><br><span class=\"line\">offsetof(type , memeber);</span><br><span class=\"line\"><span class=\"comment\">// 如 offsetof(struct ALIGN, b); 会返回 b 的首地址</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-4 作为函数参数\"><a href=\"#10-4 作为函数参数\" class=\"headerlink\" title=\"10.4 作为函数参数\"></a>10.4 作为函数参数 </h2><p> 若不使用指针传递，一个大体量的结构体的值传递将会花费较大资源拷贝一个备份传入堆栈，函数调用完之后又要删除，这样效率很低。</p>\n<p>推荐使用指针传递，为了防止结构体被修改，可以将指针引用声明为 const。</p>\n<p>另外，还可以把参数声明为寄存器变量，从而进一步提高指针传递方案的效率。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">register</span> SIMPLE <span class=\"keyword\">const</span> *trans)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"10-5 位段\"><a href=\"#10-5 位段\" class=\"headerlink\" title=\"10.5 位段\"></a>10.5 位段 </h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CHAR</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> ch\t\t:<span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> font\t:<span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> size\t:<span class=\"number\">19</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CHAR</span> <span class=\"title\">ch1</span>;</span></span><br><span class=\"line\"><span class=\"comment\">// 该结构体可以处理 128(2^7) 个不同的字符值、64(2^6)种不同的字体、0~524287 个单位的长度。</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/dfc12bddf6db4a2e9a62a500cb192fd2.png#pic_center\" alt=\"在这里插入图片描述\"><br>另一个使用位段的理由就是它们可以很方便地访问一个整型值得部分内容。</p>\n<p>例：操作系统中，用于操作软盘的代码必须与磁盘控制器通信。这些设备控制器常常包含了几个寄存器，每个寄存器又包含了许多包装在一个整型值内的不同的值。位段就是一种方便访问这些单一值得方法。假定磁盘控制器其中一个寄存器是如下定义的：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/05a40d45b9504366845c805038ae5167.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>前 5 个位段每个都占 1 位，其余几个位段更长一些。在一个从右向左分配位段的机器上，下面这个声明允许程序方便对这个寄存器的不同位段进行访问。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">DISK_REGISTER_FORMAT</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> command\t\t:<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> sector\t\t\t:<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> track\t\t\t:<span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> error_code\t\t:<span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> head_loaded\t:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> write_protect\t:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> disk_spinning\t:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> error_occurred\t:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> ready\t\t\t:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假如磁盘寄存器是在内存地址 0xc0200142 进行访问的，我们可以声明下面的指针常量</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DISK_REGISTER \\</span></span><br><span class=\"line\"><span class=\"meta\">\t((struct DISK_REGISTER_FORMAT *)0xc0200142)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 告诉控制器从哪个扇区哪个磁道开始读取</span></span><br><span class=\"line\">DISK_REGISTER-&gt;sector=new_sector;</span><br><span class=\"line\">DISK_REGISTER-&gt;track=new_track;</span><br><span class=\"line\">DISK_REGISTER-&gt;command=new_READ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待，知道操作完成(ready 变量变成真)</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(!DISK_REGISTER-&gt;ready)  ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检查错误</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(DISK_REGISTER-&gt;error_occurred)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(DISK_REGISTER-&gt;error_code)&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 赋值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DISK_REGISTER (unsigned int*)0xc0200142  <span class=\"comment\">// 与前一个 define 作用相同</span></span></span><br><span class=\"line\">*DICK_REGISTER &amp;=<span class=\"number\">0XFFFFFC1F</span>; <span class=\"comment\">// 使用与操作把 sector 字段清零，但不影响其他字段</span></span><br><span class=\"line\">*DISK_REGISTER |= (new_sector &amp; <span class=\"number\">0x1f</span>) &lt;&lt;<span class=\"number\">5</span>; <span class=\"comment\">// 接受 new_sector 的值，&amp; 确保这个值不会超过这个位段的宽度。接着，把它左移到合适的位置，然后再用 | 把这个字段设置为重要的值</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"10-6 联合\"><a href=\"#10-6 联合\" class=\"headerlink\" title=\"10.6 联合\"></a>10.6 联合 </h2><p> 目的：在 <u> 不同的时刻 </u> 把不同的东西存储在同一个位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">float</span> f;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;fi;</span><br><span class=\"line\"><span class=\"comment\">// 分配给联合的内存数量取决于它的最长成员的长度</span></span><br></pre></td></tr></table></figure>\n\n<p>事实上，假如 union 的存储长度很长，但是某一时刻它实际存入的内容很短，这就会造成资源浪费。为了节省空间，可以让 union 存储不同类型的指针，所有指针的存储长度是相同的。</p>\n<h3 id=\"10-6-2 初始化\"><a href=\"#10-6-2 初始化\" class=\"headerlink\" title=\"10.6.2 初始化\"></a>10.6.2 初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t<span class=\"keyword\">float</span> b;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> c[<span class=\"number\">4</span>];</span><br><span class=\"line\">&#125;x=&#123;<span class=\"number\">5</span>&#125;; <span class=\"comment\">// 初始值必须是联合第 1 个成员的类型</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"警告的总结 -7\"><a href=\"# 警告的总结 -7\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 具有相同成员列表的结构声明产生不同类型的变量。</p>\n<p>2. 使用 typedef 位一个自引用的结构体定义名字时应该小心。</p>\n<p>3. 向函数传递结构参数是低效的。</p>\n<h2 id=\"编程提示总结 -4\"><a href=\"# 编程提示总结 -4\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 把结构标签声明和结构的 typedef 声明放在头文件中，当源文件需要这些声明时可以通过 #include 进行引用。</p>\n<p>2. 结构成员的最佳排列方式并不一定就是考虑边界对齐而浪费内存空间最少的那种排列形式(要在可读性和省空间之间有所权衡)。</p>\n<p>3. 把位段成员显式地声明为 signed int 或 unsigned int 类型。</p>\n<p>4. 位段是不可移植的。</p>\n<p>5. 位段使源代码中位的操作表达得更为清楚。</p>\n<h1 id=\"11、动态内存分配\"><a href=\"#11、动态内存分配\" class=\"headerlink\" title=\"11、动态内存分配\"></a>11、动态内存分配 </h1><p> 基本函数：malloc(分配内存)、free(释放内存)</p>\n<p>头文件：stdlib.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">malloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>; <span class=\"comment\">// 分配一个指定大小的连续内存，若操作系统无法向 malloc 提供更多内存，malloc 会返回 NULL 指针</span></span><br><span class=\"line\"><span class=\"function\">coid <span class=\"title\">free</span><span class=\"params\">(<span class=\"keyword\">void</span> *pointer)</span></span>; <span class=\"comment\">// 参数要么是 NULL，要么是先前从 malloc、calloc、realloc 返回的值</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-3calloc 和 realloc\"><a href=\"#11-3calloc 和 realloc\" class=\"headerlink\" title=\"11.3calloc 和 realloc\"></a>11.3calloc 和 realloc</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">calloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> num_elements, <span class=\"keyword\">size_t</span> element_size)</span></span>;<span class=\"comment\">// 返回的指针会顺便初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">realloc</span><span class=\"params\">(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">size_t</span> new_size)</span></span>;<span class=\"comment\">// 修改一个原先已经分配的内存块的大小</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-4 使用例\"><a href=\"#11-4 使用例\" class=\"headerlink\" title=\"11.4 使用例\"></a>11.4 使用例 </h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pi;</span><br><span class=\"line\">pi=<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(pi==<span class=\"literal\">NULL</span>)&#123; <span class=\"comment\">// 错误检查</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Out of memory.\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分配一个足够存储 25 个整数的内存</span></span><br><span class=\"line\">pi=<span class=\"built_in\">malloc</span>(<span class=\"number\">25</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)); <span class=\"comment\">// 可移植</span></span><br><span class=\"line\"><span class=\"comment\">// 对 pi 既可以进行 *pi++ 操作，还可以进行 pi[i] 操作</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-5 常见的动态内存错误\"><a href=\"#11-5 常见的动态内存错误\" class=\"headerlink\" title=\"11.5 常见的动态内存错误\"></a>11.5 常见的动态内存错误 </h2><p> 错误分类：</p>\n<p>1. 对 NULL 指针进行解引用。</p>\n<p>2. 对分配的内存进行操作时越界。</p>\n<p>3. 释放并非动态分配的内存。</p>\n<p>4. 试图释放一块动态分配的内存的一部分。</p>\n<p>5. 一块动态内存被释放之后被继续使用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alloc.h</span><br><span class=\"line\"><span class=\"comment\">// 定义一个不易发生错误的内存分配器</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> malloc     <span class=\"comment\">// 不要直接调用 malloc</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MALLOC(num , type)  (type*)alloc((num)*sizeof(type))</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> *<span class=\"title\">alloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//alloc 可以调用 malloc 并进行检查，确保返回的指针不是 NULL</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;alloc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> malloc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">alloc</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *new_mem;</span><br><span class=\"line\">    <span class=\"comment\">// 请求所需的内存，并检查确实分配成功</span></span><br><span class=\"line\">    new_mem=<span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(new_mem==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Out of memory.\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> new_mem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;alloc.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *new_memory;</span><br><span class=\"line\">    <span class=\"comment\">// 获得一串整型数的空间</span></span><br><span class=\"line\">    new_memory=MALLOC(<span class=\"number\">25</span>,<span class=\"keyword\">int</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不要访问被 free 释放的内存\"><a href=\"# 不要访问被 free 释放的内存\" class=\"headerlink\" title=\"不要访问被 free 释放的内存\"></a>不要访问被 free 释放的内存</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p=<span class=\"built_in\">malloc</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> *q=p;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"><span class=\"comment\">//p 释放后，q 也不能再使用，除非改变了 q 的内容</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内存泄漏\"><a href=\"# 内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏 </h4><p> 分配内存但在使用完毕后不释放将引起内存泄露(memory leak)。这会一点点榨干可用内存，除非重启系统。</p>\n<h2 id=\"警告的总结 -8\"><a href=\"# 警告的总结 -8\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 不检查从 malloc 函数返回的指针是否为 NULL。</p>\n<p>2. 访问动态分配内存之外的区域。</p>\n<p>3. 向 free 函数传递一个并非由 malloc 番薯返回的指针。</p>\n<p>4. 在动态内存被释放之后再访问它。</p>\n<h2 id=\"编程提示总结 -5\"><a href=\"# 编程提示总结 -5\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 动态内存分配有助于消除程序内部存在的限制。</p>\n<p>2. 使用 sizeof 计算出具类型的长度，提高程序的可移植性。</p>\n<h1 id=\"12、使用结构和指针\"><a href=\"#12、使用结构和指针\" class=\"headerlink\" title=\"12、使用结构和指针\"></a>12、使用结构和指针 </h1><h2 id=\"12-3 双链表\"><a href=\"#12-3 双链表\" class=\"headerlink\" title=\"12.3 双链表\"></a>12.3 双链表</h2><p> 注：读代码时可以在草稿纸上模拟链表操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 双链表结点定义   doubly_linked_list_node.h</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span>&#123;</span> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span> *<span class=\"title\">fwd</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span> *<span class=\"title\">bwd</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">&#125;Node;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-3-1 双链表插入操作的优化\"><a href=\"#12-3-1 双链表插入操作的优化\" class=\"headerlink\" title=\"12.3.1 双链表插入操作的优化\"></a>12.3.1 双链表插入操作的优化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一般的双链表插入函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;doubly_linked_list_node.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dll_insert</span><span class=\"params\">(Node *rootp, <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Node *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    Node *next;</span><br><span class=\"line\">    Node *newnode;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    \t查看 value 是否已经存在于链表中，如果是就返回。</span></span><br><span class=\"line\"><span class=\"comment\">    \t否则，为心的值创建一个新节点(newnode 指向它)</span></span><br><span class=\"line\"><span class=\"comment\">    \t&quot;this&quot; 指向新节点之前的那个结点</span></span><br><span class=\"line\"><span class=\"comment\">    \t&quot;next&quot; 指向新节点之后的那个结点</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">this</span>=rootp ; (next=<span class=\"keyword\">this</span>-&gt;fwd)!=<span class=\"literal\">NULL</span>;<span class=\"keyword\">this</span>=next)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(next-&gt;value==value) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(next-&gt;value&gt;value) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    newnode=(Node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(newnode==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    newnode-&gt;value=value;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 把新值添加到链表中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情况 1、2：并非位于链表尾部</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>!=rootp)&#123;<span class=\"comment\">// 情况 1：并非位于链表起始位置</span></span><br><span class=\"line\">            newnode-&gt;fwd=next;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">            next-&gt;bwd=newnode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;\t\t\t<span class=\"comment\">// 情况 2：位于链表起始位置</span></span><br><span class=\"line\">            newnode-&gt;fwd=next;</span><br><span class=\"line\">            rootp-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            next-&gt;bwd=newnode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情况 3、4：位于链表尾部</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>!=rootp)&#123;<span class=\"comment\">// 情况 3：并非位于链表起始位置</span></span><br><span class=\"line\">            newnode-&gt;fwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">            rootp-&gt;bwd=newnode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;\t\t\t<span class=\"comment\">// 情况 4：位于链表起始位置</span></span><br><span class=\"line\">            newnode-&gt;fwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            rootp-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            rootp-&gt;bwd=newnode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细分析可以发现，不同情况中存在相同的操作，可以进行提炼化简代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一次逻辑提炼</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情况 1、2：并非位于链表尾部</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        newnode-&gt;fwd=next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>!=rootp)&#123;<span class=\"comment\">// 情况 1：并非位于链表起始位置</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;\t\t\t<span class=\"comment\">// 情况 2：位于链表起始位置</span></span><br><span class=\"line\">            rootp-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \tnext-&gt;bwd=newnode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 情况 3、4：位于链表尾部</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        newnode-&gt;fwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>!=rootp)&#123;<span class=\"comment\">// 情况 3：并非位于链表起始位置</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;\t\t\t<span class=\"comment\">// 情况 4：位于链表起始位置</span></span><br><span class=\"line\">            rootp-&gt;fwd=newnode;</span><br><span class=\"line\">            newnode-&gt;bwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rootp-&gt;bwd=newnode;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个过程其实还可以简化。先看一个例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(pointer !=<span class=\"literal\">NULL</span>) field=pointer;</span><br><span class=\"line\"><span class=\"keyword\">else</span> field=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面的判断本质上等价于下句 </span></span><br><span class=\"line\">field=pointer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因此，之前代码的 if(next != NULL) 判断可以用这种方法化简</span></span><br><span class=\"line\">newnode-&gt;fwd=next;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>!=rootp)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;fwd=newnode;</span><br><span class=\"line\">    newnode-&gt;bwd=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    rootp-&gt;fwd=newnode;</span><br><span class=\"line\">    newnode-&gt;bwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(next!=<span class=\"literal\">NULL</span>) next-&gt;bwd=newnode;</span><br><span class=\"line\"><span class=\"keyword\">else</span> rootp-&gt;bwd=newnode;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最终版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;doubly_linked_list_node.h&quot;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dll_insert</span><span class=\"params\">(Node *rootp, <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> Node *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> Node *next;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> Node *newnode;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    \t查看 value 是否已经存在于链表中，如果是就返回。</span></span><br><span class=\"line\"><span class=\"comment\">    \t否则，为心的值创建一个新节点(newnode 指向它)</span></span><br><span class=\"line\"><span class=\"comment\">    \t&quot;this&quot; 指向新节点之前的那个结点</span></span><br><span class=\"line\"><span class=\"comment\">    \t&quot;next&quot; 指向新节点之后的那个结点</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">this</span>=rootp ; (next=<span class=\"keyword\">this</span>-&gt;fwd)!=<span class=\"literal\">NULL</span>;<span class=\"keyword\">this</span>=next)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(next-&gt;value==value) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(next-&gt;value&gt;value) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    newnode=(Node *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(newnode==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    newnode-&gt;value=value;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 把新值添加到链表中</span></span><br><span class=\"line\">    newnode-&gt;fwd=next;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;fwd=newnode;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>!=rootp) newnode-&gt;bwd=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> newnode-&gt;bwd=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(next!=<span class=\"literal\">NULL</span>) next-&gt;bwd=newnode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> rootp-&gt;bwd=newnode;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"警告的总结 -9\"><a href=\"# 警告的总结 -9\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 落到链表尾部的后面。</p>\n<p>2. 使用指针时应格外小心，因为 C 并没有对它们的使用提供安全网。</p>\n<p>3. 从 if 语句中提炼语句可能会改变测试结果。</p>\n<h2 id=\"编程提示的总结 -4\"><a href=\"# 编程提示的总结 -4\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 消除特殊情况使代码更易于维护。</p>\n<p>2. 通过提炼语句消除 if 语句中的重复语句。</p>\n<p>3. 不要仅仅根据代码的大小评估它的质量。</p>\n<h1 id=\"13、高级指针话题\"><a href=\"#13、高级指针话题\" class=\"headerlink\" title=\"13、高级指针话题\"></a>13、高级指针话题 </h1><h2 id=\"13-2 高级声明\"><a href=\"#13-2 高级声明\" class=\"headerlink\" title=\"13.2 高级声明\"></a>13.2 高级声明</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">f</span><span class=\"params\">()</span></span>;   <span class=\"comment\">// 声明一个函数，它返回一个指向整型的指针</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*f)(); <span class=\"comment\">// 声明一个函数的指针，它指向的函数返回一个整型值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *(*f)(); <span class=\"comment\">// 和上一句相同，但必须对其进行间接访问操作才能得到整型值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *f[]; <span class=\"comment\">//f 是一个数组，它的元素类型是指向整型的指针。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">()</span>[]</span>;  <span class=\"comment\">//f 是一个函数，它的返回值是一个整型数组。不过这个声明是非法的，因为这里的函数只能返回标量值。</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> f[]();   <span class=\"comment\">//f 是个数组，它的元素类型是返回值为整型的函数。这个声明也是非法的，因为数组元素必须有相同的长度。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*f[])(); <span class=\"comment\">// 这个声明是合法的。先求 *f[]，f 是一个元素为某种类型的指针的数组。然后看() 号，说明 f 的数组元素是函数指针，这些指针所指向的函数的返回值是一个整型值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> *(*f[])(); <span class=\"comment\">// 与上一句同理，只是多了个间接访问符</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*==============================================================*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> (*f)(<span class=\"keyword\">int</span> ,<span class=\"keyword\">float</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> *(*g[])(<span class=\"keyword\">int</span> ,<span class=\"keyword\">float</span>);</span><br><span class=\"line\"><span class=\"comment\">// 前者把 f 声明为一个函数指针，这个函数接受 int 和 float 两个类型的参数。</span></span><br><span class=\"line\"><span class=\"comment\">// 后者则是一个存函数指针的数组</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"13-3 函数指针\"><a href=\"#13-3 函数指针\" class=\"headerlink\" title=\"13.3 函数指针\"></a>13.3 函数指针</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> (*pf)(<span class=\"keyword\">int</span>)=&amp;f;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">ans=f(<span class=\"number\">25</span>);</span><br><span class=\"line\">ans=(*pf)(<span class=\"number\">25</span>);</span><br><span class=\"line\">ans=pf(<span class=\"number\">25</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3-1 回调函数\"><a href=\"#13-3-1 回调函数\" class=\"headerlink\" title=\"13.3.1 回调函数\"></a>13.3.1 回调函数 </h3><p> 向函数传递一个指向值的指针而不是值本身。函数有一个 void* 形参，用于接收这个参数。  这样字符串和数组对象也可以被调用。字符串和数组无法作为参数传递给函数，但是指向它们的指针可以。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t在一个单链表中查找一个指定值的函数，它的参数是一个指向链表第 1 个结点的指针，一个指向我们需要查找的值的指针和一个函数指针，它所指向的函数用于比较存储与链表中的类型的值。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;node.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">search_list</span><span class=\"params\">(Node *node, <span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *value.</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">          <span class=\"keyword\">int</span>(*compare)(<span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *, <span class=\"keyword\">void</span> <span class=\"keyword\">const</span> *))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(node!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(compare(&amp;node-&gt;value,value)==<span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        node=node-&gt;link;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;<span class=\"comment\">// 类型无关的链表查找</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-1-2 转换表\"><a href=\"#13-1-2 转换表\" class=\"headerlink\" title=\"13.1.2 转换表\"></a>13.1.2 转换表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简易计算器</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span>(oper)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD:</span><br><span class=\"line\">        result=add(op1,op2);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SUB:</span><br><span class=\"line\">    \tresult=sub(op1,op2);</span><br><span class=\"line\">    \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> MUL:</span><br><span class=\"line\">        result=mul(op1,op2);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DIV:</span><br><span class=\"line\">        result=div(op1,op2);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">double</span>,<span class=\"keyword\">double</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">double</span>,<span class=\"keyword\">double</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">mul</span><span class=\"params\">(<span class=\"keyword\">double</span>,<span class=\"keyword\">double</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">div</span><span class=\"params\">(<span class=\"keyword\">double</span>,<span class=\"keyword\">double</span>)</span></span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">double</span> (*oper_func[])(<span class=\"keyword\">double</span>,<span class=\"keyword\">double</span>)=&#123;</span><br><span class=\"line\">    add,sub,mul,div...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这一句可以取代一开始的 switch 语句</span></span><br><span class=\"line\">result=oper_func[oper](op1,op2);</span><br><span class=\"line\"><span class=\"comment\">//oper 从数组中选择正确的函数指针，而函数调用操作符将执行这个函数</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"13-4 命令行参数\"><a href=\"#13-4 命令行参数\" class=\"headerlink\" title=\"13.4 命令行参数\"></a>13.4 命令行参数</h2><p>C 的 main 函数有两个形参。第 1 个通常称为 argc，它表示命令行参数的数目。第 2 个通常称为 argv，它指向一组参数值的首元素。这些元素的每个都是指向一个参数文本的指针。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/88e9265027894b09b20bbc12a94ff49a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 处理命令行参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRUE 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行实际任务的函数的原型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process_standard_input</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process_file</span><span class=\"params\">(<span class=\"keyword\">char</span> *file_name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项标志，缺省初始化为 FALSE</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> option_a, option_b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理选项参数: 跳到下一个参数，并检查它是否以一个横杠开头</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*++argv!=<span class=\"literal\">NULL</span> &amp;&amp; **argv==<span class=\"string\">&#x27;-&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查横杠后面的字母</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(*++*argv)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>:</span><br><span class=\"line\">                option_a=TRUE;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">                option_b=TRUE;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 处理文件名参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*argv==<span class=\"literal\">NULL</span>) process_standard_input();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            process_file(*argv);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(*++argv!=<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/4834227285ee42b0be740071fbfaf504.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/e7184cea80084c7b836aa5ccec45e4be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"13-5 字符串常量\"><a href=\"#13-5 字符串常量\" class=\"headerlink\" title=\"13.5 字符串常量\"></a>13.5 字符串常量 </h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;xyz&quot;</span>     <span class=\"comment\">// 这就是一个字符串常量，可以通过 &quot;xyz&quot;[2] 得到第 3 个字符</span></span><br><span class=\"line\"><span class=\"string\">&quot;xyz&quot;</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">*<span class=\"string\">&quot;xyz&quot;</span>;   <span class=\"comment\">// 返回 &#x27;y&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(<span class=\"string\">&quot;0123456789ABCDEF&quot;</span>[value%<span class=\"number\">16</span>]);</span><br><span class=\"line\"><span class=\"comment\">// 使用余数作为下标打印指定位置的字符串</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打印星号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    n+=<span class=\"number\">5</span>;</span><br><span class=\"line\">    n/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>,<span class=\"string\">&quot;**********&quot;</span>+<span class=\"number\">10</span>-n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"警告的总结 -10\"><a href=\"# 警告的总结 -10\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 对一个未初始化的指针执行间接访问操作。</p>\n<p>2. 在转移表中使用越界下标。</p>\n<h2 id=\"编程提示总结 -6\"><a href=\"# 编程提示总结 -6\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 如果并非必要，避免使用多层间接访问。</p>\n<p>2.cdecl 程序可以帮助你分析复杂的声明。</p>\n<p>3. 把 void* 强制转换为其他类型的指针式必须小心。</p>\n<p>4. 使用转移表时，应始终验证下标的有效性。</p>\n<p>5. 破坏性的命令行参数处理方式会使你以后无法再次进行处理。</p>\n<p>6. 不寻常的 diamagnetic 始终应该加上一条注释，描述它的目的和原理。</p>\n<h1 id=\"14、预处理器\"><a href=\"#14、预处理器\" class=\"headerlink\" title=\"14、预处理器\"></a>14、预处理器</h1><h2 id=\"14-1 预定义符号\"><a href=\"#14-1 预定义符号\" class=\"headerlink\" title=\"14.1 预定义符号\"></a>14.1 预定义符号</h2><p><img src=\"https://img-blog.csdnimg.cn/b4996750fa554fc3bb2cbdc3197506af.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"define\"><a href=\"#define\" class=\"headerlink\" title=\"#define\"></a>#define</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> name stuff</span></span><br><span class=\"line\"><span class=\"comment\">// 每当有符号 name 出现在这条指令后面使，预处理器就会把它替换成 stuff</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> reg register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> do_forever for(;;)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CASE break;case</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DEBUG_PRINT printf(<span class=\"meta-string\">&quot;File %s line %d:&quot;</span>\\</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t\t\t\t<span class=\"meta-string\">&quot;x=%d,y=%d,z=%d&quot;</span>,\\</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t\t\t\t__FILE__,__LINE__,\\</span></span><br><span class=\"line\"><span class=\"meta\">\t\t\t\t\t\tx,y,z)</span></span><br><span class=\"line\"><span class=\"comment\">// 内容过长可以用 \\ 代表分行</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PROCESS_LOOP  \\</span></span><br><span class=\"line\"><span class=\"meta\">\tfor(i=0;i&lt;10;i+=1)&#123;  \\</span></span><br><span class=\"line\"><span class=\"meta\">\t\tsum+=i;\t\t\t\\</span></span><br><span class=\"line\"><span class=\"meta\">\t\t<span class=\"meta-keyword\">if</span>(i&gt;0) prod*=i;  \\</span></span><br><span class=\"line\"><span class=\"meta\">\t&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-2-1 宏\"><a href=\"#14-2-1 宏\" class=\"headerlink\" title=\"14.2.1 宏\"></a>14.2.1 宏 </h3><p> 把参数替换到文本中，这种实现叫做宏（macro）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SQUARE(x) (x)*(x)    <span class=\"comment\">// 宏不用分号结尾</span></span></span><br><span class=\"line\">SQUARE(<span class=\"number\">5</span>)  <span class=\"comment\">// 会被替换成 5*5</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 第一句若不写为(x)*(x)，则会出现问题，见下例</span></span><br><span class=\"line\">SQUARE(a+<span class=\"number\">1</span>)   <span class=\"comment\">// 会替换成   a+1*a+1 而不是(a+1)*(a+1)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/cdefcd2dc8f047b49dbe42908a52bce3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"14-2-6-undef\"><a href=\"#14-2-6-undef\" class=\"headerlink\" title=\"14.2.6#undef\"></a>14.2.6#undef</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> name</span></span><br><span class=\"line\"><span class=\"comment\">// 如果一个现存的名字需要重新定义，那么它的旧定义首先必须用 #undef 移除</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"14-3 条件编译\"><a href=\"#14-3 条件编译\" class=\"headerlink\" title=\"14.3 条件编译\"></a>14.3 条件编译</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> constant-expression</span></span><br><span class=\"line\">\tstatements</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> constant-expression</span></span><br><span class=\"line\">        other statements</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        other statements</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">// 如果常量表达式的值非零，那么 statements 部分会被正常编译，否则预处理器会删除它们</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-3-1 是否被定义\"><a href=\"#14-3-1 是否被定义\" class=\"headerlink\" title=\"14.3.1 是否被定义\"></a>14.3.1 是否被定义</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(symbol)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> symbol</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(symbol)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> symbol</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> x&gt;0 || defined(A) &amp;&amp; defined(B)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-4 文件包含\"><a href=\"#14-4 文件包含\" class=\"headerlink\" title=\"14.4 文件包含\"></a>14.4 文件包含 </h2><p> 一个头文件如果被包含到 10 个源文件中，它实际上被编译了 10 次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;filename&gt;</span>   <span class=\"comment\">// 标准库文件</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;filename&quot;</span>   <span class=\"comment\">// 自定义头文件</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"避免多重包含\"><a href=\"# 避免多重包含\" class=\"headerlink\" title=\"避免多重包含\"></a>避免多重包含</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _HEADERNAME_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _HEADERNAME_H 1  <span class=\"comment\">// 如果头文件再次被包含，通过条件编译，它的所有内容被忽略</span></span></span><br><span class=\"line\">\t...<span class=\"comment\">//included filenames</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-5 其他指令\"><a href=\"#14-5 其他指令\" class=\"headerlink\" title=\"14.5 其他指令\"></a>14.5 其他指令</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#error</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">error</span> text of <span class=\"meta-keyword\">error</span> message    <span class=\"comment\">// 生成错误信息</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(OPTION_A)</span></span><br><span class=\"line\">\tstuff needed <span class=\"keyword\">for</span> option A</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined(OPTION_B)</span></span><br><span class=\"line\">\tstuff needed <span class=\"keyword\">for</span> option B</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> defined(OPTION_C)</span></span><br><span class=\"line\">\tstuff needed <span class=\"keyword\">for</span> option C</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">     <span class=\"meta\">#<span class=\"meta-keyword\">error</span> No option selected!</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">//#line</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">line</span> number <span class=\"meta-string\">&quot;string&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 通知预处理器 number 是下一行输入的行号。如果给出了可选部分 &quot;string&quot;，预处理器就把它作为当前文件的名字。</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">//#progma   语法因编译器而异</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"警告的总结 -11\"><a href=\"# 警告的总结 -11\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 不要在一个宏定义的末尾加上分号，使其称为一条完整的语句。</p>\n<p>2. 在宏定义中使用参数，但忘了在它们周围加上括号。</p>\n<p>3. 忘了在整个宏定义的两边加上括号。</p>\n<h2 id=\"编程提示的总结 -5\"><a href=\"# 编程提示的总结 -5\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 避免用 #define 指令定义可以用函数实现的很长序列的代码。</p>\n<p>2. 在那些对表达式求值的宏中，每个宏参数出现的地方都应该加上括号，并且在整个宏定义的两边也加上括号。</p>\n<p>3. 避免使用 #define 宏创建一种新语言。</p>\n<p>4. 采用命名约定，使程序员很容易看出某个标识符是否为 #define 宏。</p>\n<p>5. 只要合适就应该使用文件包含，不必担心它的额外开销。</p>\n<p>6. 头文件只应该包含一组函数和 (或) 数据的声明。</p>\n<p>7. 把不同集合的声明分离到不同的头文件中可以改善信息隐藏。</p>\n<p>8. 嵌套的 #include 文件使我们很难判断源文件之间的依赖关系。</p>\n<h1 id=\"15、输入 - 输出函数\"><a href=\"#15、输入 - 输出函数\" class=\"headerlink\" title=\"15、输入 / 输出函数\"></a>15、输入 / 输出函数</h1><h2 id=\"15-1 错误报告\"><a href=\"#15-1 错误报告\" class=\"headerlink\" title=\"15.1 错误报告\"></a>15.1 错误报告</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//stdio.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">perror</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *message)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果 message 不是 NULL 并且指向一个非空的字符串，perror 函数就打印出这个字符串，后面跟一个分号和一个空格，然后打印出一条用于解释 errno 当前错误代码的信息</span></span><br><span class=\"line\"><span class=\"comment\">// 只有当一个库函数失败时，errno 才会被设置。因此，只有当被调用的函数提示有错误发生时检查 errno 的值才有意义</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-2 终止执行\"><a href=\"#15-2 终止执行\" class=\"headerlink\" title=\"15.2 终止执行\"></a>15.2 终止执行</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//stdlib.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exit</span><span class=\"params\">(<span class=\"keyword\">int</span> status)</span></span>;   <span class=\"comment\">// 直接结束程序，status 参数返回给操作系统，用于提示程序是否正常完成</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-4-ANSI-I-O 概念\"><a href=\"#15-4-ANSI-I-O 概念\" class=\"headerlink\" title=\"15.4 ANSI I/O 概念\"></a>15.4 ANSI I/O 概念</h2><h3 id=\"15-4-1 流\"><a href=\"#15-4-1 流\" class=\"headerlink\" title=\"15.4.1 流\"></a>15.4.1 流</h3><p>ANSI C 中。所有的 I/O 操作只是简单地从程序移进或移出字节的事情。这种字节流被称为流。</p>\n<p>绝大多数流时完全缓冲的，这说明”读取”和”写入”实际上是从一块被称为缓冲区的内存区域来回复制数据。</p>\n<p>用于输出流的缓冲区只有当它写满是才会被刷新 (flush, 物理写入) 到设备或文件中。 一次性把写满的缓冲区写入和逐片把程序产生的输出分别写入相比效率更高。类似，输入缓冲区当它为空时通过从设备或文件读取下一块较大的输入，重新填充缓冲区。</p>\n<h3 id=\"15-4-2 文件\"><a href=\"#15-4-2 文件\" class=\"headerlink\" title=\"15.4.2 文件\"></a>15.4.2 文件</h3><p>stdio.h 中定义了 FILE 结构，用于访问一个流。</p>\n<p>对于每个 ANSI C 程序，运行时必须提供至少三个流：标准输入 (standard input)、标准输出(standard output) 和标准错误(standard error)。这些流的名字分别为 stdin、stdout、stderr，它们都是一个指向 FILE 结构的指针。</p>\n<h3 id=\"15-4-3 标准 I-O 常量\"><a href=\"#15-4-3 标准 I-O 常量\" class=\"headerlink\" title=\"15.4.3 标准 I/O 常量\"></a>15.4.3 标准 I/O 常量</h3><p>FOPRN_MAX 定义了至少能同时打开多少文件。</p>\n<p>FILENAME_MAX 用于提示一个字符数组应该多大以便容纳编译器所支持的最长合法文件名</p>\n<h2 id=\"15-5 流 I-O 总览\"><a href=\"#15-5 流 I-O 总览\" class=\"headerlink\" title=\"15.5 流 I/O 总览\"></a>15.5 流 I/O 总览</h2><p><img src=\"https://img-blog.csdnimg.cn/c2d2ae90eef6470295b8204d9d414ccc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/84428521ae904aadb5f267d295b0ef61.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"15-6 打开流\"><a href=\"#15-6 打开流\" class=\"headerlink\" title=\"15.6 打开流\"></a>15.6 打开流</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">FILE *<span class=\"title\">fopen</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *name, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *mode)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 第一个参数是相关的文件名，第二个参数是提示流是用于只读、只写还是读写</span></span><br><span class=\"line\"><span class=\"comment\">// 每次调用这个函数时最好都检查一下它的返回值</span></span><br><span class=\"line\">FILE *input;</span><br><span class=\"line\">input=fopen(<span class=\"string\">&quot;data3&quot;</span>,<span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(input==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">&quot;data3&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>读取</th>\n<th>写入</th>\n<th>添加</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>文本</td>\n<td>“r”</td>\n<td>“w”</td>\n<td>“a”</td>\n</tr>\n<tr>\n<td>二进制</td>\n<td>“rb”</td>\n<td>“wb”</td>\n<td>“ab”</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">FILE *<span class=\"title\">freopen</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *filename, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *mode, FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 这个函数首先试图关闭这个流，然后用指定的文件和模式重新打开这个流。如果打开失败，函数返回一个 NULL 值。反之，返回它的第 3 个参数值。</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"15-7 关闭流\"><a href=\"#15-7 关闭流\" class=\"headerlink\" title=\"15.7 关闭流\"></a>15.7 关闭流</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fclose</span><span class=\"params\">(FILE *f)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 对于输出流，该函数在文件关闭之前刷新缓冲区。成功则返回零值，反之返回 EOF</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-8 字符 I-O\"><a href=\"#15-8 字符 I-O\" class=\"headerlink\" title=\"15.8 字符 I/O\"></a>15.8 字符 I/O</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fgetc</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getc</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getchar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fputc</span><span class=\"params\">(<span class=\"keyword\">int</span> character, FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">putc</span><span class=\"params\">(<span class=\"keyword\">int</span> character, FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">putchar</span><span class=\"params\">(<span class=\"keyword\">int</span> cahracter)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 撤销字符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ungetc</span><span class=\"params\">(<span class=\"keyword\">int</span> character, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把一串从标准输入读取的数字转换为整数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;ctype.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">read_int</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ch;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 转换从标准输入读取的数字，当我们得到一个非数字字符时就停止</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((ch=getchar())!=EOF &amp;&amp; <span class=\"built_in\">isdigit</span>(ch))&#123;</span><br><span class=\"line\">        value*=<span class=\"number\">10</span>;</span><br><span class=\"line\">        value+=ch-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把非数字字符退回到流中，这样它就不会丢失</span></span><br><span class=\"line\">    ugetc(ch,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果用 fseek、fsetpos 或 rewind 函数改变了流的位置，所有退回的字符都将被丢弃</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-9 未格式化的行 I-O\"><a href=\"#15-9 未格式化的行 I-O\" class=\"headerlink\" title=\"15.9 未格式化的行 I/O\"></a>15.9 未格式化的行 I/O</h2><p>未格式化的 I/O 简单读取或写入字符。而格式化的 I/O 则执行数字和其他变量的内部和外部表示形式之间的转换。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把标准输入读取的文本行逐行复制到标准输出</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX_LINE_LENGTH 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copylines</span><span class=\"params\">(FILE *input. FILE *output)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[MAX_LINE_LENGTH];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fgets(buffer,MAX_LINE_LENGTH,input)!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"built_in\">fputs</span>(buffer,output);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"15-10 格式化的行 I-O\"><a href=\"#15-10 格式化的行 I-O\" class=\"headerlink\" title=\"15.10 格式化的行 I/O\"></a>15.10 格式化的行 I/O</h2><h2 id=\"15-10-1-scanf 族\"><a href=\"#15-10-1-scanf 族\" class=\"headerlink\" title=\"15.10.1 scanf 族\"></a>15.10.1 scanf 族</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fscanf</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *format,...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">scanf</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *format,...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sscanf</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *<span class=\"built_in\">string</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *format,...)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 这些函数都从输入源读取字符并根据 format 字符串给出的格式化代码对它们进行转换</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用例</span></span><br><span class=\"line\">nfields=<span class=\"built_in\">fscanf</span>(input,<span class=\"string\">&quot;%4d %4d %4d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\"><span class=\"comment\">// 这个宽度参数把整数值的宽度限制为 4 个数字或更少。</span></span><br><span class=\"line\"><span class=\"comment\">// 输入 1  2 。  此时 a=1,b=2,c 不变,nfields=2.</span></span><br><span class=\"line\"><span class=\"comment\">// 输入 12345 67890。 此时 a=1234,b=5,c=6789,nfields=3</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/a8611cd67cf44746a28ef2c17b832cb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用 sscanf 处理行定向 (line-oriented) 的输入</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_SIZE 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(FILE *input)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c,d,e;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[BUFFER_SIZE];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(fgets(buffer,BUFFER_SIZE,input)!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">sscanf</span>(buffer,<span class=\"string\">&quot;%d %d %d %d %d&quot;</span>,</span><br><span class=\"line\">                 &amp;a,&amp;b,&amp;c,&amp;d,&amp;e)!=<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">            \t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">&quot;Bad input skipped: %s&quot;</span>,</span><br><span class=\"line\">                            buffer);</span><br><span class=\"line\">            \t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 处理输入</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 sscanf 处理可变格式的输入</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DEFAULT_A 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DEFAULT_B 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">(<span class=\"keyword\">char</span> *buffer)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"comment\">// 查看 3 个值是否都已经给出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">sscanf</span>(buffer,<span class=\"string\">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c)!=<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否，对 a 使用缺省值，看看其他两个值是否已经给出</span></span><br><span class=\"line\">        a=DEFAULT_A;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">sscanf</span>(buffer,<span class=\"string\">&quot;%d %d&quot;</span>,&amp;b,&amp;c)!=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 为 b 使用缺省值，寻找剩余的值</span></span><br><span class=\"line\">            b=DEFAULT_B;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">sscanf</span>(buffer,<span class=\"string\">&quot;$d&quot;</span>,&amp;c)!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>,<span class=\"string\">&quot;Bad input: %s&quot;</span>,buffer);</span><br><span class=\"line\">                <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 处理 a,b,c</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"15-10-3-printf 族\"><a href=\"#15-10-3-printf 族\" class=\"headerlink\" title=\"15.10.3 printf 族\"></a>15.10.3 printf 族</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fprintf</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *format, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">printf</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *format,...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sprintf</span><span class=\"params\">(<span class=\"keyword\">char</span> *buffer, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *format,...)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/ce890255007c49239b452f6495e403ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/3970b1b5dd344867b55c9cafa3a215ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/3e100005d3dd47909168b415fc412e1f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"15-11 二进制 I-O\"><a href=\"#15-11 二进制 I-O\" class=\"headerlink\" title=\"15.11 二进制 I/O\"></a>15.11 二进制 I/O</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">fread</span><span class=\"params\">(<span class=\"keyword\">void</span> *buffer, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> count, FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">fwrite</span><span class=\"params\">(<span class=\"keyword\">void</span> *buffer, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">size_t</span> count, FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//buffer 时一个指向用于保存数据的内存位置的指针，size 时缓冲区中每个元素的字节数，count 时读取或写入的元素数</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-12 刷新和定位函数\"><a href=\"#15-12 刷新和定位函数\" class=\"headerlink\" title=\"15.12 刷新和定位函数\"></a>15.12 刷新和定位函数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fflush</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 该函数迫使输出流的缓冲区内的数据进行物理写入，不管它是否已满</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 随机访问 I/O</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">ftell</span><span class=\"params\">(FILE *stream)</span></span>;<span class=\"comment\">// 返回流当前的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fseek</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> from)</span></span>;<span class=\"comment\">// 改变读写位置</span></span><br></pre></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>如果 from 是…</th>\n<th>你将定位到</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SEEK_SET</td>\n<td>从流的起始位置起 offset 个字节，offset 必须是一个非负值。</td>\n</tr>\n<tr>\n<td>SEEK_CUR</td>\n<td>从流的当前位置起 offset 个字节，offset 可正可负。</td>\n</tr>\n<tr>\n<td>SEEK_END</td>\n<td>从流的尾部位置起 offset 个字节，offset 可正可负。如果为正，它将定位到文件尾的后面</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rewind</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//rewind 将读 / 写指针设置回指定流的起始位置。同时清除流的错误提示信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fgetpos</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">fpos_t</span> *position)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fsetpos</span><span class=\"params\">(FILE *stream, <span class=\"keyword\">fpos_t</span> <span class=\"keyword\">const</span> *position)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 后两个函数是 rewind 的替代方案</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-13 改变缓冲方式\"><a href=\"#15-13 改变缓冲方式\" class=\"headerlink\" title=\"15.13 改变缓冲方式\"></a>15.13 改变缓冲方式</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setbuf</span><span class=\"params\">(FILE* stream, <span class=\"keyword\">char</span> *buf)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//setbuf 设置了另一个数组，用于对流进行缓冲</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setvbuf</span><span class=\"params\">(FILE *stream,<span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> mode,<span class=\"keyword\">size_t</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//mode 参数用于指定缓冲的类型。_IOFBF 指定一个完全缓冲的流，_IONBF 指定一个不缓存的流，_IOLBF 指定一个行缓冲流。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-14 流错误函数\"><a href=\"#15-14 流错误函数\" class=\"headerlink\" title=\"15.14 流错误函数\"></a>15.14 流错误函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断流的状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">feof</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果流当前处于文件尾，feof 返回真。这个状态可以通过对流执行 feseek、rewind 或 fsetpos 函数来清除</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ferror</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//ferror 报告流的错误状态，如果出现任何读写错误就返回真</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clearerr</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//clearerr 对指定流的错误标志进行重置</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-15 临时文件\"><a href=\"#15-15 临时文件\" class=\"headerlink\" title=\"15.15 临时文件\"></a>15.15 临时文件</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">FILE *<span class=\"title\">tmpfile</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个文件，当文件被关闭或程序终止时这个文件会自动删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">tmpnam</span><span class=\"params\">(<span class=\"keyword\">char</span> *name)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 给临时文件起名</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-16- 文件操纵函数\"><a href=\"#15-16- 文件操纵函数\" class=\"headerlink\" title=\"15.16 文件操纵函数\"></a>15.16 文件操纵函数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *filename)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 删除一个指定文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rename</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *oldname, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *newname)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 重命名指定文件</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"警告的总结 -12\"><a href=\"# 警告的总结 -12\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 忘了在一条调试用的 printf 语句后跟一个 fflush 调用。</p>\n<p>2. 不检查 fopen 函数的返回值。</p>\n<p>3. 改变文件的位置将丢弃任何被退回到流的字符。</p>\n<p>4. 在使用 fgets 时指定太小的缓冲区。</p>\n<p>5. 使用 gets 的输入溢出缓冲区且违背检测到。</p>\n<p>6. 使用任何 scanf/printf 系列函数时，格式代码和参数指针类型不匹配。</p>\n<p>7. 在任何 scanf 系列函数的每个非数组、非指针参数前忘了加上 &amp; 符号。</p>\n<p>8. 注意在使用 scanf 系列函数转换 double、long double、short 和 long 整型时，在格式化代码中加上合适的限定符。</p>\n<p>9.sprintf 函数的输出溢出了，且缓冲区未检测到。</p>\n<p>10. 混淆 printf 和 scanf 格式代码。</p>\n<p>11. 在有些长整数长于普通整数的机器上打印长整数值时，忘了在格式代码中指定 l 修改符。</p>\n<p>12. 使用自动数组作为流的缓冲区时多加小心。</p>\n<h2 id=\"编程提示总结 -7\"><a href=\"# 编程提示总结 -7\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 在可能出现错误的场合，检查并报告错误。</p>\n<p>2. 操纵文本行而无需顾及它们的外部表示形式，这有助于提高程序的可移植性。</p>\n<p>3. 使用 scanf 限定符提高可移植性。</p>\n<p>4. 当你打印长整数时，即使你所使用的机器并不重要，坚实使用 l 修改符可以提高可移植性。</p>\n<h1 id=\"16、标准函数库\"><a href=\"#16、标准函数库\" class=\"headerlink\" title=\"16、标准函数库\"></a>16、标准函数库 </h1><p> 按需学习，可以直接参考官方文档</p>\n<h2 id=\"警告的总结 -13\"><a href=\"# 警告的总结 -13\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 忘了包含 math.h 头文件导致数学函数产生错误结果。</p>\n<p>2.clock 函数可能只产生处理器时间的近似值。</p>\n<p>3.time 函数的返回值并不一定是以秒为单位的。</p>\n<p>4.longjmp 不能返回到一个已经不在处于活动状态的函数。</p>\n<p>5. 避免 exit 函数的多重调用。</p>\n<h2 id=\"编程提示总结 -8\"><a href=\"# 编程提示总结 -8\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 滥用 setjmp 和 longjmp 可能导致晦涩难懂的代码。</p>\n<p>2. 对信号进行处理将导致程序的可移植性变差。</p>\n<p>3. 使用断言可以简化程序的调试。</p>\n<h1 id=\"17、经典抽象数据类型\"><a href=\"#17、经典抽象数据类型\" class=\"headerlink\" title=\"17、经典抽象数据类型\"></a>17、经典抽象数据类型 </h1><h2 id=\"17-1 堆栈\"><a href=\"#17-1 堆栈\" class=\"headerlink\" title=\"17.1 堆栈\"></a>17.1 堆栈</h2><h3 id=\"接口\"><a href=\"# 接口\" class=\"headerlink\" title=\"接口\"></a> 接口 </h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//stack.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_TYPE int  <span class=\"comment\">// 堆栈存储的值的类型</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">push</span></span><br><span class=\"line\"><span class=\"comment\"> 把一个新值压入栈中 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(STACK_TYPE value)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">pop</span></span><br><span class=\"line\"><span class=\"comment\"> 弹出栈顶的值 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">top</span></span><br><span class=\"line\"><span class=\"comment\"> 返回栈顶值 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">STACK_TYPE <span class=\"title\">top</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">is_empty</span></span><br><span class=\"line\"><span class=\"comment\"> 判断栈是否为空 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_empty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">is_full</span></span><br><span class=\"line\"><span class=\"comment\"> 判断栈是否已满</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_full</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"17-1-1 静态数组实现\"><a href=\"#17-1-1 静态数组实现\" class=\"headerlink\" title=\"17.1.1 静态数组实现\"></a>17.1.1 静态数组实现</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t用一个静态数组实现堆栈，数组的长度只能通过修改 #define 定义</span></span><br><span class=\"line\"><span class=\"comment\">\t并对模块重新进行编译实现</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;stack.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STACK_SIZE 100   <span class=\"comment\">// 栈的规模</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储栈中值得数组和一个指向栈顶元素得指针</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> STACK_TYPE <span class=\"built_in\">stack</span>[STACK_SIZE];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span>    top_element=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//push</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(STACK_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_full());</span><br><span class=\"line\">    top_element+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>[top_element]=value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//pop</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    top_element-=<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//top</span></span><br><span class=\"line\"><span class=\"function\">STACK_TYPE <span class=\"title\">top</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>[top_element];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_empty</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_empty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_element==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_full</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_full</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_element==STACK_SIZE<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"17-1-2 动态数组实现\"><a href=\"#17-1-2 动态数组实现\" class=\"headerlink\" title=\"17.1.2 动态数组实现\"></a>17.1.2 动态数组实现 </h3><p> 先在 stack.h 文件中加入以下接口</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">create_stack</span></span><br><span class=\"line\"><span class=\"comment\">创建堆栈，参数指定堆栈可以保存多少元素 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">create_stack</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">destory_stack</span></span><br><span class=\"line\"><span class=\"comment\"> 销毁堆栈，释放内存</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destory_stack</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">一个用动态分配数组实现得堆栈 </span></span><br><span class=\"line\"><span class=\"comment\"> 堆栈的长度在创建时给出</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;stack.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用于存储栈元素的数组和指向堆栈顶部元素的指针</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> STACK_TYPE *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> stack_size;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> top_element=<span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//create_stack</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">create_stack</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>&#123;</span><br><span class=\"line\">    assert(stack_size==<span class=\"number\">0</span>);</span><br><span class=\"line\">    stack_size=size;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>=<span class=\"built_in\">malloc</span>(stack_size*<span class=\"keyword\">sizeof</span>(STACK_TYPE));</span><br><span class=\"line\">    assert(<span class=\"built_in\">stack</span>!=<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//destory_stack</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destory_stack</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(stack_size&gt;<span class=\"number\">0</span>);</span><br><span class=\"line\">    stack_size=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">stack</span>);</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//push</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(STACK_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_full());</span><br><span class=\"line\">    top_element+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>[top_element]=value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//pop</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    top_element-=<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//top</span></span><br><span class=\"line\"><span class=\"function\">STACK_TYPE <span class=\"title\">top</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>[top_element];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_empty</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_empty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_element==<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_full</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_full</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> top_element==stack_size<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"17-1-3 链式堆栈\"><a href=\"#17-1-3 链式堆栈\" class=\"headerlink\" title=\"17.1.3 链式堆栈\"></a>17.1.3 链式堆栈</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链表实现栈，这个栈没有长度限制</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&quot;stack.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> FALSE 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个结构体来存储栈元素，next 字段指向下一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">STACK_NODE</span>&#123;</span></span><br><span class=\"line\">    STACK_TYPE value;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">STACK_NODE</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> StackNode *<span class=\"built_in\">stack</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//create_stack</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">create_stack</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//destory_stack</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destory_stack</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!is_empty()) pop();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//push</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(STACK_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    StackNode *new_node;</span><br><span class=\"line\">    </span><br><span class=\"line\">    new_node=<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(StackNode));</span><br><span class=\"line\">    assert(new_node!=<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    new_node-&gt;value=value;</span><br><span class=\"line\">    new_node-&gt;next=<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>=new_node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//pop</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    StackNode *first_node;</span><br><span class=\"line\">    </span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    first_node=<span class=\"built_in\">stack</span>;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>=first_node-&gt;next;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(first_node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//top</span></span><br><span class=\"line\"><span class=\"function\">STACK_TYPE <span class=\"title\">top</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>-&gt;value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_empty</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_empty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>==<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_full</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_full</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"17-2 队列\"><a href=\"#17-2 队列\" class=\"headerlink\" title=\"17.2 队列\"></a>17.2 队列 </h2><h3 id=\"接口 -1\"><a href=\"# 接口 -1\" class=\"headerlink\" title=\"接口\"></a> 接口 </h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//queue.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> QUEUE_TYPE int <span class=\"comment\">// 队列元素类型</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">create_queue</span></span><br><span class=\"line\"><span class=\"comment\"> 创建一个队列，参数指定队列最大容量 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">create_queue</span><span class=\"params\">(<span class=\"keyword\">size_t</span> size)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">destory_queue</span></span><br><span class=\"line\"><span class=\"comment\"> 销毁一个队列 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destory_queue</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">insert</span></span><br><span class=\"line\"><span class=\"comment\"> 向队列添加一个新元素 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(QUEUE_TYPE value)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">delete</span></span><br><span class=\"line\"><span class=\"comment\"> 从队列中删除一个元素 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">first</span></span><br><span class=\"line\"><span class=\"comment\"> 返回队头 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">QUEUE_TYPE <span class=\"title\">first</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">is_empty</span></span><br><span class=\"line\"><span class=\"comment\"> 判断队列是否为空 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_empty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">is_full</span></span><br><span class=\"line\"><span class=\"comment\"> 判断队列是否已满</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_full</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"17-2-1 静态数组实现\"><a href=\"#17-2-1 静态数组实现\" class=\"headerlink\" title=\"17.2.1 静态数组实现\"></a>17.2.1 静态数组实现</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用静态数组实现队列</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> QUEUE_SIZE 100 <span class=\"comment\">// 队列中元素的最大数量</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARRAY_SIZE (QUEUE_SIZE + 1) <span class=\"comment\">// 数组长度</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储队里了元素的数组和指向队列头和尾的指针</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> QUEUE_TYPE <span class=\"built_in\">queue</span>&#123;ARRAY_SIZE&#125;;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> front=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">size_t</span> rear=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//insert</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(QUEUE_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_full());</span><br><span class=\"line\">    rear=(rear+<span class=\"number\">1</span>)%ARRAY_SIZE;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>[rear]=value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//delete</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    front=(front+<span class=\"number\">1</span>)%ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//first</span></span><br><span class=\"line\"><span class=\"function\">QUEUE_TYPE <span class=\"title\">first</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    assert(!is_empty());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">queue</span>[front];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_empty</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_empty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rear+<span class=\"number\">1</span>)%ARRAY_SIZE==front;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//is_full</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_full</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (rear+<span class=\"number\">2</span>)%ARRAY_SIZE==front;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"17-3 树\"><a href=\"#17-3 树\" class=\"headerlink\" title=\"17.3 树\"></a>17.3 树 </h2><h3 id=\"接口 -2\"><a href=\"# 接口 -2\" class=\"headerlink\" title=\"接口\"></a> 接口 </h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//tree.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TREE_TYPE int  <span class=\"comment\">// 树的值类型</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">insert</span></span><br><span class=\"line\"><span class=\"comment\"> 向树添加一个值，这个值原先不存在树中 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(TREE_TYPE value)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">find</span></span><br><span class=\"line\"><span class=\"comment\"> 查找一个特定的值 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">TREE_TYPE *<span class=\"title\">find</span><span class=\"params\">(TREE_TYPE value)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">pre_order_traverse</span></span><br><span class=\"line\"><span class=\"comment\"> 先序遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre_order_traverse</span><span class=\"params\">(<span class=\"keyword\">void</span> (*callback)(TREE_TYPE value))</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"17-3-1 静态数组实现\"><a href=\"#17-3-1 静态数组实现\" class=\"headerlink\" title=\"17.3.1 静态数组实现\"></a>17.3.1 静态数组实现 </h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态数组实现二叉搜索树</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;tree.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TREE_SIZE 100  <span class=\"comment\">// 树的规模</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ARRAY_SIZE  (TREE_SIZE+1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用于存储树所有节点的数组</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> TREE_TYPE tree[ARRAY_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">left_child</span></span><br><span class=\"line\"><span class=\"comment\"> 计算一个节点左孩子的下标 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">left_child</span><span class=\"params\">(<span class=\"keyword\">int</span> current)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">right_child</span></span><br><span class=\"line\"><span class=\"comment\"> 计算一个节点右孩子的下标 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">right_child</span><span class=\"params\">(<span class=\"keyword\">int</span> current)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current*<span class=\"number\">2</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//insert</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(TREE_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> current;</span><br><span class=\"line\">    <span class=\"comment\">// 从根节点开始，直到找到那个值，进入合适的子树</span></span><br><span class=\"line\">    current=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(tree[current]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据情况，进入左子树或右子树(确信未出现重复的值)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value&lt;tree[current])</span><br><span class=\"line\">            current=left_child(current);</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            assert(value!=tree[current]);</span><br><span class=\"line\">            current=right_child(current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        assert(current&lt;ARRAY_SIZE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tree[current]=value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//find</span></span><br><span class=\"line\"><span class=\"function\">TREE_TYPE *<span class=\"title\">find</span><span class=\"params\">(TREE_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> current;</span><br><span class=\"line\">    <span class=\"comment\">// 确保值非零，因为零用于提示一个未使用的节点</span></span><br><span class=\"line\">    assert(value!=<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从根节点开始</span></span><br><span class=\"line\">    current=<span class=\"number\">1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从合适的子树开始，直到到达一个叶节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current&lt;ARRAY_SIZE &amp;&amp; tree[current]!=value)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据情况，进入左子树或右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value&lt;tree[current])</span><br><span class=\"line\">            current=left_child(current);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            current=right_child(current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(current&lt;ARRAY_SIZE) <span class=\"keyword\">return</span> tree+current;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">do_pre_order_traverse</span></span><br><span class=\"line\"><span class=\"comment\"> 执行一层先序遍历，这个辅助函数用于保存我们当前正在处理的节点信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">do_pre_order_traverse</span><span class=\"params\">(<span class=\"keyword\">int</span> current,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"keyword\">void</span> (*callback)(TREE_TYPE value))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(current&lt;ARRAY_SIZE &amp;&amp; tree[current]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        callback(tree[current]);</span><br><span class=\"line\">        do_pre_order_traverse(left_child(current),callback);</span><br><span class=\"line\">        do_pre_order_traverse(right_child(current),callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//pre_order_traverse</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre_order_traverse</span><span class=\"params\">(<span class=\"keyword\">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class=\"line\">     do_pre_order_traverse(<span class=\"number\">1</span>,callback);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"17-3-2 链表实现\"><a href=\"#17-3-2 链表实现\" class=\"headerlink\" title=\"17.3.2 链表实现\"></a>17.3.2 链表实现 </h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链表实现树</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;tree.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TreeNode 结构包含了值和两个指向某个树节点的指针</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TREE_NODE</span>&#123;</span></span><br><span class=\"line\">    TREE_TYPE value;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TREE_NODE</span> *<span class=\"title\">left</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TREE_NODE</span> *<span class=\"title\">right</span>;</span></span><br><span class=\"line\">&#125;TreeNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指向树根节点的指针</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> TreeNode *tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//insert</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(TREE_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    TreeNode *current;</span><br><span class=\"line\">    TreeNode **link;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从根节点开始</span></span><br><span class=\"line\">    link=&amp;tree;</span><br><span class=\"line\">    <span class=\"comment\">// 持续查找值，进入合适的子树</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>((current=*link)!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据情况，进入左子树或右子树(确认无重复值)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value&lt;current-&gt;value) link=&amp;current-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            assert(value!=current-&gt;value);</span><br><span class=\"line\">            link=&amp;current-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 分配一个新节点，使适当节点的 link 字段指向它</span></span><br><span class=\"line\">    current=<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(TreeNode));</span><br><span class=\"line\">    assert(current!=<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    current-&gt;value=value;</span><br><span class=\"line\">    current-&gt;left=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    current-&gt;right=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    *link=current;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//find</span></span><br><span class=\"line\"><span class=\"function\">TREE_TYPE *<span class=\"title\">find</span><span class=\"params\">(TREE_TYPE value)</span></span>&#123;</span><br><span class=\"line\">    TreeNode *current;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从根节点开始</span></span><br><span class=\"line\">    current=tree;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从合适的子树开始，直到到达一个叶节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current!=<span class=\"literal\">NULL</span> &amp;&amp; current-&gt;value!=value)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据情况，进入左子树或右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value&lt;current-&gt;value)</span><br><span class=\"line\">            current=current-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            current=current-&gt;right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(current!=<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> &amp;current-&gt;value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">do_pre_order_traverse</span></span><br><span class=\"line\"><span class=\"comment\"> 执行一层先序遍历，这个辅助函数用于保存我们当前正在处理的节点信息</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">do_pre_order_traverse</span><span class=\"params\">(TreeNode *current,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                   <span class=\"keyword\">void</span> (*callback)(TREE_TYPE value))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(current!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        callback(tree[current]);</span><br><span class=\"line\">        do_pre_order_traverse(current-&gt;left,callback);</span><br><span class=\"line\">        do_pre_order_traverse(current-&gt;right,callback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//pre_order_traverse</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre_order_traverse</span><span class=\"params\">(<span class=\"keyword\">void</span> (*callback)(TREE_TYPE value))</span></span>&#123;</span><br><span class=\"line\">     do_pre_order_traverse(tree,callback);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"17-4- 实现的改进\"><a href=\"#17-4- 实现的改进\" class=\"headerlink\" title=\"17.4 实现的改进\"></a>17.4 实现的改进</h2><p>1. 有时可能会拥有超过一个的堆栈。</p>\n<p>可以从堆栈的实现模块中取出数组和 top_element 的声明，并把它们放入用户代码。</p>\n<p>然后，它们通过参数被堆栈函数访问，这些函数便不再固定于某个数组。缺点是这样会丢失封装性，造成非法访问。</p>\n<p>2. 拥有超过一个类型</p>\n<p>有时可能同时需要一个整型栈和一个浮点型栈。</p>\n<p>可以把整个堆栈模块实现为一个 #define 宏，把目标类型作为参数。</p>\n<p>还可以让它存储 void* 类型的值，绕过类型检查。但是很容易出错。如：一个整数被压入一个元素类型为指针的栈中。</p>\n<p>可以设计一个泛型 ADT。</p>\n<p>3. 名字冲突</p>\n<h2 id=\"警告的总结 -14\"><a href=\"# 警告的总结 -14\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 不要使用断言检查内存是否分配成功。</p>\n<p>2. 数组形式的二叉树节点位置计算公式假定数组的下标从 1 开始。</p>\n<p>3. 把数据封装于对它进行操纵的模块可以防止用户不正确地访问数据。</p>\n<p>4. 与类型无关地函数没有类型检查，所以要确保传递正确类型地数据。</p>\n<h2 id=\"编程提示的总结 -6\"><a href=\"# 编程提示的总结 -6\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 避免使用具有副作用的函数。</p>\n<p>2. 一个模块的接口应该避免暴露它的实现细节。</p>\n<p>3. 将数据类型参数化，使它容易修改。</p>\n<p>4. 只有模块对外公布的接口才应该使公用的。</p>\n<p>5. 使用断言来防止非法操作。</p>\n<p>6. 几个不同的实现使用同一个接口使模块具有更强的可互换性。</p>\n<p>7. 服用现有的代码而不是对它进行改写。</p>\n<p>8. 迭代比尾部递归效率更高。</p>\n<h1 id=\"18、运行时环境\"><a href=\"#18、运行时环境\" class=\"headerlink\" title=\"18、运行时环境\"></a>18、运行时环境 </h1><p> 不同机器生成的汇编代码可能会有所不同</p>\n<h2 id=\"18-1- 判断运行时环境\"><a href=\"#18-1- 判断运行时环境\" class=\"headerlink\" title=\"18.1 判断运行时环境\"></a>18.1 判断运行时环境</h2><h3 id=\"18-1-2 静态变量和初始化\"><a href=\"#18-1-2 静态变量和初始化\" class=\"headerlink\" title=\"18.1.2 静态变量和初始化\"></a>18.1.2 静态变量和初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> static_variable=<span class=\"number\">5</span>;</span><br><span class=\"line\">.data</span><br><span class=\"line\">.enen</span><br><span class=\"line\">.global _static_variable</span><br><span class=\"line\">_static_variable:</span><br><span class=\"line\">.<span class=\"keyword\">long</span>   <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p>汇编代码的一开始是两个指令，分别表示进入程序的数据区以及确保变量开始于内存的偶数地址。变量被声明为全局类型，变量名以一个下划线开始。许多 C 编译器会在 C 代码所声明的外部名字前加一个下划线，以免与各个库函数所使用的名字冲突。</p>\n<p>最后，编译器为变量创建控件，并用适当的值对它进行初始化。</p>\n<h3 id=\"18-1-3 堆栈帧\"><a href=\"#18-1-3 堆栈帧\" class=\"headerlink\" title=\"18.1.3 堆栈帧\"></a>18.1.3 堆栈帧 </h3><p> 函数分为三部分：函数序(prologue)、函数体(body)、函数跋(epilogue)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/db2f96e630c148169779ddc511216786.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>第一条指令 (.text) 表示进入程序的代码段。为函数创建堆栈帧，堆栈帧是堆栈中的一个区域，里面存入函数的变量和其他值。</p>\n<p>.globl 是函数的全局声明</p>\n<p>0x3cfc 表示寄存器 d2 到 d7、a2 到 a5 中的值需要被存储。（存入堆栈帧）</p>\n<h3 id=\"18-1-4 寄存器变量\"><a href=\"#18-1-4 寄存器变量\" class=\"headerlink\" title=\"18.1.4 寄存器变量\"></a>18.1.4 寄存器变量</h3><p><img src=\"https://img-blog.csdnimg.cn/d2a82b2a7f504abc88437639c2cb81eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>1-6 存在了一个寄存器中，7-10 存到了其他地方。说明最多只能有 6 个整型值可以被存放在数据寄存器。</p>\n<p>机器使用的地址模型执行间接寻址和索引操作。这种组合工作颇似数组的下标引用。</p>\n<p>寄存器 a6 称为帧指针 (frame pointer)，它指向堆栈帧内部的一个”引用”位置。a6@(-28) 指定了一个偏移地址 -28。这个偏移位置从 -4 开始，每次增长 4。（整型值和指针都占 4 个字节）</p>\n<h3 id=\"18-1-5 外部标识符的长度\"><a href=\"#18-1-5 外部标识符的长度\" class=\"headerlink\" title=\"18.1.5 外部标识符的长度\"></a>18.1.5 外部标识符的长度</h3><p><img src=\"https://img-blog.csdnimg.cn/6ab22148f9ee4e28a7fa35b920343256.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>变量名的长度一般没有限制</p>\n<h3 id=\"18-1-6 判断堆栈帧布局\"><a href=\"#18-1-6 判断堆栈帧布局\" class=\"headerlink\" title=\"18.1.6 判断堆栈帧布局\"></a>18.1.6 判断堆栈帧布局</h3><p><img src=\"https://img-blog.csdnimg.cn/fb7d25fa4e5e4615862230aca047673e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>前三条指令把函数的参数压入堆栈。被压入的第 1 个参数存储于 a6@(-16)，包含变量 i10。然后被压入的是 d7，包含变量 i1。</p>\n<p>pea 指令简单地把它的操作数压入堆栈。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/730bfba5a8dc42a38bf815edab84884a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>jbsr 是跳转子程序(jump subroutine)。它把返回地址压入堆栈，并跳转到_func_ret_int 的起始位置。当被调用函数结束仍无后需要返回到它的调用位置，就要用到这个压入到堆栈中的返回地址。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/99b65c51a0ef4130a84448c6c75d781f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"函数序\"><a href=\"# 函数序\" class=\"headerlink\" title=\"函数序\"></a>函数序</h4><p><img src=\"https://img-blog.csdnimg.cn/5ac4b52f193c4188b3db5824c5353e2e.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>首先，a6 的内容被压入栈中。其次，堆栈指针的当前值被复制到 a6</p>\n<p><img src=\"https://img-blog.csdnimg.cn/043db02c1e054d2ea966ba6d159c7580.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>最后，link 指令从堆栈指针中 -8。这将会创建空间用于保存局部变量和被保存的寄存器值。</p>\n<p>下一条指令把一个单一的寄存器保存到堆栈帧。 0x80 指定寄存器 d7。寄存器存储在堆栈的顶部，它提示堆栈帧的顶部就是寄存器值保存的位置。堆栈帧剩余的部分必然是局部变量存储的地方。</p>\n<p>最后(mov 指令) 从堆栈复制一个值到 d7。</p>\n<h4 id=\"堆栈中的参数顺序\"><a href=\"# 堆栈中的参数顺序\" class=\"headerlink\" title=\"堆栈中的参数顺序\"></a>堆栈中的参数顺序 </h4><p> 被调用函数使用帧指针加一个偏移量来访问参数。当参数以反序压入到堆栈时，参数列表的第 1 个参数便位于堆栈中这些参数的顶部，它距离帧指针的偏移量是个常数。</p>\n<h4 id=\"最终的堆栈帧布局\"><a href=\"# 最终的堆栈帧布局\" class=\"headerlink\" title=\"最终的堆栈帧布局\"></a>最终的堆栈帧布局</h4><p><img src=\"https://img-blog.csdnimg.cn/52bb66a4548f40978f535a6a1317dae3.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>第 1 条 movl 指令是把第 2 个参数复制到 d0。下一条指令将这个值 -6，第 3 条指令把结果存入局部变量 d。d0 的作用是计算过程中的”中间结果暂存器”。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/12fec6e95363444a881c7027a10e6cb3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>接下来的 3 条指令对 return 语句进行求值。结果存入 d0。</p>\n<h4 id=\"函数跋\"><a href=\"# 函数跋\" class=\"headerlink\" title=\"函数跋\"></a>函数跋</h4><p><img src=\"https://img-blog.csdnimg.cn/919b5628fb194e1ba03ae5ff4b123b53.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>当返回到调用程序之后执行的第 1 条指令就是把 12 加到堆栈指针。这个假发能把参数值从堆栈中取出。</p>\n<h4 id=\"返回值\"><a href=\"# 返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><img src=\"https://img-blog.csdnimg.cn/9654fe42346a4a63acca44981026d35a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>这个函数没有参数，所以没有东西压入堆栈。这个函数返回后，d0 和 d1 的值都被保存。double 的长度为 8，返回需要同时用到 d0 和 d1。</p>\n<h2 id=\"18-2C 和汇编语言的接口\"><a href=\"#18-2C 和汇编语言的接口\" class=\"headerlink\" title=\"18.2C 和汇编语言的接口\"></a>18.2C 和汇编语言的接口 </h2><h4 id=\"汇编语言程序调用 C\"><a href=\"# 汇编语言程序调用 C\" class=\"headerlink\" title=\"汇编语言程序调用 C\"></a> 汇编语言程序调用 C</h4><p>1. 如果寄存器 d0、d1、a0、a1 保存了重要的值，它们必须在调用 C 之前进行保存，因为 C 不会保存它们的值。</p>\n<p>2. 任何函数的参数必须以参数列表相反的顺序压入到堆栈中。</p>\n<p>3. 函数必须由一条”跳转子程序”类型的指令调用，它会把返回地址压入堆栈。</p>\n<p>4. 当 C 函数返回时，汇编程序必须清楚堆栈中的任何参数。</p>\n<p>5. 如果汇编程序期望接受一个返回值，它将保存在 d0。</p>\n<p>6. 任何在调用之前进行过保存的寄存器此时可以恢复。</p>\n<h4 id=\"C 调用汇编程序\"><a href=\"#C 调用汇编程序\" class=\"headerlink\" title=\"C 调用汇编程序\"></a>C 调用汇编程序</h4><p>1. 保存任何你希望修改的寄存器(除了 d0、d1、a0、a1)。</p>\n<p>2. 参数值从堆栈中获得，因为调用它的 C 函数把参数压入堆栈。</p>\n<p>3. 如果函数应该返回一个值，它的值应保存在 d0 中。</p>\n<p>4. 返回之前，函数必须清楚任何它压入堆栈中的内容。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1ff9747cc8be4bbe8b8291962bce0a20.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"18-3 运行时效率\"><a href=\"#18-3 运行时效率\" class=\"headerlink\" title=\"18.3 运行时效率\"></a>18.3 运行时效率 </h2><p> 虚拟内存：由操作系统实现，它在需要时把程序的活动部分放入内存并把不活动的部分复制到磁盘中，这样就允许运行大型的程序。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e37be83bd52343fb98135df9cfd84cbe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>1. 在耗费时间最多的函数中，有些是库函数。</p>\n<p>2. 有些函数之所以耗费了大量的实践是因为它们被调用的次数多。</p>\n<p>3. 有些函数调用的次数并不多，但是每次调用所花费的时间很长。</p>\n<h2 id=\"警告的总结 -15\"><a href=\"# 警告的总结 -15\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 决定 外部标识符最大长度 的是链接器而不是编译器。</p>\n<p>2. 你无法链接由不同编译器产生的程序。</p>\n<h2 id=\"编程提示总结 -9\"><a href=\"# 编程提示总结 -9\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 使用 stdarg 实现可变参数列表。</p>\n<p>2. 改进算法比优化代码更有效率。</p>\n<p>3. 使用某种环境特有的技巧会导致程序不可移植。</p>\n<p>否分配成功。</p>\n<p>2. 数组形式的二叉树节点位置计算公式假定数组的下标从 1 开始。</p>\n<p>3. 把数据封装于对它进行操纵的模块可以防止用户不正确地访问数据。</p>\n<p>4. 与类型无关地函数没有类型检查，所以要确保传递正确类型地数据。</p>\n<h2 id=\"编程提示的总结 -7\"><a href=\"# 编程提示的总结 -7\" class=\"headerlink\" title=\"编程提示的总结\"></a>编程提示的总结</h2><p>1. 避免使用具有副作用的函数。</p>\n<p>2. 一个模块的接口应该避免暴露它的实现细节。</p>\n<p>3. 将数据类型参数化，使它容易修改。</p>\n<p>4. 只有模块对外公布的接口才应该使公用的。</p>\n<p>5. 使用断言来防止非法操作。</p>\n<p>6. 几个不同的实现使用同一个接口使模块具有更强的可互换性。</p>\n<p>7. 服用现有的代码而不是对它进行改写。</p>\n<p>8. 迭代比尾部递归效率更高。</p>\n<h1 id=\"18、运行时环境 -1\"><a href=\"#18、运行时环境 -1\" class=\"headerlink\" title=\"18、运行时环境\"></a>18、运行时环境 </h1><p> 不同机器生成的汇编代码可能会有所不同</p>\n<h2 id=\"18-1- 判断运行时环境 -1\"><a href=\"#18-1- 判断运行时环境 -1\" class=\"headerlink\" title=\"18.1 判断运行时环境\"></a>18.1 判断运行时环境</h2><h3 id=\"18-1-2 静态变量和初始化 -1\"><a href=\"#18-1-2 静态变量和初始化 -1\" class=\"headerlink\" title=\"18.1.2 静态变量和初始化\"></a>18.1.2 静态变量和初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态初始化</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> static_variable=<span class=\"number\">5</span>;</span><br><span class=\"line\">.data</span><br><span class=\"line\">.enen</span><br><span class=\"line\">.global _static_variable</span><br><span class=\"line\">_static_variable:</span><br><span class=\"line\">.<span class=\"keyword\">long</span>   <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p>汇编代码的一开始是两个指令，分别表示进入程序的数据区以及确保变量开始于内存的偶数地址。变量被声明为全局类型，变量名以一个下划线开始。许多 C 编译器会在 C 代码所声明的外部名字前加一个下划线，以免与各个库函数所使用的名字冲突。</p>\n<p>最后，编译器为变量创建控件，并用适当的值对它进行初始化。</p>\n<h3 id=\"18-1-3 堆栈帧 -1\"><a href=\"#18-1-3 堆栈帧 -1\" class=\"headerlink\" title=\"18.1.3 堆栈帧\"></a>18.1.3 堆栈帧 </h3><p> 函数分为三部分：函数序(prologue)、函数体(body)、函数跋(epilogue)</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2821c6aa3864495791b72057f087b08b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>第一条指令 (.text) 表示进入程序的代码段。为函数创建堆栈帧，堆栈帧是堆栈中的一个区域，里面存入函数的变量和其他值。</p>\n<p>.globl 是函数的全局声明</p>\n<p>0x3cfc 表示寄存器 d2 到 d7、a2 到 a5 中的值需要被存储。（存入堆栈帧）</p>\n<h3 id=\"18-1-4 寄存器变量 -1\"><a href=\"#18-1-4 寄存器变量 -1\" class=\"headerlink\" title=\"18.1.4 寄存器变量\"></a>18.1.4 寄存器变量</h3><p><img src=\"https://img-blog.csdnimg.cn/91d4c46bcdf04c4382c6cd44d28c9ead.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>1-6 存在了一个寄存器中，7-10 存到了其他地方。说明最多只能有 6 个整型值可以被存放在数据寄存器。</p>\n<p>机器使用的地址模型执行间接寻址和索引操作。这种组合工作颇似数组的下标引用。</p>\n<p>寄存器 a6 称为帧指针 (frame pointer)，它指向堆栈帧内部的一个”引用”位置。a6@(-28) 指定了一个偏移地址 -28。这个偏移位置从 -4 开始，每次增长 4。（整型值和指针都占 4 个字节）</p>\n<h3 id=\"18-1-5 外部标识符的长度 -1\"><a href=\"#18-1-5 外部标识符的长度 -1\" class=\"headerlink\" title=\"18.1.5 外部标识符的长度\"></a>18.1.5 外部标识符的长度</h3><p><img src=\"https://img-blog.csdnimg.cn/c093e565c3484953ad4965fdb9222588.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>变量名的长度一般没有限制</p>\n<h3 id=\"18-1-6 判断堆栈帧布局 -1\"><a href=\"#18-1-6 判断堆栈帧布局 -1\" class=\"headerlink\" title=\"18.1.6 判断堆栈帧布局\"></a>18.1.6 判断堆栈帧布局</h3><p><img src=\"https://img-blog.csdnimg.cn/1e80fada00484e358a581858795fb5a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>前三条指令把函数的参数压入堆栈。被压入的第 1 个参数存储于 a6@(-16)，包含变量 i10。然后被压入的是 d7，包含变量 i1。</p>\n<p>pea 指令简单地把它的操作数压入堆栈。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e00c8110b6694d6dba6cd16a19166a59.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>jbsr 是跳转子程序(jump subroutine)。它把返回地址压入堆栈，并跳转到_func_ret_int 的起始位置。当被调用函数结束仍无后需要返回到它的调用位置，就要用到这个压入到堆栈中的返回地址。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0693fbee23b54c8997d538cd88024f3d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"函数序 -1\"><a href=\"# 函数序 -1\" class=\"headerlink\" title=\"函数序\"></a>函数序</h4><p><img src=\"https://img-blog.csdnimg.cn/2e09d26d1a3a4db288e5003b709e2472.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>首先，a6 的内容被压入栈中。其次，堆栈指针的当前值被复制到 a6</p>\n<p><img src=\"https://img-blog.csdnimg.cn/94e767c9ad394c60bac01cd603ed4fef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>最后，link 指令从堆栈指针中 -8。这将会创建空间用于保存局部变量和被保存的寄存器值。</p>\n<p>下一条指令把一个单一的寄存器保存到堆栈帧。 0x80 指定寄存器 d7。寄存器存储在堆栈的顶部，它提示堆栈帧的顶部就是寄存器值保存的位置。堆栈帧剩余的部分必然是局部变量存储的地方。</p>\n<p>最后(mov 指令) 从堆栈复制一个值到 d7。</p>\n<h4 id=\"堆栈中的参数顺序 -1\"><a href=\"# 堆栈中的参数顺序 -1\" class=\"headerlink\" title=\"堆栈中的参数顺序\"></a>堆栈中的参数顺序 </h4><p> 被调用函数使用帧指针加一个偏移量来访问参数。当参数以反序压入到堆栈时，参数列表的第 1 个参数便位于堆栈中这些参数的顶部，它距离帧指针的偏移量是个常数。</p>\n<h4 id=\"最终的堆栈帧布局 -1\"><a href=\"# 最终的堆栈帧布局 -1\" class=\"headerlink\" title=\"最终的堆栈帧布局\"></a>最终的堆栈帧布局</h4><p><img src=\"https://img-blog.csdnimg.cn/6de3b4d9b2ab40f6a9421be75d865ecb.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>第 1 条 movl 指令是把第 2 个参数复制到 d0。下一条指令将这个值 -6，第 3 条指令把结果存入局部变量 d。d0 的作用是计算过程中的”中间结果暂存器”。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e3f218f778f544eca67a8bf5d75ab033.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>接下来的 3 条指令对 return 语句进行求值。结果存入 d0。</p>\n<h4 id=\"函数跋 -1\"><a href=\"# 函数跋 -1\" class=\"headerlink\" title=\"函数跋\"></a>函数跋</h4><p><img src=\"https://img-blog.csdnimg.cn/736bffced19a4aaa944fe163ed7dd513.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>当返回到调用程序之后执行的第 1 条指令就是把 12 加到堆栈指针。这个假发能把参数值从堆栈中取出。</p>\n<h4 id=\"返回值 -1\"><a href=\"# 返回值 -1\" class=\"headerlink\" title=\"返回值\"></a>返回值</h4><p><img src=\"https://img-blog.csdnimg.cn/cb1b6504bd204711aea8f2a7823ee5c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>这个函数没有参数，所以没有东西压入堆栈。这个函数返回后，d0 和 d1 的值都被保存。double 的长度为 8，返回需要同时用到 d0 和 d1。</p>\n<h2 id=\"18-2C 和汇编语言的接口 -1\"><a href=\"#18-2C 和汇编语言的接口 -1\" class=\"headerlink\" title=\"18.2C 和汇编语言的接口\"></a>18.2C 和汇编语言的接口 </h2><h4 id=\"汇编语言程序调用 C-1\"><a href=\"# 汇编语言程序调用 C-1\" class=\"headerlink\" title=\"汇编语言程序调用 C\"></a> 汇编语言程序调用 C</h4><p>1. 如果寄存器 d0、d1、a0、a1 保存了重要的值，它们必须在调用 C 之前进行保存，因为 C 不会保存它们的值。</p>\n<p>2. 任何函数的参数必须以参数列表相反的顺序压入到堆栈中。</p>\n<p>3. 函数必须由一条”跳转子程序”类型的指令调用，它会把返回地址压入堆栈。</p>\n<p>4. 当 C 函数返回时，汇编程序必须清楚堆栈中的任何参数。</p>\n<p>5. 如果汇编程序期望接受一个返回值，它将保存在 d0。</p>\n<p>6. 任何在调用之前进行过保存的寄存器此时可以恢复。</p>\n<h4 id=\"C 调用汇编程序 -1\"><a href=\"#C 调用汇编程序 -1\" class=\"headerlink\" title=\"C 调用汇编程序\"></a>C 调用汇编程序</h4><p>1. 保存任何你希望修改的寄存器(除了 d0、d1、a0、a1)。</p>\n<p>2. 参数值从堆栈中获得，因为调用它的 C 函数把参数压入堆栈。</p>\n<p>3. 如果函数应该返回一个值，它的值应保存在 d0 中。</p>\n<p>4. 返回之前，函数必须清楚任何它压入堆栈中的内容。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0358630ffc9b4ce391b0488aaecab8d0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"18-3 运行时效率 -1\"><a href=\"#18-3 运行时效率 -1\" class=\"headerlink\" title=\"18.3 运行时效率\"></a>18.3 运行时效率 </h2><p> 虚拟内存：由操作系统实现，它在需要时把程序的活动部分放入内存并把不活动的部分复制到磁盘中，这样就允许运行大型的程序。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8b46ef0f59044d3992c2410bb6ca2170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASU5GSU5JVEVfV0FS,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>1. 在耗费时间最多的函数中，有些是库函数。</p>\n<p>2. 有些函数之所以耗费了大量的实践是因为它们被调用的次数多。</p>\n<p>3. 有些函数调用的次数并不多，但是每次调用所花费的时间很长。</p>\n<h2 id=\"警告的总结 -16\"><a href=\"# 警告的总结 -16\" class=\"headerlink\" title=\"警告的总结\"></a>警告的总结</h2><p>1. 决定 外部标识符最大长度 的是链接器而不是编译器。</p>\n<p>2. 你无法链接由不同编译器产生的程序。</p>\n<h2 id=\"编程提示总结 -10\"><a href=\"# 编程提示总结 -10\" class=\"headerlink\" title=\"编程提示总结\"></a>编程提示总结</h2><p>1. 使用 stdarg 实现可变参数列表。</p>\n<p>2. 改进算法比优化代码更有效率。</p>\n<p>3. 使用某种环境特有的技巧会导致程序不可移植。</p>\n","url":"/posts/46293/","min2read":85,"word4post":"21.2k","prev_post":null,"next_post":{"title":"What's_米家？","url":"/posts/51802/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"1、快速上手\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">1、快速上手 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告与总结\" href = \"#\"><span class=\"toc-number\">1.1.</span> <span class=\"toc-text\">警告与总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结\" href = \"#\"><span class=\"toc-number\">1.2.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"2、基本概念\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">2、基本概念 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"2-1- 环境\" href = \"#\"><span class=\"toc-number\">2.1.</span> <span class=\"toc-text\">2.1 环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"2-1-1- 翻译环境\" href = \"#\"><span class=\"toc-number\">2.1.1.</span> <span class=\"toc-text\">2.1.1 翻译环境</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"2-1-2- 执行环境\" href = \"#\"><span class=\"toc-number\">2.1.2.</span> <span class=\"toc-text\">2.1.2 执行环境 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"2-2- 词法规则\" href = \"#\"><span class=\"toc-number\">2.2.</span> <span class=\"toc-text\">2.2 词法规则 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"三字母词\" href = \"#\"><span class=\"toc-number\">2.2.1.</span> <span class=\"toc-text\"> 三字母词 </span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"3、数据\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\">3、数据 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-1- 基本数据类型\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\">3.1 基本数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"3-1-1- 整型\" href = \"#\"><span class=\"toc-number\">3.1.1.</span> <span class=\"toc-text\">3.1.1 整型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"整型字面值\" href = \"#\"><span class=\"toc-number\">3.1.1.1.</span> <span class=\"toc-text\"> 整型字面值 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"枚举类型 -enumerated\" href = \"#\"><span class=\"toc-number\">3.1.1.2.</span> <span class=\"toc-text\"> 枚举类型(enumerated)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"3-1-2- 浮点类型\" href = \"#\"><span class=\"toc-number\">3.1.2.</span> <span class=\"toc-text\">3.1.2 浮点类型 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"3-1-3- 指针\" href = \"#\"><span class=\"toc-number\">3.1.3.</span> <span class=\"toc-text\">3.1.3 指针 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"指针常量\" href = \"#\"><span class=\"toc-number\">3.1.3.1.</span> <span class=\"toc-text\"> 指针常量 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"字符串常量\" href = \"#\"><span class=\"toc-number\">3.1.3.2.</span> <span class=\"toc-text\">字符串常量 </span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-2 声明\" href = \"#\"><span class=\"toc-number\">3.2.</span> <span class=\"toc-text\">3.2 声明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"3-2-2 数组声明\" href = \"#\"><span class=\"toc-number\">3.2.1.</span> <span class=\"toc-text\">3.2.2 数组声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"3-2-3- 指针声明\" href = \"#\"><span class=\"toc-number\">3.2.2.</span> <span class=\"toc-text\">3.2.3 指针声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"3-2-4 隐式声明\" href = \"#\"><span class=\"toc-number\">3.2.3.</span> <span class=\"toc-text\">3.2.4 隐式声明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-3-typedef\" href = \"#\"><span class=\"toc-number\">3.3.</span> <span class=\"toc-text\">3.3 typedef</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-4- 常量\" href = \"#\"><span class=\"toc-number\">3.4.</span> <span class=\"toc-text\">3.4 常量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-6- 链接属性\" href = \"#\"><span class=\"toc-number\">3.5.</span> <span class=\"toc-text\">3.6 链接属性 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-7- 存储类型\" href = \"#\"><span class=\"toc-number\">3.6.</span> <span class=\"toc-text\">3.7 存储类型 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"初始化\" href = \"#\"><span class=\"toc-number\">3.6.0.1.</span> <span class=\"toc-text\">初始化 </span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-8-static- 关键字\" href = \"#\"><span class=\"toc-number\">3.7.</span> <span class=\"toc-text\">3.8 static 关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"3-10- 小结\" href = \"#\"><span class=\"toc-number\">3.8.</span> <span class=\"toc-text\">3.10 小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结\" href = \"#\"><span class=\"toc-number\">3.9.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结\" href = \"#\"><span class=\"toc-number\">3.10.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"4、语句\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">4、语句 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -1\" href = \"#\"><span class=\"toc-number\">4.1.</span> <span class=\"toc-text\"> 警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -1\" href = \"#\"><span class=\"toc-number\">4.2.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"5、操作符和表达式\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">5、操作符和表达式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"5-1 操作符\" href = \"#\"><span class=\"toc-number\">6.</span> <span class=\"toc-text\">5.1 操作符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-1-1 算术操作符\" href = \"#\"><span class=\"toc-number\">6.0.1.</span> <span class=\"toc-text\">5.1.1 算术操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-1-2 移位操作符\" href = \"#\"><span class=\"toc-number\">6.0.2.</span> <span class=\"toc-text\">5.1.2 移位操作符 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-1-3- 位操作符\" href = \"#\"><span class=\"toc-number\">6.0.3.</span> <span class=\"toc-text\">5.1.3 位操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-1-4 赋值\" href = \"#\"><span class=\"toc-number\">6.0.4.</span> <span class=\"toc-text\">5.1.4 赋值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-1-8- 条件操作符\" href = \"#\"><span class=\"toc-number\">6.0.5.</span> <span class=\"toc-text\">5.1.8 条件操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-1-9- 逗号操作符\" href = \"#\"><span class=\"toc-number\">6.0.6.</span> <span class=\"toc-text\">5.1.9 逗号操作符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-1-10- 下标引用、函数调用和结构成员\" href = \"#\"><span class=\"toc-number\">6.0.7.</span> <span class=\"toc-text\">5.1.10 下标引用、函数调用和结构成员</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"5-3 左值和右值\" href = \"#\"><span class=\"toc-number\">6.1.</span> <span class=\"toc-text\">5.3 左值和右值 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"5-4- 表达式求值\" href = \"#\"><span class=\"toc-number\">6.2.</span> <span class=\"toc-text\">5.4 表达式求值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-4-1 隐式类型转换\" href = \"#\"><span class=\"toc-number\">6.2.1.</span> <span class=\"toc-text\">5.4.1 隐式类型转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-4-2- 算术转换\" href = \"#\"><span class=\"toc-number\">6.2.2.</span> <span class=\"toc-text\">5.4.2 算术转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"5-4-3 操作符的属性\" href = \"#\"><span class=\"toc-number\">6.2.3.</span> <span class=\"toc-text\">5.4.3 操作符的属性 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -2\" href = \"#\"><span class=\"toc-number\">6.3.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -2\" href = \"#\"><span class=\"toc-number\">6.4.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"6、指针\" href = \"#\"><span class=\"toc-number\">7.</span> <span class=\"toc-text\">6、指针 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-1- 内存和地址\" href = \"#\"><span class=\"toc-number\">7.1.</span> <span class=\"toc-text\">6.1 内存和地址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-4- 间接访问操作符\" href = \"#\"><span class=\"toc-number\">7.2.</span> <span class=\"toc-text\">6.4 间接访问操作符 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-5- 未初始化和非法指针\" href = \"#\"><span class=\"toc-number\">7.3.</span> <span class=\"toc-text\">6.5 未初始化和非法指针</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-6NULL 指针\" href = \"#\"><span class=\"toc-number\">7.4.</span> <span class=\"toc-text\">6.6NULL 指针</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-7 指针、间接访问和左值\" href = \"#\"><span class=\"toc-number\">7.5.</span> <span class=\"toc-text\">6.7 指针、间接访问和左值 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-8 指针、间接访问和变量\" href = \"#\"><span class=\"toc-number\">7.6.</span> <span class=\"toc-text\">6.8 指针、间接访问和变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-9 指针常量\" href = \"#\"><span class=\"toc-number\">7.7.</span> <span class=\"toc-text\">6.9 指针常量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-10 指针表达式\" href = \"#\"><span class=\"toc-number\">7.8.</span> <span class=\"toc-text\">6.10 指针表达式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"6-13 指针运算\" href = \"#\"><span class=\"toc-number\">7.9.</span> <span class=\"toc-text\">6.13 指针运算 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -3\" href = \"#\"><span class=\"toc-number\">7.10.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结 -1\" href = \"#\"><span class=\"toc-number\">7.11.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"7、函数\" href = \"#\"><span class=\"toc-number\">8.</span> <span class=\"toc-text\">7、函数 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"7-5 递归和迭代\" href = \"#\"><span class=\"toc-number\">8.1.</span> <span class=\"toc-text\">7.5 递归和迭代</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"7-6 可变参数列表\" href = \"#\"><span class=\"toc-number\">8.2.</span> <span class=\"toc-text\">7.6 可变参数列表 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"7-6-1-stdarg 宏\" href = \"#\"><span class=\"toc-number\">8.2.1.</span> <span class=\"toc-text\">7.6.1 stdarg 宏 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -4\" href = \"#\"><span class=\"toc-number\">8.3.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结 -2\" href = \"#\"><span class=\"toc-number\">8.4.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"8、数组\" href = \"#\"><span class=\"toc-number\">9.</span> <span class=\"toc-text\">8、数组 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"8-1 一维数组\" href = \"#\"><span class=\"toc-number\">9.1.</span> <span class=\"toc-text\">8.1 一维数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"8-1-2- 下标引用\" href = \"#\"><span class=\"toc-number\">9.1.1.</span> <span class=\"toc-text\">8.1.2 下标引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"8-1-5- 数组和指针\" href = \"#\"><span class=\"toc-number\">9.1.2.</span> <span class=\"toc-text\">8.1.5 数组和指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"8-1-8 初始化\" href = \"#\"><span class=\"toc-number\">9.1.3.</span> <span class=\"toc-text\">8.1.8 初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"8-2 多维数组\" href = \"#\"><span class=\"toc-number\">9.2.</span> <span class=\"toc-text\">8.2 多维数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"8-2-3- 下标\" href = \"#\"><span class=\"toc-number\">9.2.1.</span> <span class=\"toc-text\">8.2.3 下标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"8-2-4 指向数组的指针\" href = \"#\"><span class=\"toc-number\">9.2.2.</span> <span class=\"toc-text\">8.2.4 指向数组的指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"8-2-5 作为函数参数的多维数组\" href = \"#\"><span class=\"toc-number\">9.2.3.</span> <span class=\"toc-text\">8.2.5 作为函数参数的多维数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"8-2-6 初始化\" href = \"#\"><span class=\"toc-number\">9.2.4.</span> <span class=\"toc-text\">8.2.6 初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"8-3 指针数组\" href = \"#\"><span class=\"toc-number\">9.3.</span> <span class=\"toc-text\">8.3 指针数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -5\" href = \"#\"><span class=\"toc-number\">9.4.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结 -3\" href = \"#\"><span class=\"toc-number\">9.5.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"9、字符串、字符和字节\" href = \"#\"><span class=\"toc-number\">10.</span> <span class=\"toc-text\">9、字符串、字符和字节</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"9-2 字符串长度\" href = \"#\"><span class=\"toc-number\">10.1.</span> <span class=\"toc-text\">9.2 字符串长度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"9-5 字符串查找基础\" href = \"#\"><span class=\"toc-number\">10.2.</span> <span class=\"toc-text\">9.5 字符串查找基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"9-5-1 查找一个字符\" href = \"#\"><span class=\"toc-number\">10.2.1.</span> <span class=\"toc-text\">9.5.1 查找一个字符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"9-5-2 查找任何几个字符\" href = \"#\"><span class=\"toc-number\">10.2.2.</span> <span class=\"toc-text\">9.5.2 查找任何几个字符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"9-5-3 查找一个字串\" href = \"#\"><span class=\"toc-number\">10.2.3.</span> <span class=\"toc-text\">9.5.3 查找一个字串</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"9-6 高级字符串查找\" href = \"#\"><span class=\"toc-number\">10.3.</span> <span class=\"toc-text\">9.6 高级字符串查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"9-6-1 查找一个字符串前缀\" href = \"#\"><span class=\"toc-number\">10.3.1.</span> <span class=\"toc-text\">9.6.1 查找一个字符串前缀</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"9-6-2 查找标记\" href = \"#\"><span class=\"toc-number\">10.3.2.</span> <span class=\"toc-text\">9.6.2 查找标记</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"9-7 错误信息\" href = \"#\"><span class=\"toc-number\">10.4.</span> <span class=\"toc-text\">9.7 错误信息</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"9-8 字符操作\" href = \"#\"><span class=\"toc-number\">10.5.</span> <span class=\"toc-text\">9.8 字符操作 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"9-8-1 字符分类\" href = \"#\"><span class=\"toc-number\">10.5.1.</span> <span class=\"toc-text\">9.8.1 字符分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"9-8-2 字符转换\" href = \"#\"><span class=\"toc-number\">10.5.2.</span> <span class=\"toc-text\">9.8.2 字符转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"9-9 内存操作\" href = \"#\"><span class=\"toc-number\">10.6.</span> <span class=\"toc-text\">9.9 内存操作 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -6\" href = \"#\"><span class=\"toc-number\">10.7.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -3\" href = \"#\"><span class=\"toc-number\">10.8.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"10、结构体和联合\" href = \"#\"><span class=\"toc-number\">11.</span> <span class=\"toc-text\">10、结构体和联合 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"10-1 结构体基础\" href = \"#\"><span class=\"toc-number\">11.1.</span> <span class=\"toc-text\">10.1 结构体基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"10-1-1 结构体声明\" href = \"#\"><span class=\"toc-number\">11.1.1.</span> <span class=\"toc-text\">10.1.1 结构体声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"10-1-3 成员访问\" href = \"#\"><span class=\"toc-number\">11.1.2.</span> <span class=\"toc-text\">10.1.3 成员访问</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"10-1-5 结构体自引用\" href = \"#\"><span class=\"toc-number\">11.1.3.</span> <span class=\"toc-text\">10.1.5 结构体自引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"10-1-6 不完整声明\" href = \"#\"><span class=\"toc-number\">11.1.4.</span> <span class=\"toc-text\">10.1.6 不完整声明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"10-1-7 结构体初始化\" href = \"#\"><span class=\"toc-number\">11.1.5.</span> <span class=\"toc-text\">10.1.7 结构体初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"10-3 结构的存储分配\" href = \"#\"><span class=\"toc-number\">11.2.</span> <span class=\"toc-text\">10.3 结构的存储分配</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"10-4 作为函数参数\" href = \"#\"><span class=\"toc-number\">11.3.</span> <span class=\"toc-text\">10.4 作为函数参数 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"10-5 位段\" href = \"#\"><span class=\"toc-number\">11.4.</span> <span class=\"toc-text\">10.5 位段 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"10-6 联合\" href = \"#\"><span class=\"toc-number\">11.5.</span> <span class=\"toc-text\">10.6 联合 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"10-6-2 初始化\" href = \"#\"><span class=\"toc-number\">11.5.1.</span> <span class=\"toc-text\">10.6.2 初始化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -7\" href = \"#\"><span class=\"toc-number\">11.6.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -4\" href = \"#\"><span class=\"toc-number\">11.7.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"11、动态内存分配\" href = \"#\"><span class=\"toc-number\">12.</span> <span class=\"toc-text\">11、动态内存分配 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"11-3calloc 和 realloc\" href = \"#\"><span class=\"toc-number\">12.1.</span> <span class=\"toc-text\">11.3calloc 和 realloc</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"11-4 使用例\" href = \"#\"><span class=\"toc-number\">12.2.</span> <span class=\"toc-text\">11.4 使用例 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"11-5 常见的动态内存错误\" href = \"#\"><span class=\"toc-number\">12.3.</span> <span class=\"toc-text\">11.5 常见的动态内存错误 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"不要访问被 free 释放的内存\" href = \"#\"><span class=\"toc-number\">12.3.0.1.</span> <span class=\"toc-text\">不要访问被 free 释放的内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"内存泄漏\" href = \"#\"><span class=\"toc-number\">12.3.0.2.</span> <span class=\"toc-text\">内存泄漏 </span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -8\" href = \"#\"><span class=\"toc-number\">12.4.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -5\" href = \"#\"><span class=\"toc-number\">12.5.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"12、使用结构和指针\" href = \"#\"><span class=\"toc-number\">13.</span> <span class=\"toc-text\">12、使用结构和指针 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"12-3 双链表\" href = \"#\"><span class=\"toc-number\">13.1.</span> <span class=\"toc-text\">12.3 双链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"12-3-1 双链表插入操作的优化\" href = \"#\"><span class=\"toc-number\">13.1.1.</span> <span class=\"toc-text\">12.3.1 双链表插入操作的优化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -9\" href = \"#\"><span class=\"toc-number\">13.2.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结 -4\" href = \"#\"><span class=\"toc-number\">13.3.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"13、高级指针话题\" href = \"#\"><span class=\"toc-number\">14.</span> <span class=\"toc-text\">13、高级指针话题 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"13-2 高级声明\" href = \"#\"><span class=\"toc-number\">14.1.</span> <span class=\"toc-text\">13.2 高级声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"13-3 函数指针\" href = \"#\"><span class=\"toc-number\">14.2.</span> <span class=\"toc-text\">13.3 函数指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"13-3-1 回调函数\" href = \"#\"><span class=\"toc-number\">14.2.1.</span> <span class=\"toc-text\">13.3.1 回调函数 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"13-1-2 转换表\" href = \"#\"><span class=\"toc-number\">14.2.2.</span> <span class=\"toc-text\">13.1.2 转换表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"13-4 命令行参数\" href = \"#\"><span class=\"toc-number\">14.3.</span> <span class=\"toc-text\">13.4 命令行参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"13-5 字符串常量\" href = \"#\"><span class=\"toc-number\">14.4.</span> <span class=\"toc-text\">13.5 字符串常量 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -10\" href = \"#\"><span class=\"toc-number\">14.5.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -6\" href = \"#\"><span class=\"toc-number\">14.6.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"14、预处理器\" href = \"#\"><span class=\"toc-number\">15.</span> <span class=\"toc-text\">14、预处理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"14-1 预定义符号\" href = \"#\"><span class=\"toc-number\">15.1.</span> <span class=\"toc-text\">14.1 预定义符号</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"define\" href = \"#\"><span class=\"toc-number\">15.2.</span> <span class=\"toc-text\">#define</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"14-2-1 宏\" href = \"#\"><span class=\"toc-number\">15.2.1.</span> <span class=\"toc-text\">14.2.1 宏 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"14-2-6-undef\" href = \"#\"><span class=\"toc-number\">15.3.</span> <span class=\"toc-text\">14.2.6#undef</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"14-3 条件编译\" href = \"#\"><span class=\"toc-number\">15.4.</span> <span class=\"toc-text\">14.3 条件编译</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"14-3-1 是否被定义\" href = \"#\"><span class=\"toc-number\">15.5.</span> <span class=\"toc-text\">14.3.1 是否被定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"14-4 文件包含\" href = \"#\"><span class=\"toc-number\">15.6.</span> <span class=\"toc-text\">14.4 文件包含 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"避免多重包含\" href = \"#\"><span class=\"toc-number\">15.6.0.1.</span> <span class=\"toc-text\">避免多重包含</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"14-5 其他指令\" href = \"#\"><span class=\"toc-number\">15.7.</span> <span class=\"toc-text\">14.5 其他指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -11\" href = \"#\"><span class=\"toc-number\">15.8.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结 -5\" href = \"#\"><span class=\"toc-number\">15.9.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"15、输入 - 输出函数\" href = \"#\"><span class=\"toc-number\">16.</span> <span class=\"toc-text\">15、输入 &#x2F; 输出函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-1 错误报告\" href = \"#\"><span class=\"toc-number\">16.1.</span> <span class=\"toc-text\">15.1 错误报告</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-2 终止执行\" href = \"#\"><span class=\"toc-number\">16.2.</span> <span class=\"toc-text\">15.2 终止执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-4-ANSI-I-O 概念\" href = \"#\"><span class=\"toc-number\">16.3.</span> <span class=\"toc-text\">15.4 ANSI I&#x2F;O 概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"15-4-1 流\" href = \"#\"><span class=\"toc-number\">16.3.1.</span> <span class=\"toc-text\">15.4.1 流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"15-4-2 文件\" href = \"#\"><span class=\"toc-number\">16.3.2.</span> <span class=\"toc-text\">15.4.2 文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"15-4-3 标准 I-O 常量\" href = \"#\"><span class=\"toc-number\">16.3.3.</span> <span class=\"toc-text\">15.4.3 标准 I&#x2F;O 常量</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-5 流 I-O 总览\" href = \"#\"><span class=\"toc-number\">16.4.</span> <span class=\"toc-text\">15.5 流 I&#x2F;O 总览</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-6 打开流\" href = \"#\"><span class=\"toc-number\">16.5.</span> <span class=\"toc-text\">15.6 打开流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-7 关闭流\" href = \"#\"><span class=\"toc-number\">16.6.</span> <span class=\"toc-text\">15.7 关闭流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-8 字符 I-O\" href = \"#\"><span class=\"toc-number\">16.7.</span> <span class=\"toc-text\">15.8 字符 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-9 未格式化的行 I-O\" href = \"#\"><span class=\"toc-number\">16.8.</span> <span class=\"toc-text\">15.9 未格式化的行 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-10 格式化的行 I-O\" href = \"#\"><span class=\"toc-number\">16.9.</span> <span class=\"toc-text\">15.10 格式化的行 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-10-1-scanf 族\" href = \"#\"><span class=\"toc-number\">16.10.</span> <span class=\"toc-text\">15.10.1 scanf 族</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"15-10-3-printf 族\" href = \"#\"><span class=\"toc-number\">16.10.1.</span> <span class=\"toc-text\">15.10.3 printf 族</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-11 二进制 I-O\" href = \"#\"><span class=\"toc-number\">16.11.</span> <span class=\"toc-text\">15.11 二进制 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-12 刷新和定位函数\" href = \"#\"><span class=\"toc-number\">16.12.</span> <span class=\"toc-text\">15.12 刷新和定位函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-13 改变缓冲方式\" href = \"#\"><span class=\"toc-number\">16.13.</span> <span class=\"toc-text\">15.13 改变缓冲方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"15-14 流错误函数\" href = \"#\"><span class=\"toc-number\">16.13.1.</span> <span class=\"toc-text\">15.14 流错误函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-15 临时文件\" href = \"#\"><span class=\"toc-number\">16.14.</span> <span class=\"toc-text\">15.15 临时文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"15-16- 文件操纵函数\" href = \"#\"><span class=\"toc-number\">16.15.</span> <span class=\"toc-text\">15.16 文件操纵函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -12\" href = \"#\"><span class=\"toc-number\">16.16.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -7\" href = \"#\"><span class=\"toc-number\">16.17.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"16、标准函数库\" href = \"#\"><span class=\"toc-number\">17.</span> <span class=\"toc-text\">16、标准函数库 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -13\" href = \"#\"><span class=\"toc-number\">17.1.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -8\" href = \"#\"><span class=\"toc-number\">17.2.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"17、经典抽象数据类型\" href = \"#\"><span class=\"toc-number\">18.</span> <span class=\"toc-text\">17、经典抽象数据类型 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"17-1 堆栈\" href = \"#\"><span class=\"toc-number\">18.1.</span> <span class=\"toc-text\">17.1 堆栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"接口\" href = \"#\"><span class=\"toc-number\">18.1.1.</span> <span class=\"toc-text\"> 接口 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"17-1-1 静态数组实现\" href = \"#\"><span class=\"toc-number\">18.1.2.</span> <span class=\"toc-text\">17.1.1 静态数组实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"17-1-2 动态数组实现\" href = \"#\"><span class=\"toc-number\">18.1.3.</span> <span class=\"toc-text\">17.1.2 动态数组实现 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"17-1-3 链式堆栈\" href = \"#\"><span class=\"toc-number\">18.1.4.</span> <span class=\"toc-text\">17.1.3 链式堆栈</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"17-2 队列\" href = \"#\"><span class=\"toc-number\">18.2.</span> <span class=\"toc-text\">17.2 队列 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"接口 -1\" href = \"#\"><span class=\"toc-number\">18.2.1.</span> <span class=\"toc-text\"> 接口 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"17-2-1 静态数组实现\" href = \"#\"><span class=\"toc-number\">18.2.2.</span> <span class=\"toc-text\">17.2.1 静态数组实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"17-3 树\" href = \"#\"><span class=\"toc-number\">18.3.</span> <span class=\"toc-text\">17.3 树 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"接口 -2\" href = \"#\"><span class=\"toc-number\">18.3.1.</span> <span class=\"toc-text\"> 接口 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"17-3-1 静态数组实现\" href = \"#\"><span class=\"toc-number\">18.4.</span> <span class=\"toc-text\">17.3.1 静态数组实现 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"17-3-2 链表实现\" href = \"#\"><span class=\"toc-number\">18.4.1.</span> <span class=\"toc-text\">17.3.2 链表实现 </span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"17-4- 实现的改进\" href = \"#\"><span class=\"toc-number\">18.5.</span> <span class=\"toc-text\">17.4 实现的改进</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -14\" href = \"#\"><span class=\"toc-number\">18.6.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结 -6\" href = \"#\"><span class=\"toc-number\">18.7.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"18、运行时环境\" href = \"#\"><span class=\"toc-number\">19.</span> <span class=\"toc-text\">18、运行时环境 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"18-1- 判断运行时环境\" href = \"#\"><span class=\"toc-number\">19.1.</span> <span class=\"toc-text\">18.1 判断运行时环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-2 静态变量和初始化\" href = \"#\"><span class=\"toc-number\">19.1.1.</span> <span class=\"toc-text\">18.1.2 静态变量和初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-3 堆栈帧\" href = \"#\"><span class=\"toc-number\">19.1.2.</span> <span class=\"toc-text\">18.1.3 堆栈帧 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-4 寄存器变量\" href = \"#\"><span class=\"toc-number\">19.1.3.</span> <span class=\"toc-text\">18.1.4 寄存器变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-5 外部标识符的长度\" href = \"#\"><span class=\"toc-number\">19.1.4.</span> <span class=\"toc-text\">18.1.5 外部标识符的长度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-6 判断堆栈帧布局\" href = \"#\"><span class=\"toc-number\">19.1.5.</span> <span class=\"toc-text\">18.1.6 判断堆栈帧布局</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"函数序\" href = \"#\"><span class=\"toc-number\">19.1.5.1.</span> <span class=\"toc-text\">函数序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"堆栈中的参数顺序\" href = \"#\"><span class=\"toc-number\">19.1.5.2.</span> <span class=\"toc-text\">堆栈中的参数顺序 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"最终的堆栈帧布局\" href = \"#\"><span class=\"toc-number\">19.1.5.3.</span> <span class=\"toc-text\">最终的堆栈帧布局</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"函数跋\" href = \"#\"><span class=\"toc-number\">19.1.5.4.</span> <span class=\"toc-text\">函数跋</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"返回值\" href = \"#\"><span class=\"toc-number\">19.1.5.5.</span> <span class=\"toc-text\">返回值</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"18-2C 和汇编语言的接口\" href = \"#\"><span class=\"toc-number\">19.2.</span> <span class=\"toc-text\">18.2C 和汇编语言的接口 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"汇编语言程序调用 C\" href = \"#\"><span class=\"toc-number\">19.2.0.1.</span> <span class=\"toc-text\"> 汇编语言程序调用 C</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"C 调用汇编程序\" href = \"#\"><span class=\"toc-number\">19.2.0.2.</span> <span class=\"toc-text\">C 调用汇编程序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"18-3 运行时效率\" href = \"#\"><span class=\"toc-number\">19.3.</span> <span class=\"toc-text\">18.3 运行时效率 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -15\" href = \"#\"><span class=\"toc-number\">19.4.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -9\" href = \"#\"><span class=\"toc-number\">19.5.</span> <span class=\"toc-text\">编程提示总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示的总结 -7\" href = \"#\"><span class=\"toc-number\">19.6.</span> <span class=\"toc-text\">编程提示的总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"18、运行时环境 -1\" href = \"#\"><span class=\"toc-number\">20.</span> <span class=\"toc-text\">18、运行时环境 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"18-1- 判断运行时环境 -1\" href = \"#\"><span class=\"toc-number\">20.1.</span> <span class=\"toc-text\">18.1 判断运行时环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-2 静态变量和初始化 -1\" href = \"#\"><span class=\"toc-number\">20.1.1.</span> <span class=\"toc-text\">18.1.2 静态变量和初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-3 堆栈帧 -1\" href = \"#\"><span class=\"toc-number\">20.1.2.</span> <span class=\"toc-text\">18.1.3 堆栈帧 </span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-4 寄存器变量 -1\" href = \"#\"><span class=\"toc-number\">20.1.3.</span> <span class=\"toc-text\">18.1.4 寄存器变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-5 外部标识符的长度 -1\" href = \"#\"><span class=\"toc-number\">20.1.4.</span> <span class=\"toc-text\">18.1.5 外部标识符的长度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" data-id=\"18-1-6 判断堆栈帧布局 -1\" href = \"#\"><span class=\"toc-number\">20.1.5.</span> <span class=\"toc-text\">18.1.6 判断堆栈帧布局</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"函数序 -1\" href = \"#\"><span class=\"toc-number\">20.1.5.1.</span> <span class=\"toc-text\">函数序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"堆栈中的参数顺序 -1\" href = \"#\"><span class=\"toc-number\">20.1.5.2.</span> <span class=\"toc-text\">堆栈中的参数顺序 </span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"最终的堆栈帧布局 -1\" href = \"#\"><span class=\"toc-number\">20.1.5.3.</span> <span class=\"toc-text\">最终的堆栈帧布局</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"函数跋 -1\" href = \"#\"><span class=\"toc-number\">20.1.5.4.</span> <span class=\"toc-text\">函数跋</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"返回值 -1\" href = \"#\"><span class=\"toc-number\">20.1.5.5.</span> <span class=\"toc-text\">返回值</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"18-2C 和汇编语言的接口 -1\" href = \"#\"><span class=\"toc-number\">20.2.</span> <span class=\"toc-text\">18.2C 和汇编语言的接口 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"汇编语言程序调用 C-1\" href = \"#\"><span class=\"toc-number\">20.2.0.1.</span> <span class=\"toc-text\"> 汇编语言程序调用 C</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" data-id=\"C 调用汇编程序 -1\" href = \"#\"><span class=\"toc-number\">20.2.0.2.</span> <span class=\"toc-text\">C 调用汇编程序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"18-3 运行时效率 -1\" href = \"#\"><span class=\"toc-number\">20.3.</span> <span class=\"toc-text\">18.3 运行时效率 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"警告的总结 -16\" href = \"#\"><span class=\"toc-number\">20.4.</span> <span class=\"toc-text\">警告的总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"编程提示总结 -10\" href = \"#\"><span class=\"toc-number\">20.5.</span> <span class=\"toc-text\">编程提示总结</span></a></li></ol></li></ol>","categories":[],"tags":[{"name":"读书笔记（技术书籍）","path":"api/tags/读书笔记（技术书籍）.json","url":"/tags/读书笔记（技术书籍）/"}]}